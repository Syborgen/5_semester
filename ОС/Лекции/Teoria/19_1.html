<html>
<head>
<title>ПРОГРАММИРОВАНИЕ НА shell (UNIX)</title>
</head>


<body>
<h1 align="center">Простейшие средства языка SHELL</h1>

<p>Командный  язык  shell  (в  переводе  -  раковина, скорлупа)
фактически  есть  язык программирования очень высокого уровня. На
этом  языке  пользователь  осуществляет  управление  компьютером.
Обычно,  после  входа  в систему вы начинаете взаимодействовать с
командной оболочкой (если угодно - она начинает взаимодействовать
с  вами).  Признаком  того,  что оболочка (shell) готова к приему
команд  служит  выдаваемый  ею  на  экран  промптер. В простейшем
случае это один доллар (&quot;$&quot;).</p>
     <p>Shell  не  является  необходимым  и  единственным  командным
языком  (хотя  именно  он  стандартизован  в  рамках POSIX [POSIX
1003.2]   -   стандарта   мобильных  систем).  Например,  немалой
популярностью  пользуется язык cshell, есть также kshell, bashell
(из  наиболее популярных в последнее время) и другие. Более того,
каждый  пользователь  может  создать  свой  командный язык. Может
одновременно  на одном экземпляре операционной системы работать с
разными командными языками.</p>
<p>     ОБРАТИТЕ  ВНИМАНИЕ.  shell - это одна из многих команд UNIX.
То  есть  в набор команд оболочки (интерпретатора) &quot;shell&quot; входит
команда  &quot;sh&quot;  -  вызов  интерпретатора  &quot;shell&quot;.  Первый &quot;shell&quot;
вызывается  автоматически  при  вашем входе в систему и выдает на
экран промтер. После этого вы можете вызывать на выполнение любые
команды,  в  том  числе  и снова сам &quot;shell&quot;, который вам создаст
новую оболочку внутри прежней.</p>
<p>     Так например, если вы подготовите в редакторе файл &quot;f1&quot;:</p>

<p>     echo Hello!</p>

<p>     то  это  будет  обычный  текстовый  файл, содержащий команду
&quot;echo&quot;, которая при выполнении выдает все написанное правее ее на
экран.  Можно  сделать  файл  &quot;f1&quot;  выполняемым с помощью команды
&quot;chmod  755  f1&quot;. Но его можно ВЫПОЛНИТЬ, вызвав явно команду (!)
&quot;sh&quot; (&quot;shell&quot;):</p>

<p>     sh f1</p>

<p>или<p>

     <p>sh &lt; f1</p>

     <p>Файл  можно  выполнить  и  в текущем экземпляре &quot;shell&quot;. Для
этого существует специфическая команда &quot;.&quot; (точка), т.е.</p>

     <p>. f1</p>

     <p>ВАЖНОЕ   ПРЕДУПРЕЖДЕНИЕ.  Не  начинайте  командные  файлы  с
символа  &quot;#&quot;, хотя естественно начинать его с комментария. Дело в
том,  что  такой  командный файл в оболочке C-Shell (&quot;csh&quot;) будет
интерпретирован  как  выполняемый  в  &quot;csh&quot;,  в  результате будет
активизирован. интерпретатор &quot;csh&quot;.</p>
     <p>СОВЕТ.  Начинайте  командный  sh-файл  с  пустой  строки или
пустого оператора &quot;:&quot;.</p>
     <p>Поскольку  UNIX  -  система многопользовательская, вы можете
даже  на персональном компьютере работать параллельно, скажем, на
12-ти  экранах  (переход  с  экрана  на  экран ALT/функциональная
клавиша),  имея  на  каждом  экране нового (или одного и того же)
пользователя со своей командной оболочкой. Можете и в графическом
режиме X-Window также открыть большое число окон, а в каждом окне
может быть свой свой пользователь со своей командной оболочкой...</p>
     <p>Стержневым элементом языка shell является команда.</p>


<h3>Структура команд</h3>
		  

<p>     Команды в shell обычно имеют следующий формат:</p>

<p>     &lt;имя команды&gt; &lt;флаги&gt; &lt;аргумент(ы)&gt;</p>

<p>     Например:</p>

<p>     ls  -ls  /usr/bin</p>

<p>     где ls - имя команды выдачи содержимого директория, -ls  - флаги ( &quot;-&quot; - признак флагов, l - длинный формат, s - об'ем файлов в блоках).</p>
<p>     /usr/bin -  директорий, для которого выполняется команда.</p>
<p>     Эта  команда  выдаст  на  экран в длинном формате содержимое
директория  /usr/bin,  при  этом  добавит  информацию  о  размере
каждого файла в блоках.
<p>     К сожалению, такая структура команды выдерживается далеко не
всегда.  Не  всегда перед флагами ставится минус, не всегда флаги
идут   одним   словом.   Есть   разнообразие  и  в  представлении
аргументов.   К   числу  команд,  имеющих  экзотические  форматы,
относятся  и такие &quot;ходовые&quot; команды, как сс, tar, dd, find и ряд
других.
<p>     Как    правило  (но   не   всегда),   первое   слово   (т.е.
последовательность  символов  до  пробела,  табуляции  или  конца
строки)  shell воспринимает,  как  команду.  Поэтому  в командной
строке

<p>     cat cat

<p>     первое   слово   будет   расшифровано  shell,   как  команда
(конкатенации),  которая   выдаст  на  экран  файл с именем &quot;cat&quot;
(второе слово), находящийся в текущем директории.


<h3>Группировка команд.</h3>


<p>Средства группировки:
<p>     ;   и   &lt;перевод   строки&gt;   -  определяют  последовательное
выполнение команд;
<p>     &amp; - асинхронное (фоновое) выполнение предшествующей команды;
<p>     &amp;&amp;  - выполнение последующей команды при условии нормального
завершения предыдущей, иначе игнорировать;
<p>     ||   -   выполнение  последующей  команды  при  ненормальном
завершении предыдущей, иначе игнорировать.

<p>     При  выполнении  команды в асинхронном режиме (после команды
стоит   один   амперсенд)  на  экран  выводится  номер  процесса,
соответствующий  выполняемой  команде,  и  система, запустив этот
фоновый процесс, вновь выходит на диалог с пользователем.
<p>     Например,  наберем  (экзотическую)  команду &quot;find&quot; в фоновом
режиме  для  поиска  в  системе  ,  начиная от корня &quot;/&quot;, файла с
именем  &quot;conf&quot;,  а  затем  &quot;pwd&quot; в обычном режиме. На экране этот
фрагмент будет выглядеть следующим образом:
<p>

<pre>--------------------------------
| $ find / -name conf -print &amp; | ввод команды &quot;find&quot;
|                              |
| 288                          | номер (PID) фонового процесса
|                              |
| $ pwd                        | ввод команды &quot;pwd&quot;
|                              |
| /mnt/lab/asu                 | результат работы &quot;pwd&quot;
|                              |
| $                            | возвращение shell в промптер
|                              |
| /usr/include/sys/conf        | результат работы &quot;find&quot;
|                              |
--------------------------------</pre>

<p>     Иногда  необходимо,  чтобы все фоновые процессы завершились,
прежде  чем  будет  выполняться какой-то расчет. Для этого служит
специальная  команда  &quot;wait  [PID]&quot;.  Эта команда ждет завершения
указанного   идентификатором  (числом)  фонового  процесса.  Если
команда  без  параметра,  то  она  ждет  завершения  всех фоновых
процессов, дочерних для данного &quot;sh&quot;.

<p>     Для  группировки  команд также могут использоваться фигурные
&quot;{}&quot;  и  круглые  &quot;()&quot;  скобки.  Рассмотрим  примеры,  сочетающие
различные способы группировки:

<p>     Если введена командная строка

<p>     k1 &amp;&amp; k2; k3

<p>     где  k1, k2 и k3 - какие-то команды, то &quot;k2&quot; будет выполнена
только  при  успешном  завершении  &quot;k1&quot;;  после любого из исходов
обработки  &quot;k2&quot; (т.е. &quot;k2&quot; будет выполнена, либо пропущена) будет
выполнена &quot;k3&quot;.

<p>     k1 &amp;&amp; {k2; k3}

<p>     Здесь  обе  команды (&quot;k2&quot; и &quot;k3&quot;) будут выполнены только при
успешном завершении &quot;k1&quot;.

<p>     {k1; k2} &amp;

<p>     В фоновом режиме будет выполняться последовательность команд
&quot;k1&quot; и &quot;k2&quot;.

<p>     Фоновые   процессы   (как   и   теневую   экономику)  сложно
уничтожить,  поскольку  традиционная  команда  &quot;CTL/C&quot;  прерывает
только   процессы   переднего  плана.  Для  уничтожения  фонового
процесса  надо  знать его номер. При запуске фонового процесса на
экран  выдается  число,  соответствующее  номеру (идентификатору)
этого  процесса  (PID). Если этот номер забыт или надо убедиться,
что этот процесс не закончен, с помощью команды

<p>	ps -aux

<p>     можно  получить  перечень  идентификаторов  процессов (PID),
имена  пользователей,  текущее  время,  затраченное процессами, и
т.д.
<p>     В   выведенной   таблице   можно   найти  номера  процессов,
подлежащих   уничтожению,  например  это  &quot;849&quot;  и  &quot;866&quot;.  Тогда
командой

<p>	kill -9  866 849

<p>     можно  уничтожить  эти  процессы.  При уничтожении процессов
надо вы должны иметь то же имя пользователя, какое было приписано
уничтожаемым   процессам   (или   иметь   имя  привилегированного
пользователя).

<p>     ПРЕДУПРЕЖДЕНИЕ.    Если   параллельно   обрабатывается   или
создается  файл с ОДНИМ именем (например, несколько пользователей
вызвали  в  редактор  один и тот же файл), то в системе продолжит
существование  тот  вариант  файла, который возвращен (записан) в
систему  последним.  Это частая ошибка пользователей персональных
компьютеров,   которые   редактируют   один  файл  параллельно  с
нескольких экранов.

 <p>    Круглые  скобки  &quot;()&quot;, кроме выполнения функции группировки,
выполняют  и  функцию  вызова  нового  экземпляра  интерпретатора
shell.
 <p>    Пусть мы находились в начальном каталоге &quot;/mnt/lab/asu&quot;
<p>     Тогда в последовательности команд

<p>     cd ..; ls; ls

<p>     две  команды  &quot;ls&quot; выдадут 2 экземпляра содержимого каталога
&quot;/mnt/lab&quot;, а последовательность
<p>     (cd ..; ls) ls
<p>     выдаст  сначала  содержимое  каталога  &quot;/mnt/lab&quot;,  а  затем
содержимое  &quot;/mnt/lab/asu&quot;,  т.к.  при  входе в скобки вызывается
новый   экземпляр  shell,  в  рамках  которого  и  осуществляется
переход. При выходе из круглых скобок происходит возврат в старый
shell и в старый каталог.


<h3>Перенаправление команд</h3>

<p>     Стандартный ввод (вход) - &quot;stdin&quot; в ОС UNIX осуществляется с
клавиатуры  терминала,  а  стандартный  вывод  (выход) - &quot;stdout&quot;
направлен  на  экран терминала. Существует еще и стандартный файл
диагностических  сообщений  - &quot;stderr&quot;, о котором речь будет чуть
позже.
<p>     Команда,  которая  может  работать  со  стандартным входом и
выходом, называется ФИЛЬТРОМ.
<p>     Пользователь  имеет удобные средства перенаправления ввода и
вывода   на   другие  файлы  (устройства).  Символы  &quot;&gt;&quot;  и  &quot;&gt;&gt;&quot;
обозначают перенаправление вывода.

<p>	ls &gt;f1

<p>     команда  &quot;ls&quot;  сформирует  список файлов текущего каталога и
поместит его в файл &quot;f1&quot; (вместо выдачи на экран). Если файл &quot;f1&quot;
до этого существовал, то он будет затерт новым.

<p>     pwd &gt;&gt;f1

<p>     команда  pwd  сформирует  полное  имя  текущего  каталога  и
поместит его в конец файла &quot;f1&quot;, т.е. &quot;&gt;&gt;&quot; добавляет в файл, если
он непустой.
<p>     Символы &gt; и &lt; обозначают перенаправление ввода.

<p>     wc -l&gt; &gt;f1

<p>подсчитает и выдаст на экран число строк в файле f1.

<p>     ed f2&gt; &lt;&gt;!

<p>     создаст    с    использованием    редактора    файл    &quot;f2&quot;,
непосредственно  с  терминала.  Окончание  ввода  определяется по
символу,  стоящему  правее  &quot;&gt;&lt;&gt;&quot;  (т.е  &quot;!&quot;).  То есть ввод будет
закончен, когда первым в очередной строке будет &quot;!&quot;.
<p>     Можно сочетать перенаправления. Так

<p>    wc -l&gt; <f3 >f4   и   wc -l &gt;f4 &lt;f3

<p>     выполняются одинаково: подсчитывается число строк файла &quot;f3&quot;
и результат помещается в файл &quot;f4&quot;.
<p>     Средство,  объединяющее  стандартный  выход одной команды со
стандартным  входом  другой, называется КОНВЕЙЕРОМ и обозначается
вертикальной чертой &quot;|&quot;.

<p>     ls  | wc -l

<p>     список  файлов  текущего  каталога  будет  направлен на вход
команды &quot;wc&quot;, которая на экран выведет число строк каталога.
<p>     Конвейером  можно  об'единять и более двух команд, когда все
они, возможно кроме первой и последней - фильтры:

<p>     cat f1 | grep -h result | sort | cat -b &gt; f2

<p>     Данный  конвейер  из  файла &quot;f1&quot; (&quot;cat&quot;) выберет все строки,
содержащие   слово   &quot;result&quot;   (&quot;grep&quot;),   отсортирует  (&quot;sort&quot;)
полученные  строки,  а  затем  пронумерует  (&quot;cat  -b&quot;) и выведет
результат в файл &quot;f2&quot;.
<p>     Поскольку  устройства  в  ОС  UNIX представлены специальными
файлами,  их можно использовать при перенаправлениях. Специальные
файлы  находятся  в  каталоге  &quot;/dev&quot;.  Например,  &quot;lp&quot; - печать;
&quot;console&quot;  -  консоль; &quot;ttyi&quot; - i-ый терминал; &quot;null&quot; - фиктивный
(пустой) файл (устройство).
<p>     Тогда,  например,

<p>     ls &gt; /dev/lp

<p>     выведет  содержимое  текущего каталога на печать, а

<p>     f1 &lt; /dev/null  обнулит  файл &quot;f1&quot;.

<p>     sort f1 | tee /dev/lp | tail -20

<p>     В  этом  случае  будет  отсортирован  файл &quot;f1&quot; и передан на
печать, а 20 последних строк также будут выданы на экран.

<p>     Вернемся  к  перенаправлению выхода. Стандартные файлы имеют
номера:  0  -  stdin,  1  -  stdout  и  2  -  stderr. Если вам не
желательно  иметь  на  экране  сообщение  об  ошибке,  вы  можете
перенаправить  его  с  экрана  в  указанный вами файл (или вообще
&quot;выбросить&quot;,   перенаправив   в   файл   &quot;пустого  устройства&quot;  -
/dev/null). Например при выполнении команды

<p>     cat f1 f2

<p>     которая  должна  выдать  на экран последовательно содержимое
файлов &quot;f1&quot; и &quot;f2&quot;, выдаст вам, например, следующее

<p>    111111 222222

<p>    cat: f2: No such file or directory

<p>где 111111 222222 - содержимое файла &quot;f1&quot;, а файл &quot;f2&quot; отсутствует,
о чем команда &quot;cat&quot; выдала сообщение в стандартный файл диагностики,
по умолчанию, как и стандартный выход, представленный экраном.
<p>     Если  вам не желательно такое сообщение на экране, его можно
перенаправить в указанный вами файл:

<p>     cat f1 f2 2&gt;f-err

<p>     сообщения  об  ошибках  будут  направляться (об этом говорит
перенаправление  &quot;2&gt;&quot;)  в  файл  &quot;f-err&quot;.  Кстати,  вы можете всю
информацию  направлять  в  один  файл  &quot;ff&quot;, использовав в данном
случае конструкцию

<p>     cat f1 f2 &gt;&gt;ff 2&gt;ff

<p>     Можно   указать   не  только  какой  из  стандартных  файлов
перенаправлять,   но  и  в  какой  стандартный  файл  осуществить
перенаправление.

<p>     cat f1 f2 2&gt;&gt;ff 1&gt;&amp;2

<p>     Здесь    сначала   &quot;stderr&quot;   перенаправляется   (в   режиме
добавления)    в   файл   &quot;ff&quot;,   а   затем   стандартный   выход
перенаправляется  на  &quot;stderr&quot;,  которым к этому моменту является
файл &quot;ff&quot;. То есть результат будет аналогичен предыдущему.
<p>     Конструкция &quot;1&gt;&amp;2&quot; - означает, что кроме номера стандартного
файла,  в который перенаправить,  необходимо впереди ставить &quot;&amp;&quot;;
вся конструкция пишется без пробелов.
<p>     &lt;&amp;-   - закрывает стандартный ввод.
<p>     &gt;&amp;-   - закрывает стандартный вывод.


<h3>Генерация имен файлов.</h3>

<p>     При генерации имен используют метасимволы:
<p>     *   -   произвольная  (возможно  пустая)  последовательность
символов;
<p>     ? - один произвольный символ;
<p>     [...] - любой из символов, указанных в скобках перечислением
и/или с указанием диапазона;

<p>     cat f* - выдаст все файлы каталога, начинающиеся с &quot;f&quot;;
<p>     cat *f* - выдаст все файлы, содержащие &quot;f&quot;;
<p>     cat   program.?   -   выдаст   файлы   данного   каталога  с
однобуквенными расширениями, скажем &quot;program.c&quot; и &quot;program.o&quot;, но
не выдаст &quot;program.com&quot;;
<p>     cat  [a-d]*  -  выдаст файлы, которые начинаются с &quot;a&quot;, &quot;b&quot;,
&quot;c&quot;, &quot;d&quot;. Аналогичный эффект дадут и команды &quot;cat [abcd]*&quot; и
&quot;cat [bdac]*&quot;.


<h3>Командные файлы.</h3>

<p>     Для  того,  чтобы текстовый файл можно было использовать как
команду, существует несколько возможностей.
<p>     Пусть  с  помощью  редактора  создан  файл  с  именем &quot;cmd&quot;,
содержащий одну строку следующего вида:

<p>     date; pwd; ls

<p>     Можно  вызвать  shell  как команду (!), обозначаемую &quot;sh&quot;, и
передать  ей  файл &quot;cmd&quot;,  как  аргумент или как перенаправленный
вход, т.е.

<p>      $  sh cmd    или     $ sh &lt;cmd

<p>     В  результате  выполнения  любой из этих команд будет выдана
дата, затем имя текущего каталога, а потом содержимое каталога.
<p>     Более интересный и удобный вариант работы с командным файлом
-  это  превратить  его  в  выполняемый,  т.е. просто сделать его
командой,  что достигается изменением кода защиты. Для этого надо
разрешить выполнение этого файла.
<p>     Например,

<p>     chmod  711 cmd

<p>     сделает код защиты &quot;rwx__x__x&quot;. Тогда простой вызов

<p>     cmd

<p>     приведет к выполнению тех же трех команд.
<p>     Результат будет тот же, если файл с содержимым

<p>     date; pwd; ls

<p>представлен в виде:

<p>	  date
<p>	  pwd
<p>	  ls

<p>     так как переход на другую строку также является разделителем
в последовательности команд.
<p>     Таким  образом,  выполняемыми  файлами  могут быть не только
файлы,  полученные  в результате компиляции и сборки, но и файлы,
написанные  на  языке  shell.  Их  выполнение происходит в режиме
интерпретации с помощью shell-интерпретатора
<p>     Еще  раз  отметим,  что  shell-интерпретатор, это всего лишь
одна   из   сотен  команд  ОС  UNIX,  имеющая  равные  с  прочими
привилегии.
</pre>
</body>
</html>
