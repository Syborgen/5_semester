<HTML>
<HEAD>
<TITLE>Графические интерфейсы пользователя</TITLE>
</HEAD>
<BODY>
  <b><font size="6"><center>Графические интерфейсы пользователя</center></font></b><br>
  <br>
  На персональных компьютерах могут использоваться символьные интерфейсы. В течение 
  нескольких лет доминировала система MS-DOS с символьным интерфейсом. Однако 
  теперь на большинстве персональных компьютеров используется <b>графический интерфейс 
  пользователя</b> (GUI, Graphical User Interface). Сокращение GUI произносится 
  как &laquo;гуи&raquo; (&laquo;gooey&raquo;).<br>
<dd> Графический интерфейс пользователя был придуман Дугласом Энгельбартом и его 
  исследовательской группой в Стенфордском исследовательском институте. Затем 
  этот интерфейс был скопирован исследователями из Xerox PARC. Однажды Стив Джобе, 
  один из основателей компании Apple, посетив PARC, увидел графический интерфейс 
  пользователя на компьютере Xerox. Это натолкнуло его на мысль о создании нового 
  компьютера, которым стал компьютер Lisa фирмы Apple, появившийся в 1983 году. 
  Lisa была слишком дорогой машиной и поэтому она не получила коммерческого успеха, 
  но ее преемник Macintosh, разработанный годом позже, стал крайне популярен. 
  Компьютер Apple Macintosh оказал значительное влияние на систему Windows, первая 
  версия которой была представлена корпорацией Microsoft в 1985 году, а также 
  на другие системы с графическим интерфейсом пользователя.<br>
<dd> Графический интерфейс пользователя состоит из четырех основных элементов, 
  из первых букв английских названий которых можно сложить слово WIMP (Windows, 
  Icons, Menus, Pointing device — окна, пиктограммы, меню, указывающее устройство). 
  Окна представляют собой прямоугольные участки экрана, используемые для запуска 
  программ. Пиктограммами называются небольшие символы, на которых можно щелкнуть 
  мышью, чтобы вызвать какое-либо действие. Меню являются списками действий, из 
  которых может быть выбрано одно. Наконец, указывающее устройство — это мышь, 
  шаровой манипулятор или другое устройство, используемое для перемещения курсора 
  по экрану и для выбора элементов.<br>
<dd> Программное обеспечение графического интерфейса пользователя может быть реализовано 
  либо на уровне пользователя, как это делается в семействе систем UNIX, либо 
  включено в саму операционную систему, как в случае Windows. В следующих разделах 
  мы познакомимся с аппаратурой и программным обеспечением ввода и вывода для 
  графического интерфейса пользователя персональных компьютеров. В первую очередь 
  будет обсуждаться операционная система Windows, однако основные понятия действительны 
  и для других графических интерфейсов пользователя.<br>
  <br>
  <br>
<a NAME="01"></a>
  <b><font size="4">Аппаратное обеспечение клавиатуры, мыши и дисплея персонального 
  компьютера</font></b><br>
  <br>
  Все современные персональные компьютеры оснащены клавиатурами и растровым графическим 
  дисплеем с изображением, отображаемым в памяти компьютера. Эти компоненты составляют 
  части самого компьютера. Однако в современном персональном компьютере клавиатура 
  и экран являются полностью раздельными устройствами, каждое со своим собственным 
  драйвером.<br>
<dd> Связь с клавиатурой может осуществляться через последовательный порт, параллельный 
  порт или порт USB. При нажатии любой клавиши центральный процессор прерывается, 
  и драйвер клавиатуры извлекает символ, читая порт ввода-вывода. Все остальное 
  осуществляется программно, в основном в драйвере клавиатуры.<br>
<dd> На Pentium-компьютерах клавиатура содержит встроенный микропроцессор, общающийся 
  с микросхемой контроллера, расположенной на материнской плате, через специальный 
  последовательный порт. Прерывание возникает при каждом нажатии, а также при 
  каждом отпускании клавиши. Аппаратная часть клавиатуры поставляет в порт не 
  ASCII-код клавиши, а ее номер, или, как его еще называют, скан-код. Например, 
  при нажатии клавиши А в регистр ввода-вывода помещается код клавиши 30. При 
  этом драйвер должен решить, был ли этот символ строчным, прописным или частью 
  какой-либо комбинации клавиш вроде CTRL+A, ALT+A, CTRL+ALT+A и т. д. Для этого 
  драйвер должен запоминать все нажатые, но еще не отпущенные клавиши (например, 
  SHIFT).<br>
<dd> Например, последовательность действий<br>
  <br>
  <font face="Arial">Нажать SHIFT, нажать А, отпустить А, отпустить SHIFT</font><br>
  <br>
<dd> означает прописной символ А. Однако последовательность действий<br>
  <br>
  <font face="Arial">Нажать SHIFT, нажать А. отпустить SHIFT, отпустить А</font><br>
  <br>
<dd> также означает прописной символ А. Поскольку клавиатурный интерфейс возлагает 
  всю тяжесть обработки на программное обеспечение, он является исключительно 
  гибким. Например, программе пользователя может быть небезразлично, введена ли 
  цифра с верхней линейки клавиш или с правой цифровой клавиатуры. В принципе 
  драйвер может предоставить такую информацию.<br>
<dd> У большинства персональных компьютеров имеется мышь или, в некоторых случаях, 
  шаровой манипулятор, представляющий собой обычную мышь, лежащую на спине. Наиболее 
  распространенный тип компьютерных мышей содержит в себе резиновый шар, выглядывающий 
  из отверстия в днище мыши и вращающийся, когда мышь двигается по столу или коврику. 
  При вращении шар поворачивает прижатые к нему резиновые ролики, закрепленные 
  на перпендикулярных осях. При движении мыши с запада на восток вращается ось 
  <i>х,</i> а движение мыши с севера на юг заставляет вращаться ось <i>у.</i> 
  Когда мышь преодолевает по столу определенное минимальное расстояние или нажимается 
  или отпускается одна из кнопок мыши, мышь посылает компьютеру сообщение. Обычно 
  это минимальное расстояние, которое некоторые люди называют &laquo;мики&raquo;, 
  составляет около 0,1 мм. У мышей может быть одна, две или три кнопки, в зависимости 
  от оценки разработчиками интеллектуальных способностей пользователей — смогут 
  ли они работать более чем с одной клавишей.<br>
<dd> Сообщение, посылаемое компьютеру, содержит три параметра: изменения позиции 
  по координатам х и у, dх и dу и состояние кнопок. Формат сообщения зависит от 
  системы и числа кнопок мыши. Обычно оно занимает 3 байт. Большинство мышей способно 
  передавать до 40 сообщений в секунду, поэтому может оказаться, что с момента 
  последнего сообщения мышь переместилась на несколько мики.<br>
<dd> Обратите внимание, что мышь сообщает только об изменениях своей позиции, 
  а не об абсолютном значении позиции. Если мышь аккуратно поднять и снова положить, 
  так что шарик не повернется, то сообщений послано не будет.<br>
<dd> Некоторые графические интерфейсы пользователя отличают однократный щелчок 
  мыши от двойного щелчка. Если два щелчка мыши достаточно близки в <a href="../comment.html#12">пространстве</a> 
  (в миках) и во времени (доли секунды), операционная система сигнализирует о 
  двойном щелчке мыши. Временной интервал, отличающий двойной щелчок от двух независимых 
  щелчков, а также скорость перемещения курсора мыши по экрану могут быть программно 
  настроены пользователем.<br>
<dd> Рассмотрим теперь аппаратную часть дисплея. Дисплеи могут быть разделены 
  на две основные категории: устройства с <b>векторной графикой</b> и устройства 
  с <b>растровой графикой</b>. Векторные графические устройства могут выполнять 
  такие команды, как вывод точек, рисование линий, геометрических фигур и текста. 
  У растровых графических устройств, напротив, область вывода представляет собой 
  прямоугольную сетку точек, называемых <b>пикселами</b>, каждая из которых может 
  принимать различные значения яркости или цвета. В ранние дни эпохи компьютеростроения 
  векторные графические устройства встречались довольно часто, но в наши дни единственными 
  векторными графическими устройствами остались плоттеры. Все остальные графические 
  устройства используют растровую графику.<br>
<dd> Растровые графические дисплеи реализуются при помощи специального устройства, 
  называемого <b>графическим адаптером</b>. Графический адаптер содержит специальную 
  память, называемую <b>видео-ОЗУ</b> или <b>видеопамятью</b> и образующую часть 
  адресного пространства компьютера. Это означает, что центральный процессор обращается 
  к ней так же, как и к остальной оперативной памяти (рис. 5.32). Здесь хранится 
  образ экрана либо в символьном, либо в растровом виде. В символьном виде каждый 
  байт (или два байта) видеопамяти содержат один отображаемый символ. В растровом 
  виде каждый пиксел экрана представляется в видеопамяти отдельно. На каждый пиксел 
  отводится от одного бита для простейшего бинарного черно-белого изображения 
  до 24 бит для цветного дисплея высокого качества.<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_30.jpg" alt="Дисплей с общей памятью"><br>
    <br>
    <b><font face="Arial">Рис. 5.32.</font></b><font face="Arial"> Дисплей с общей 
    памятью</font><br>
    <br>
  </center>
<dd> Кроме того, в состав графического адаптера входит микросхема, называющаяся 
  <b>видеоконтроллером</b>. Эта микросхема получает символы из видеопамяти и формирует 
  соответствующий им видеосигнал, посылаемый на монитор. Монитор формирует луч 
  электронов, сканирующий экран в горизонтальном направлении. Обычно на экран 
  выводится от 480 до 1024 горизонтальных линий с количеством точек на линию от 
  640 до 1200. Сигнал видеоконтроллера модулирует электронный луч, определяя яркость 
  каждого пиксела. У цветных мониторов три луча, для красного, зеленого и синего 
  цветов, модулируемые независимо друг от друга. В плоских мониторах также используются 
  пикселы трех цветов, но принципы работы этих мониторов выходят за рамки данной 
  книги.<br>
<dd> Видеоконтроллеры могут работать в двух режимах: символьном (используемом 
  для простого текста) и растровом (для всего остального). В символьном виде контроллер 
  преобразует каждый символ в прямоугольник пикселов размером 9x14 (включая промежутки 
  между символами) и составляет из них экран из 25 строк по 80 символов. Для этого 
  дисплей должен иметь 350 линий по 720 пикселов в каждой. Чтобы избежать мерцания, 
  каждый кадр должен перерисовываться от 60 до 100 раз в секунду.<br>
<dd> Для вывода текста на экран видеоконтроллер должен взять из видеопамяти первые 
  80 символов, сформировать для них 14 горизонтальных линий, которые подать на 
  монитор, затем взять следующие 80 символов и т. д. Контроллер может также брать 
  из видеопамяти по одному символу, что позволяет обойтись без буферизации символов 
  в контроллере. Растры шрифтов 9x14 бит хранятся в ПЗУ, используемым видеоконтроллером. 
  (ОЗУ может также использоваться для поддержки настраиваемых шрифтов.) Адресация 
  обращений к ПЗУ 12-разрядная, 8 бит для кода символа и 4 бит для линии развертки. 
  Восемь бит в каждом байте ПЗУ управляют 8 пикселами, 9-й пиксел между символами 
  всегда пустой. Таким образом, для вывода строки текста на экран требуется 14 
  х 80 = 1120 обращений к памяти. Такое же число обращений требуется к знакогенератору 
  в ПЗУ.<br>
<dd> На рис. 5.33, <i>а</i> показана часть видеопамяти дисплея, работающего в 
  символьном режиме. Каждый символ на экране (рис. 5.33, б) занимает в видеопамяти 
  два байта. Младший байт слова содержит ASCII-код отображаемого символа. В старшем 
  байте слова хранятся атрибуты символа, означающие его цвет, мерцание, инверсию 
  и т. д. Для экрана из 25 строк по 80 символов требуется 4000 байт видеопамяти.<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_31.jpg" alt="Видеопамять монохромного дисплея, работающего в символьном виде (а); соответствующий экран (б). Символами х обозначены байты атрибутов"><br>
    <br>
    <b><font face="Arial">Рис. 5.33.</font></b><font face="Arial"> Видеопамять 
    монохромного дисплея, работающего в символьном виде (а);<br>
    соответствующий экран (б). Символами х обозначены байты атрибутов<br>
    </font><br>
  </center>
<dd> При работе дисплея в графическом режиме используются те же принципы, с той 
  разницей, что каждый пиксел экрана управляется индивидуально и каждому пикселу 
  соответствует своя область (от 1 до 24 бит) в видеопамяти. В простейшем случае 
  бинарного изображения каждому пикселу экрана соответствует один бит видеопамяти. 
  В случае высококачественного изображения на каждый пиксел приходится 24 бит 
  видеопамяти, по 8 бит для интенсивности красного, зеленого и синего цветов. 
  Представление цвета в виде разложения на составляющие интенсивности красного, 
  зеленого и синего цветов, называющееся по первым буквам их английских названий 
  RGB (Red, Green, Blue), обусловлено свойствами восприятия человеческого глаза.<br>
<dd> Размеры современных растровых графических экранов варьируются в широких пределах. 
  Самые распространенные стандарты: 640x480 (VGA), 800x600 (SVGA), 1024x768 (XGA), 
  1280x1024 и 1600x1200 пикселов. Все эти экраны, кроме 1280x1024, имеют соотношение 
  размеров сторон 4:3, что соответствует стандартным телевизионным трубкам (NTSC 
  или PAL/SECAM), и, следовательно, позволяет использовать квадратные пикселы. 
  Размер 1280x1024 должен был на самом деле быть 1280x960, но привлекательность 
  числа 1024, видимо, была слишком велика, чтобы противостоять этому искушению, 
  несмотря на то что пикселы при этом слегка искажаются и преобразования в другие 
  размеры усложняются. Цветному дисплею, работающему в режиме 1024x768 с 24 бит 
  на пиксел, необходимо 2,25 Мбайт ОЗУ только для хранения изображения. Если весь 
  экран обновляется 75 раз в секунду, видеопамять должна доставлять данные с постоянной 
  скоростью 169 Мбайт/с.<br>
<dd> Чтобы избежать необходимости управлять такими большими областями памяти, 
  во многих системах имеется возможность использовать меньшее цветовое разрешение. 
  В простейшей схеме каждый пиксел представляется 8-разрядным числом. Оно обычно 
  не содержит самого цвета пиксела, а является индексом в таблице цветов, состоящей 
  из 256 24-разрядных элементов формата RGB. Эта таблица, называемая цветовой 
  палитрой и позволяющая экрану содержать в любой момент 256 произвольных цветов, 
  часто реализуется аппаратно. При изменении, например, элемента 7 цветовой палитры, 
  изменятся цвета всех пикселов, содержащих байт 7. Использование 8-разрядной 
  цветовой палитры позволяет в три раза сократить размер, требуемый для хранения 
  изображения, за счет более грубого цветового разрешения. Цветовая палитра также 
  применяется в схеме сжатия изображений GIF (Graphics Interchange Format — формат 
  графического обмена).<br>
<dd> Также применяются цветовые палитры с 16 битами на пиксел. В этом случае цветовая 
  палитра содержит 65 536 элементов, что позволяет одновременно использовать до 
  65 536 цветов. Такая схема позволяет достичь гораздо более качественной цветопередачи, 
  однако размер требуемой видеопамяти при этом методе сокращается всего лишь на 
  одну треть по сравнению с 24-разрядными пикселами. К тому же сама цветовая палитра 
  размером 65 536 элементов по 3 байт (192 Кбайт) тоже должна где-то храниться. 
  Если она хранится аппаратно (чтобы избежать затрат времени на дополнительные 
  обращения к оперативной памяти), хранение такой палитры требует существенно 
  больше аппаратных буферов памяти, чем в случае 8-разрядной цветовой палитры.<br>
<dd> Возможно и хранение в 16-разрядных пикселах значений цвета в формате RGB 
  с 5 бит на цвет, с одним битом лишним (можно выделить зеленой составляющей цвета 
  6 бит, так как человеческий глаз более чувствителен именно к зеленому цвету.) 
  В результате может получиться система, схожая с 24-разрядным цветом, но с меньшим 
  числом градаций яркости для каждого цвета.<br>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Программное обеспечение ввода</font></b><br>
  <br>
  Получив символ, клавиатурный драйвер должен начать его обработку. Поскольку 
  программным обеспечением используются коды символов, а не скан-коды клавиш, 
  получаемые драйвером от клавиатуры, драйвер должен преобразовать скан-коды в 
  символы с помощью таблицы. Не все IBM-совместимые компьютеры используют стандартные 
  скан-коды клавиш, поэтому, чтобы драйвер мог поддерживать различные клавиатуры, 
  он должен осуществлять эти преобразования при помощи различных таблиц. Проще 
  всего включить нужную таблицу в драйвер во время компиляции драйвера. Однако 
  такой подход усложняется тем фактом, что огромному количеству пользователей 
  требуется набирать тексты на языках, отличных от английского. В различных странах 
  клавиатуры организуются по-разному, и даже в странах, использующих шрифты на 
  основе латиницы, применяются различные акцентированные буквы, перечеркнутые 
  буквы и т. п., а также знаки пунктуации, отсутствующие в английском языке.<br>
<dd> Для достижения большей гибкости в настройке <a href="../comment.html#13">раскладок 
  клавиатуры</a> многие операционные системы предоставляют загружаемые <b>кодовые 
  страницы</b> или, как их еще называют, <b>карты клавиш.</b> Они позволяют выбирать 
  способ преобразования скан-кодов клавиш в символы, предоставляемые приложению, 
  либо во время загрузке системы, либо позднее.<br>
  <br>
  <br>
<a NAME="03"></a>
  <b><font size="4">Программное обеспечение вывода для Windows</font></b><br>
  <br>
  Программное обеспечение вывода для графического интерфейса пользователя представляет 
  собой весьма обширную тему. Только о графическом интерфейсе пользователя системы 
  Windows написано множество книг по полторы тысячи страниц (например, [265, 303, 
  271]). Очевидно, в этом разделе мы сможем лишь поверхностно коснуться этой темы 
  и познакомиться с некоторыми основными концепциями. Чтобы обсуждение было более 
  конкретным, мы опишем программный интерфейс приложения Windows API, поддерживаемый 
  всеми 32-разрядными версиями системы Windows. Программное обеспечение вывода 
  для других графических интерфейсов пользователя значительно отличается в деталях, 
  но в первом приближении имеет много общего с Windows API.<br>
<dd> Базовым элементом любого графического интерфейса пользователя является прямоугольная 
  область экрана, называемая <b>окном. </b> Положение окна и его размеры однозначно 
  определяются координатами (в пикселах) двух противоположных углов окна. Окно 
  может содержать заголовок, меню, вертикальную и горизонтальную полосы прокрутки. 
  Типичное окно показано на рис. 5.34. Обратите внимание, что система координат, 
  принятая в Windows, помещает начало координат в левый верхний угол, а координата 
  <i>y</i> увеличивается сверху вниз, что отличается от картезианской системы 
  координат, принятой в математике.<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_32.jpg" alt="Пример окна, расположенного на экране XGA-дисплея"><br>
    <br>
    <b><font face="Arial">Рис. 5.34.</font></b><font face="Arial"> Пример окна, 
    расположенного на экране XGA-дисплея</font><br>
    <br>
  </center>
<dd> При создании окна параметрами указывается, может ли это окно перемещаться 
  пользователем, может ли пользователь изменять его размеры, будут ли у него полосы 
  прокрутки и т. п. Главное окно большинства программ обычно можно перемещать, 
  изменять его размеры и прокручивать его содержимое при помощи полос прокрутки 
  с ползунками. Все эти возможности оказывают огромное влияние на способ написания 
  программ. В частности, программы должны получать информацию об изменении размеров 
  их окон и должны быть готовы в любое время перерисовать содержимое своих окон, 
  даже когда они совсем этого не ждут.<br>
<dd> Это привело к тому, что программы в системе Windows управляются сообщениями. 
  Действия пользователя, включая работу с клавиатурой или мышью, перехватываются 
  системой Windows и преобразуются в сообщения, адресуемые программе, владеющей 
  окнами, к которым обращены действия пользователя. У каждой программы есть очередь 
  сообщений, в которую направляются все сообщения, относящиеся к ее окнам. Главный 
  цикл программы состоит из получения следующего сообщения и обработки его с помощью 
  вызова внутренней процедуры, соответствующей данному типу сообщений. В некоторых 
  случаях система Windows может вызывать эти процедуры напрямую, минуя очередь 
  сообщений. Эта модель принципиально отличается от используемой в системе UNIX 
  модели процедурных программ, для взаимодействия с операционной системой обращающихся 
  к системным вызовам.<br>
<dd> Поясним программную модель, применяемую в системе Windows, на примере программы, 
  приведенной в листинге 5.2. Здесь мы видим скелет основной программы для системы 
  Windows. Она не закончена и не содержит обработки ошибок, но для наших целей 
  она включает достаточно подробностей. Программа начинается с оператора включения 
  файла заголовка <i>windows.h</i>, содержащего большое количество макросов, определений 
  типов данных, констант, прототипов функций и другой информации, необходимой 
  для программ, работающих в системе Windows.<br>
  <br>
  <center>
    <b><font face="Arial">Листинг 5.2.</font></b><font face="Arial"> Скелет основной 
    программы для системы Windows</font><br>
    <br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="860" HEIGHT="26">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD width="860" height="24"> #include &lt;windows.h&gt;<br>
          int WINAPI WinMain(HINSTANCE h, HINSTANCE hprev, char *szCmd, int iCmdShow)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{WNDCLASS wndclass;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          /* объект класса для этого окна */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MSG msg;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          /* здесь сохраняются входящие сообщения */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; HWND hwnd;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          /* дескриптор (указатель) объекта окна */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp; 
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          /* Инициализация объекта wndclass */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.lpfnWndProc = WndProc;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp 
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp&nbsp; /* адрес 
          процедуры обратного вызова */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.lpszClassName = 
          "Program name"; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* текст 
          строки заголовка */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.hIcon = LoadIcon(NULL, 
          IDI_APPLICATION);&nbsp;&nbsp;&nbsp; /* загрузить пиктограмму программы 
          */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; wndclass.hCursor = LoadCursor(NULL, 
          IDC_ARROW); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* загрузить курсор мыши */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RegisterClass(&wndclass); 
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp; 
          /* сообщить системе Windows об объекте wndclass */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; hwnd = CreateWindow ( ... 
          ); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp&nbsp;&nbsp; 
          /* запросить память для окна */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShowWindow(hwnd, iCmdShow); 
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* отобразить 
          окно на экране */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UpdateWindow(hwnd); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp 
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          /* сообщение окну с требованием перерисовки */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (GetMessage(&msg, NULL, 
          0, 0))&nbsp;&nbsp; /* получить сообщение из очереди */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{TranslateMessage(&msg); 
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          /* транслировать сообщение */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          DispatchMessage(&msg); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp 
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* послать сообщение msg соответствующей 
          процедуре */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return(msg.wParam);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
          <br>
          long CALLBACK WndProc(HWND hwnd, UINT message, UINT wParam, long lParam)<br>
          /* Здесь помещаются определения */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp {switch (message)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp 
          {case WM_CREATE: ... ; return ... ; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 
          создать окно */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp&nbsp; 
          case WM_PAINT: ... ; return ... ; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp 
          /* перерисовать содержимое окна */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp&nbsp; 
          case WM_DESTROY: ... ; return ... ; &nbsp;&nbsp;&nbsp;&nbsp;/* уничтожить 
          окно */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp&nbsp; return(DefWindowProc(hwnd, 
          message, wParam, lParam));&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp 
          /* по умолчанию */<br>
          } </TD>
      </TR>
    </table>
  </center>
  <br>
<dd> Основная программа начинается с описания, содержащего ее имя и параметры. 
  Макрос <i>WINAPI</i> представляет собой указание компилятору использовать определенное 
  соглашение о передаче параметров и не будет нас дальше интересовать. Первый 
  параметр, <i>h,</i> является дескриптором (описателем) экземпляра, используемым 
  для идентификации программы в системе. В определенном смысле интерфейс Win32 
  является объектно-ориентированным, это означает, что на этом уровне система 
  Windows содержит объекты (например, программы, файлы и окна) с их состоянием 
  и связанными с ними программами, называемыми методами, работающими с этим состоянием. 
  Обращения к объектам производятся при помощи дескрипторов, в качестве которых 
  используются указатели на объекты (адреса объектов). В данном случае <i>h</i> 
  однозначно идентифицирует программу. Второй параметр более не используется и 
  присутствует только ради обратной совместимости. Третий параметр, <i>szCmd,</i> 
  представляет собой заканчивающийся нулевым байтом текст, содержащий командную 
  строку запуска данной программы, даже если программа не была запущена из командной 
  строки. Четвертый параметр, <i>iCmdShow,</i> сообщает, должно ли окно программы 
  при запуске занять весь экран, часть экрана или окно должно быть минимизировано.<br>
<dd> Это описание процедуры иллюстрирует широко используемое соглашение фирмы 
  Microsoft, называемое <b>венгерской нотацией</b>. Название передразнивает так 
  называемую польскую нотацию, придуманную польским логиком И. Лукасевичем для 
  представления алгебраических формул без использования скобок. Венгерская нотация 
  была изобретена венгерским программистом из корпорации Microsoft Чарльзом Шимоньи. 
  Она состоит в использовании первых нескольких символов идентификаторов для указания 
  его типа. Среди допустимых символов и типов с (character — символ), w (word 
  — слово, сегодня означает 16-разрядное целое без знака), i (integer — 32-разрядное 
  целое со знаком), 1 (long — также 32-разрядное целое со знаком), s (string — 
  строка), sz (строка, завершающаяся нулевым байтом), р (pointer — указатель), 
  fn (function — функция) и h (handle — дескриптор). Так, <i>szCmd</i> представляет 
  собой строку, завершающуюся нулем, a <i>iCmdShow —</i> целое число. Многие программисты 
  полагают, что в подобном указании типа переменных в их именах мало пользы и 
  оно лишь затрудняет чтение программ для системы Windows. В системе UNIX подобные 
  соглашения не используются.<br>
<dd> С каждым окном должен быть связан объект класса, описывающий его свойства. 
  В листинге 5.2 таким объектом класса является <i>wndclass.</i> У объекта типа 
  <i>WNDCLASS</i> 10 полей, четыре из которых инициализируются в листинге 5.2. 
  В реальной программе остальные шесть также следует проинициализировать. Наиболее 
  важным полем является l<i>pfnWndProc, </i> представляющим собой указатель типа 
  long (то есть 32-разрядный) на функцию, обрабатывающую сообщения, направляемые 
  окну. Другие поля, инициализируемые в этом примере, сообщают, какую пиктограмму 
  использовать в окне, какой использовать курсор мыши, и задают строку заголовка.<br>
<dd> После инициализации объекта <i>wndclass </i> вызывается процедура <i>RegisterClass,</i> 
  чтобы передать его системе. Так, после этого вызова система Windows знает, какую 
  процедуру вызывать для обработки различных событий, не устанавливаемых в очередь 
  сообщений. Следующий вызов <i>CreateWindow </i> запрашивает у системы область 
  памяти под структуру данных окна и возвращает дескриптор окна для последующих 
  обращений к нему. Затем программа вызывает еще две системные процедуры, чтобы 
  вывести окно на экран и нарисовать его содержимое.<br>
<dd> Затем программа входит в главный цикл, состоящий из получения сообщения, 
  выполнения с ним определенных преобразований и передачи его снова системе на 
  обработку. Для обработки сообщения система вызывает процедуру <i>WndProc.</i> 
  В принципе все эти действия можно было организовать проще, но такая архитектура 
  программ сложилась исторически, и теперь мы вынуждены с ней работать.<br>
<dd> Следом за основной программой располагается процедура <i>WndProc,</i> обрабатывающая 
  различные сообщения, посылаемые окну. Ключевое слово <i>CALLBACK</i> (обратный 
  вызов) здесь, как и слово <i>WINAPI </i> выше, указывает используемое соглашение 
  о передаче параметров процедуры. Первый параметр процедуры — дескриптор окна. 
  Второй параметр содержит тип сообщения. В третьем и четвертом параметрах передается 
  дополнительная информация.<br>
<dd> Сообщения <i>WM_CREATE</i> и <i>WM_DESTROY, </i> извещающие о создании и 
  уничтожении окна, посылаются в начале и в конце работы программы. Они предоставляют 
  программе возможность, например, запросить буферы памяти для работы, а затем 
  вернуть память системе.<br>
<dd> Сообщение третьего типа, <i>WM_PAINT, </i> является указанием программе заполнить 
  окно. Оно может посылаться приложению не только при первой прорисовке окна, 
  но также и во время работы программы. В отличие от безоконных текстовых систем, 
  программы в системе Windows не могут рассчитывать на то, что все, что они когда-либо 
  выведут на экран, будет оставаться там вечно. Поверх одного окна может быть 
  выведено или перетащено другое окно, открыты меню, диалоговые окна и всплывающие 
  подсказки. При удалении этих элементов окно должно быть перерисовано. Чтобы 
  сообщить программе, что окно следует перерисовать, система Windows посылает 
  ей сообщение <i>WM_PAINT.</i> В нем также предоставляется информация о том, 
  какая часть окна должна быть перерисована, что облегчает работу программе, позволяя 
  перерисовать только часть окна.<br>
<dd> Система Windows может заставить программу что-нибудь сделать двумя способами. 
  Во-первых, система может послать программе сообщение, добавив его к очереди 
  сообщений. Этот метод используется для ввода с клавиатуры, мыши и для сигналов 
  от таймеров. Другой способ состоит в непосредственном вызове системой процедуры 
  <i>WndProc.</i> Этот метод используется для всех прочих событий. Поскольку после 
  полной обработки сообщения система Windows уведомляется об этом, она может воздержаться 
  от отправки следующего сообщения до того, как будет обработано предыдущее. Таким 
  образом удается избежать возникновения ситуации состязаний.<br>
<dd> В системе Windows используется огромное количество сообщений различных типов. 
  Чтобы избежать некорректного поведения программы в случае прихода неожиданного 
  сообщения, в конце процедуры <i>WndProc </i> следует помещать обращение к системной 
  процедуре <i>DefWindowProc,</i> таким образом, позволяя обработчику по умолчанию 
  позаботиться обо всех остальных случаях.<br>
<dd> Подведем итоги вышесказанного. Программа, работающая в системе Windows, обычно 
  создает одно или несколько окон, для каждого из которых создается объект класса. 
  С каждой программой связаны очередь сообщений и набор процедур обработки. В 
  конечном итоге поведением программ управляют поступающие события, обрабатывающиеся 
  специальными процедурами. Эта модель принципиально отличается от подхода, принятого 
  в системе UNIX.<br>
<dd> Собственно выводом на экран занимается пакет, состоящий из нескольких сот 
  процедур, образующих вместе <b>интерфейс графических устройств (GDI,</b> Graphic 
  Device Interface). Этот пакет может обрабатывать текст и все виды графики. Он 
  разрабатывался с расчетом на независимость от платформ и устройств. Прежде чем 
  программа может начать вывод в окне, она должна получить <b>контекст устройства</b>, 
  представляющий собой внутреннюю структуру данных, содержащую свойства окна: 
  текущий шрифт, цвет текста, цвет фона и т. д. Большинство процедур интерфейса 
  GDI используют контекст устройства либо для вывода, либо для получения или установки 
  свойств.<br>
<dd> Существуют различные способы получения контекста устройства. Простой пример 
  его получения и использования выглядит так:<br>
  <br>
<font face="Arial"> 
<dd> hdc = GetDC(hwnd);<br>
<dd> TextOut(hdc, х, у, psText, iLength);<br>
</font> 
<dd><font face="Arial"> ReleaseDC(hwnd, hdc);<br>
  </font><br>
<dd> Первый оператор получает дескриптор контекста устройства, <i>hdc.</i> Во 
  второй строке программы контекст устройства используется для вывода на экран 
  строки текста. В параметрах процедуры указываются координаты начала печати <i>(х, 
  у),</i> указатель на строку и ее длина. Третий вызов освобождает контекст устройства, 
  сообщая системе, что программа закончила вывод. Обратите внимание, что контекст 
  устройства <i>hdc</i> используется аналогично дескриптору файла в UNIX. Кроме 
  того, следует заметить, что процедура <i>ReleaseDC </i> содержит избыточные 
  параметры. Дескриптор контекста устройства <i>hdc</i> однозначно указывает окно. 
  Использование избыточной информации, не требующейся для работы программы, довольно 
  распространено в системе Windows.<br>
<dd> Также следует заметить, что при получении контекста устройства <i>hdc</i> 
  программа может писать только в клиентскую область окна, но не в заголовок строку 
  состояния и т. п. В структуре данных контекста устройства внутренне поддерживается 
  область отсечения. Любой вывод за пределы области отсечения игнорируется. Однако 
  есть другая системная процедура, <i>GetWindowDC, </i> также позволяющая получить 
  контекст устройства. Эта процедура устанавливает область отсечения, равную всему 
  окну. Другие вызовы ограничивают область отсечения по-другому. Наличие в системе 
  нескольких вызовов, выполняющих практически одно и то же, является еще одной 
  характеристикой системы Windows.<br>
<dd> Конечно, невозможно представить в этой книге полное описание работы с интерфейсом 
  графических устройств. Читатели, которых интересует данная тема, могут найти 
  дополнительную информацию в ссылках на литературу, приведенных выше. Тем не 
  менее следует, возможно, сказать еще несколько слов о важности интерфейса GDI. 
  Интерфейс GDI содержит различные процедуры, позволяющие получать и освобождать 
  контексты устройств, получать информацию о контекстах устройств, получать и 
  задавать атрибуты контекстов устройств (например, цвет фона), управлять такими 
  объектами интерфейса GDI, как перья, кисти и шрифты, у каждого из которых есть 
  свои атрибуты. Естественно, что интерфейс GDI содержит большое число процедур 
  для собственно рисования на экране.<br>
<dd> Процедуры графического вывода можно разделить на четыре категории: рисование 
  прямых и кривых линий, вывод заполненных областей, управление растровыми изображениями 
  и вывод текста. Пример вывода текста уже был приведен нами выше, поэтому давайте 
  познакомимся с другими функциями. Вызов<br>
  <br>
<dd> <font face="Arial">Rectangle(hdc, xleft, ytop, xright, ybottom);</font><br>
  <br>
<dd> рисует на экране заполненный прямоугольник, заданный координатами противоположных 
  углов: <i>(xleft, ytop)</i> и <i>(xright, ybottom).</i> Например,<br>
  <br>
<dd> <font face="Arial">Rectangle(hdc, 2, 1, 6, 4);</font><br>
  <br>
<dd> выведет на экран прямоугольник, показанный на рис. 5.35. Толщина линии и 
  цвет заливки задаются контекстом устройства. Другие обращения к интерфейсу GDI 
  выглядят аналогично.<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_33.jpg" alt="Пример прямоугольника, нарисованного с помощью процедуры Rectangle. Каждый квадрат соответствует одному пикселу"><br>
    <br>
    <b><font face="Arial">Рис. 5.35.</font></b><font face="Arial"> Пример прямоугольника, 
    нарисованного с помощью процедуры Rectangle.<br>
    Каждый квадрат соответствует одному пикселу</font><br>
  </center>
  <br>
  <br>
  <b>Растровые изображения</b><br>
  <br>
  Процедуры интерфейса GDI являются примерами векторной графики. Они используются 
  для помещения на экран геометрических фигур и текста. Выводимые объекты легко 
  могут быть масштабированы для вывода на большие или меньшие экраны, при условии 
  что число пикселов на экране <a href="../comment.html#14">одинаково</a>. Вывод 
  объектов также в большой степени независим от устройств. Набор обращений к процедурам 
  GDI может быть собран в файл, описывающий сложные операции рисования. Такой 
  файл в системе Windows называется <b>метафайлом.</b> Метафайлы широко применяются 
  для передачи изображений от одной программы Windows к другой. Расширение у таких 
  файлов <i>.wmf.</i><br>
<dd> Многие программы системы Windows позволяют пользователю скопировать изображение 
  (или часть его) и поместить в буфер обмена Windows. Затем пользователь может 
  перейти к другой программе и вставить содержимое буфера обмена в другой документ. 
  Один из способов реализации данных действий состоит в представлении изображения 
  в виде метафайла и помещении его в буфер обмена в формате <i>.wmf.</i> Существуют 
  также и другие методы.<br>
<dd> Не все изображения, с которыми работают компьютеры, могут быть созданы при 
  помощи векторной графики. Например, в фотографиях и видеофильмах векторная графика 
  не используется. Напротив, изображения в данном случае сканируются, в результате 
  чего получается прямоугольная матрица цветных точек. Затем у каждой ячейки квадратной 
  сетки измеряются и преобразуются в число значения интенсивности красного, зеленого 
  и синего цвета. Все эти данные сохраняются в виде значения одного пиксела. Изображение, 
  состоящее из таких пикселов, называют <b>растровым</b>. В системе Windows имеется 
  широкий набор средств для работы с растровыми изображениями.<br>
<dd> Растровые изображения применяются также для вывода текста. Одни из способов 
  представления символов каким-либо шрифтом состоит в использовании небольших 
  растровых изображений. В этом случае вывод текста на экран превращается в перемещение 
  растровых изображений.<br>
<dd> Для работы с растровыми изображениями часто используется процедура <i>bitblt.</i> 
  Она вызывается следующим образом:<br>
  <br>
<dd> <font face="Arial">BitBlt(dsthdc, dx, dy, wid, ht, srchdc, sx, sy, rasterop);</font><br>
  <br>
<dd> В простейшем случае она копирует растровое изображение из одного прямоугольника 
  в другой (возможно, в другом окне). Первые три параметра указывают окно, в которое 
  будет скопирован прямоугольник, и координаты в этом окне. Следом указываются 
  ширина и высота прямоугольника, после которых задаются окно, из которого копируется 
  прямоугольник, и координаты в нем. Обратите внимание, что у каждого окна есть 
  своя система координат с началом (0,0) в верхнем левом углу окна. Последний 
  параметр будет описан ниже. Эффект вызова<br>
  <br>
<dd> <font face="Arial">BitBlt(hdc2, 1, 2, 5, 7, hdc1, 2, 2, SRCCOPY);</font><br>
  <br>
<dd> показан на рис. 5.36. Обратите внимание, что скопированной оказалась вся 
  область 5x7 пикселов символа А, включая цвет фона.<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_34.jpg" alt="Копирование растровых изображений с помощью процедуры BitBIt: до (а); после (б)"><br>
    <br>
    <b><font face="Arial">Рис. 5.36.</font></b><font face="Arial"> Копирование 
    растровых изображений с помощью процедуры BitBIt: до (<i>а</i>); после (<i>б</i>)</font><br>
  </center>
  <br>
<dd> Процедура <i>BitBIt</i> может не только копировать растровые изображения. 
  Последний параметр процедуры дает возможность выполнять с растровыми изображениями 
  побитовые логические операции, что позволяет объединять растровые изображения. 
  Например, к ним можно применить логическую операцию ИЛИ или сложение по модулю 
  2.<br>
<dd> Недостатком растровых изображений является сложность их масштабирования. 
  Символ размера 8x12 точек выглядит вполне разумно на экране с разрешением 640x480 
  пикселов. Однако при копировании этого растрового изображения на печатаемый 
  лист с разрешением 1200 точек на дюйм, что соответствует разрешению 10200x13200 
  точек на листе, ширина символа (8 пикселов) окажется равной 8/1200 дюйма или 
  около 0,17 мм. Кроме того, копирование с одного устройства на другое усложняется 
  различными цветовыми свойствами устройств.<br>
<dd> По этой причине системой Windows также поддерживается структура данных, называемая 
  <b>аппаратно-независимым растровым изображением</b> (<b>DIB,</b> Device-Independent 
  Bitmap). Изображение такого формата хранится в файлах с расширением <i>.bтр.</i> 
  В этих файлах помимо пикселов хранятся информационные заголовки и цветовая таблица. 
  Такие данные облегчают копирование растровых изображений между несхожими устройствами.<br>
  <br>
  <br>
  <b>Шрифты</b><br>
  <br>
  В системе Windows, предшествовавших версии Windows 3.1, символы представлялись 
  в виде растровых изображений и копировались на экран или принтер с помощью процедуры 
  <i>BitBlt.</i> Проблема была в том, что, как уже было продемонстрировано, растровое 
  изображение, годящееся для экрана, слишком мало для принтера. К тому же для 
  каждого символа каждого размера требовался отдельный растр. Другими словами, 
  при наличии растрового изображения символа А размером в 10 точек нет способа 
  вычислить его для 12-точечного шрифта. Для каждого символа каждого шрифта размером 
  от 4 до 120 точек понадобится огромное количество растровых изображений. Вся 
  система при этом оказывалась крайне неуклюжей.<br>
<dd> Решение этой проблемы было предложено при помощи шрифтов TrueType, представляющих 
  собой не растровые изображения, а контуры символов. Каждый символ определяется 
  последовательностью точек по своему периметру. С помощью такой системы символы 
  легко увеличиваются и уменьшаются. Все, что нужно для этого сделать — это умножить 
  координаты каждой точки на один и тот же множитель. Это позволяет масштабировать 
  символы, задавая любой, даже нецелый, размер шрифта. После задания нужного размера 
  точки периметра символа соединяются друг с другом при помощи нехитрого алгоритма, 
  напоминающего картинку-загадку для детей (в последнее время для получения более 
  гладких результатов используются сплайны). Когда контур полностью обведен, символ 
  может быть закрашен. Пример нескольких символов трех различных размеров показан 
  на рис. 5.37.<br>
<dd> Таким образом, промасштабировав контур символа и преобразовав его в растровое 
  изображение, можно гарантировать, что символы, изображаемые на экране и печатаемые 
  на принтере, будут близки, насколько это возможно, отличаясь только ошибками 
  квантования. Чтобы еще более увеличить качество, можно каждый символ снабдить 
  подсказками, помогающими в выполнении растеризации. Например, обе засечки у 
  буквы Т должны быть идентичными, что может не получиться вследствие ошибок округления.<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_35.jpg" alt="Несколько примеров контуров символов различных размеров"><br>
    <br>
    <b><font face="Arial">Рис. 5.37.</font></b><font face="Arial"> Несколько примеров 
    контуров символов различных размеров</font><br>
  </center>
</BODY>
</HTML>
