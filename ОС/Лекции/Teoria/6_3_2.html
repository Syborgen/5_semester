<html>
</style>
<body lang=RU style='tab-interval:36.0pt'>

<h1 align="center">Виртуальная и физическая память</h1> 

<p>Оперативная память является, пожалуй, одним из наиболее дорогих ком&shy;понентов компьютерной системы. Ранние системы UNIX имели в своем
распоряжении 64 Кбайт оперативной памяти, и это количество было явно
недостаточным, современные компьютеры обладают гигабайтами опера&shy;тивной памяти,
но и этого уже мало.</p> 

<p>Оперативная память может быть представлена в виде последовательности байтов, каждый из которых имеет свой уникальный адрес, называемый <i>физическим адресом. </i>Именно эти адреса в конечном счете использует про&shy;цессор, обмениваясь данными с оперативной памятью. Однако адресное пространство процесса существенным образом отличается от адресного пространства физической оперативной памяти. Представим себе, что ад&shy;ресное
пространство процесса непосредственно отображалось бы в опера&shy;тивную память,
другими словами, что адреса, используемые процессом, являлись бы физическими адресами. При таком подходе на пути создания многозадачной системы нас ожидал бы ряд непреодолимых препятствий:</p> 

<p>- Во-первых, трудно себе представить механизм, защищающий адрес&shy;ное
пространство одного процесса, от адресного пространства дру&shy;гого или, что более важно, от адресного
пространства самой опера&shy;ционной
системы. Поскольку каждый процесс работает с физиче&shy;скими адресами, нет никакой гарантии, что процесс
не обратится к. ячейкам памяти,
принадлежащим другим процессам или ядру систе&shy;мы. Последствия такого обращения скорее всего будут весьма пла&shy;чевными.</p> 

<p>- Во-вторых, уже на этапе компиляции необходимо было бы преду&shy;смотреть распределение существующего физического
адресного про&shy;странства. При запуске
каждый процесс должен занимать непрерыв&shy;ную и непересекающуюся область
физических адресов.</p> 

<p>О В-третьих, подобное распределение памяти
между процессами вряд ли можно назвать оптимальным. Объем
физической оперативной памяти будет существенным образом
ограничивать число процессов, одновременно выполняющихся в системе. Так восемь процессов,
каждый из которых занимает 1 Мбайт памяти,
исчерпают 8 Мбайт оперативной памяти,
а операционная система при средней загрузке насчитывает более 80 процессов!</p> 

<p>Все перечисленные проблемы преодолимы с помощью виртуальной памя&shy;ти. При этом адреса, используемые приложениями и самим ядром, не обя&shy;заны соответствовать физическим адресам. Виртуальные адреса трансли&shy;руются или отображаются в физические на аппаратном уровне при актив-Ном участии ядра операционной системы.</p> 

<p>Смысл виртуальной памяти заключается в том, что каждый процесс вы&shy;полняется в собственном <i>виртуальном
адресном пространстве. </i>Виртуальное адресное
пространство — настоящий рай для процесса. Во-первых, у про&shy;цесса создается ощущение исключительности - - ведь все адресное про&shy;странство
принадлежит только ему. Во-вторых, он больше не ограничен объемом физической памяти - - виртуальная память может значительно превышать физическую. В результате процессы становятся изолированны&shy;ми друг от друга и не имеют возможности (даже при желании) &quot;хозяйничать&quot; в адресном пространстве соседа. Физическая
память распре&shy;деляется максимально эффективно - - она не зависит
от распределения виртуальной памяти отдельного процесса.</p> 

<p>Очевидно, что
для реализации виртуальной памяти необходим управляе&shy;мый механизм отображения виртуального адреса в физический. В совре&shy;менных компьютерных системах процесс отображения
выполняется на ап&shy;паратном уровне (с помощью MMU), обеспечивая высокую скорость трансляции.
Операционная система осуществляет управление этим про&shy;цессом.</p> 

<p>Современные процессоры, как правило, поддерживают объединение ад&shy;ресного пространства в области переменного размера — <i>сегменты </i>и облас&shy;ти фиксированного размера — <i>страницы.
</i>При этом для каждого сегмента или страницы может
быть задано собственное отображение виртуальных адресов в
физические.</p> 

<p>На рис. 3.4 показана взаимосвязь между виртуальным и физическим ад&shy;ресным пространством. Виртуальное адресное пространство процесса, кak правило,
является последовательным в рамках уже знакомых нам сегмен&shy;тов -- кода, данных, стека и библиотек. Расположение соответствующих
областей физической памяти может иметь фрагментированный характер, позволяя оптимально распределять память между процессами.</p> 

<p><img width=578 height=324 src="2Part2_.files/image002.jpg"></p> 

<p>размер виртуальной памяти может существенно превышать размер физи&shy;ческой за счет использования <i>вторичной
памяти </i>или <i>области свопинга — </i>как правило, дискового пространства, где могут сохраняться временно не используемые
участки адресного пространства процесса. Например, если при выполнении процесса происходит обращение к виртуальному адресу, для которого присутствует соответствующая
страница физической памяти, операция
чтения или записи завершится успешно. Если страница в опера&shy;тивной памяти отсутствует, процессор генерирует
аппаратное прерывание, называемое <i>страничной ошибкой </i>(page fault), в ответ на которое ядро опреде&shy;ляет положение
сохраненного содержимого страницы в области свопинга, считывает страницу в память, устанавливает параметры отображения вирту&shy;альных
адресов в физические и сообщает процессору о необходимости по&shy;вторить операцию. Все эти действия невидимы для приложения, которое работает с виртуальной памятью.</p> 

<p>Механизм отображения виртуальных адресов в физические (трансляция адреса) существенным образом зависит от конкретной аппаратной реали&shy;зации. Чтобы наше обсуждение не носило слишком абстрактного характе&shy;ра, в этом разделе рассмотрим механизм отображения виртуальных адресов в
физические в операционной системе SCO UNIX на примере семейства процессоров Intel. Однако, как и для остальных подсистем UNIX, основ&shy;ные принципы отличаются мало, и данное изложение поможет читателю
представить механизмы управления памятью и разобраться, при необхо&shy;димости, в конкретной реализации.</p> 

<h3>Сегменты</h3> 

<p>Семейство процессоров Intel позволяет разделить память на несколько логических частей, называемых <i>&gt;сегментами.
</i>При этом адресное простран&shy;ство процесса может быть представлено
в виде нескольких логических сегментов, каждый из которых состоит
из непрерывной последовательно&shy;сти адресов, лежащих в заданном диапазоне. Трансляция
адресов, осно&shy;ванная на сегментации, предусматривает однозначное отображение
адре&shy;сов сегмента в непрерывную
последовательность физических адресов. Вир&shy;туальный адрес при этом состоит из двух частей: <i>селектора сегмента </i>и <i>смещения </i>относительно начала сегмента. Селектор (точнее, поле селектора INDEX) указывает на так называемый <i>дескриптор
сегмента, </i>содержащий такие параметры, как его расположение
в памяти, размер и права доступа.</p> 

<p>Процессор поддерживает косвенную адресацию сегментов через дескрип&shy;торы
сегментов, которые располагаются в специальных таблицах — облас&shy;тях памяти, на которые указывают предназначенные для этого регистры
Процессора. Ядро операционной системы отвечает за заполнение этих таб&shy;лиц и
установку значений регистров. Другими словами, ядро задает ото&shy;бражение, а процессор выполняет отображение на аппаратном уровне. Благодаря такой косвенной адресации логические сегменты защищены Друг от друга, что обеспечивает целостность адресного пространства про&shy;цесса
и ядра.</p> 

<p>Дескрипторы сегментов расположены в двух системных таблицах — <i>локальной таблице дескрипторов </i>(Local
Descriptor Table - LDT) и <i>глобаль-ной таблице дескрипторов </i>(Global Descriptor Table -- GDT). Как следует из названия, LDT обеспечивает трансляцию виртуальных адресов
сег-| ментов процесса, в то время как GDT обслуживает адресное пространст-во ядра (например,
при обработке системного вызова или прерывания). Для каждого процесса создается
собственная LDT, в то время как GDT разделяется всеми процессами. Информация о таблице, на
которую ука-зывает селектор, находится в
самом селекторе, вид которого представлен] на рис. 3.5.</p> 

<p><img width=426 height=90 src="2Part2_.files/image004.jpg"></p> 

<p>Если бит TI равен 0, то селектор указывает на GDT, в противном случае
используется LDT. Поле rpl задает уровень привилегий сегмента и явля-ется одним из механизмов обеспечения защиты сегментов. Например, если процесс, находясь в режиме задачи, попытается обратиться к сегменту, принадлежащему ядру, процессор сгенерирует особую ситуацию, в ответ на это ядро отправит процессу сигнал sigsegv.</p> 

<p>Каждая запись LDT или GDT является дескриптором сегмента. Определе-| но несколько типов дескрипторов, используемых для сегментов кода, дан-ных и стека, а
также ряд дескрипторов, с помощью которых обеспечивает&shy;ся многозадачность и передача управления от непривилегированной зада&shy;чи, например, процесса в режиме задачи, к
привилегированной задаче, например, ядру. Дескрипторы, используемые в
последнем случае, называ&shy;ются <i>шлюзами.</i></p> 

<p>Дескрипторы сегментов (кода, данных, стека) имеют несколько полей:</p> 

<p>Базовый адрес - В этом поле
хранится 32-битный адрес начала сегмента. Процессор добавляет к нему
смещение и получает 32-битный линейный адрес.</p> 

<p>Предел - Это
поле определяет размер сегмента. Если результирующий линейный
адрес выходит за пределы сегмента, процессор гене&shy;рирует особую ситуацию.
Границы сегмента позволяют процес&shy;сору
обнаруживать такие распространенные ошибки, как пере&shy;полнение стека, неверные указатели, неверные
адреса вызовов и переходов. В случае, когда операционная система
считает, что обращение за пределы сегмента не
является ошибкой (например, при
переполнении стека), она может расширить сег&shy;мент путем выделения дополнительной памяти и запросить вы&shy;полнение команды вновь.</p> 

<p>Привилегии - Это поле, имеющее название Descriptor Privilege Level (DPL),
определяет уровень
привилегий сегмента и используется совмест&shy;но с полем RPL селектора для разрешения или запрещения дос&shy;тупа к сегменту. Для
получения доступа к сегменту задача долж&shy;на
иметь по крайней мере такой же уровень привилегий, как и сегмент, т. е. RPL &gt;= DPL.</p> 

<p>Признак&nbsp; присутствия -&nbsp;Этот бит обеспечивает один из механизмов реализации виртуальной
памяти. Если бит не установлен, при попытке обращения к сегменту процессор генерирует особую ситуацию отсутствия сегмента,
позволяя ядру подгрузить сегмент из вторичной памя&shy;ти и вновь повторить инструкцию, не затрагивая при этом выпол&shy;нение процесса. Однако в большинстве современных версий UNIX виртуальная память основана на страничном механизме, при котором сегмент
всегда присутствует в памяти, а обмен ме&shy;жду оперативной и вторичной памятью
происходит на уровне страниц.</p> 

<p>Тип - Это поле определяет тип сегмента. Процессор
проверяет типсегмента на соответствие исполняемой команде. Это, в частно&shy;сти, не
позволяет интерпретировать информацию сегмента дан&shy;ных как инструкции процессора.</p> 

<p>Права доступа - Это поле определяет права доступа, ограничивающие
множество операций, которые можно производить с сегментом. Например, сегмент кода обычно
отмечается как исполняемый и читаемый. Сегменты
данных могут иметь право доступа только для чтения, или для чтения и записи.</p> 

<p>Комбинация селектора и смещения образует логический адрес. Блок управления памятью процессора использует селектор для определения соответст&shy;вующего ему дескриптора. Складывая базовый адрес сегмента, хранящийся в
дескрипторе, со смещением, процессор создает линейный
адрес (рис. 3.6).</p> 

<p><img width=444 height=278 src="2Part2_.files/image006.jpg"></p> 

<p>Если страничный механизм не используется, полученный линейный адрес
является физическим, используемым для непосредственного доступа оперативной
памяти. Однако реализация виртуальной памяти, основанная только на сегментах,
не обладает достаточной гибкостью и не используете: в современных версиях UNIX. Управление памятью в большинстве систем основано на страничном механизме. Сегменты используются ядром для
размещения кода, данных и стека процесса, причем каждый из них имеет нулевой базовый адрес и предел - 3 Гбайт, т. е. всю адресуемую вирту альную память за вычетом 1 Гбайт, занимаемых ядром системы. Распреде
ление виртуального адресного пространства между ядром и процессам рассмотрено в разделе &quot;Адресное пространство процесса&quot;.</p> 

<h3>Страничный механизм</h3> 

<p>При реализации виртуальной памяти, основанной только на сегментации
весь сегмент целиком может либо присутствовать в оперативной памяти либо отсутствовать (точнее, находиться во вторичной памяти или в испол няемом файле
процесса). Поскольку размер сегмента может быть доста точно велик, одновременное выполнение нескольких больших процесса вызовет серьезную конкуренцию за ресурсы памяти,
что в свою очередь приведет к
интенсивному обмену данными между оперативной и вторич ной памятью. К тому же обмен областями
переменного размера, каковым являются
сегменты, достаточно сложен и, хотя фрагментация памяти пpи этом будет невелика, приведет к низкой эффективности ее использования
оставляя большое количество неиспользуемого пространства.</p> 

<p>Страничный механизм обеспечивает гораздо большую гибкость. В этом слу
чае все виртуальное адресное пространство (4 Гбайт для процессоров Intel разделено на блоки одинакового размера, называемые <i style='mso-bidi-font-style:
normal'>страницами. </i>Боль шинство процессоров Intel работает со страницами размером 4 Кбайт. Так же как и в случае сегментации, страница может либо
присутствовать в oпe ративной памяти, либо находиться в области
свопинга или исполняемом файле процесса. Основное преимущество такой схемы
заключается в том что система управления памятью оперирует
областями достаточно малого размера для обеспечения эффективного распределения
ресурсов памяти ме жду процессами. Страничный механизм
допускает, чтобы часть сегмент находилась в оперативной памяти, а часть
отсутствовала. Это дает ядру воз можность разместить
в памяти только те страницы, которые в данное время используются процессом, тем самым значительно освобождая оперативную память. Еще одним преимуществом является то, что страницы сегмента мо гут
располагаться в физической памяти в произвольном месте и порядке что позволяет эффективно использовать свободное
пространство<sup>2</sup>.</p> 

<p><sup><font size="2">2</font></sup><font size="2">Данный подход напоминает схему хранения файлов
на диске – каждый файл состоит из различного часла блоков хранения данных,
которые могут располагаться в любых свободных участках дискового накопителя.
Это ведет к значительной фрагментации, но сущетвенно повышает эффективность
использование дискового пространства.</font></p> 

<p>При использовании страничного механизма линейный адрес, полученный в результате сложения базового адреса сегмента и смещения также являет&shy;ся логическим адресом, который дополнительно обрабатывается блоком
страничной трансляции процессора. В этом случае линейный адрес рас&shy;сматривается процессором как состоящий из трех частей, показанных на рис. 3.7.</p> 

<p><img width=502 height=340 src="2Part2_.files/image008.jpg"></p> 

<p>Первое поле адреса, с 22 по 31 бит, указывает на элемент <i>каталога таблиц страниц </i>(Page Directory Entry, PDE). Каталог таблиц страниц имеет длину, равную одной
странице, и содержит до 1024 указателей на <i>таблицы
стра&shy;ниц </i>(page table). Таким образом, первое поле адресует определенную таб&shy;лицу страниц.
Второе поле, занимающее с 12 по 21 бит, указывает на <i>эле&shy;мент таблицы страниц </i>(Page Table Entry, РТЕ). Таблицы страниц также имеют длину 4 Кбайт, а элементы таблицы адресуют в совокупности 1024
страниц. Другими словами, второе поле адресует определенную страницу. Наконец, смещение на странице определяется третьим полем, занимаю&shy;щим младшие 12 бит линейного адреса. Таким образом, с помощью од&shy;ного каталога таблиц процесс может адресовать 1024x1024x4096 = 4 Гбайт
Физической памяти.</p> 

<p>На рис. 3.7 показано, как блок страничной адресации процессора транс&shy;лирует линейный адрес в физический. Процессор использует поле PDE адреса
(старшие 10 бит) в качестве индекса в каталоге таблиц. Найденный элемент содержит адрес таблицы страниц. Второе поле линейного адреса, РТЕ, позволяет
процессору выбрать нужный элемент таблицы, адресую щий физическую страницу. Складывая адрес начала страницы со смеще нием, хранящимся в третьем поле, процессор
получает 32-битный физиче ский адрес<sup>3</sup>.</p> 

<p>Каждый элемент таблицы страниц содержит несколько полей (табл. 3.2 описывающих различные характеристики страницы.</p> 
<div class=Section1>

<table class=MsoNormalTable border=0 cellspacing=0 cellpadding=0
 style='margin-left:2.0pt;border-collapse:collapse;mso-padding-alt:0cm 2.0pt 0cm 2.0pt'>
 <tr style='height:16.3pt'>
  <td width=654 colspan=2 valign=top style='width:490.3pt;border-top:none;
  border-left:none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-bottom-alt:solid windowtext .75pt;mso-border-right-alt:solid windowtext .75pt;
  background:white;padding:0cm 2.0pt 0cm 2.0pt;height:16.3pt'>
  <p class=Normal style='margin-left:262.3pt;background:white'><span
  style='font-size:14.0pt;mso-bidi-font-size:10.0pt;font-family:Arial;
  mso-bidi-font-family:"Times New Roman";color:black;letter-spacing:.2pt'>Таблица
  3.2. Поля РТЕ</span><span style='font-size:14.0pt;mso-bidi-font-size:10.0pt'>
  <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='height:62.55pt'>
  <td width=76 valign=top style='width:2.0cm;border:none;border-bottom:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .75pt;mso-border-top-alt:solid windowtext .75pt;
  mso-border-bottom-alt:solid windowtext .75pt;background:white;padding:0cm 2.0pt 0cm 2.0pt;
  height:62.55pt'>
  <p class=Normal style='background:white'><span style='font-size:12.0pt;
  mso-bidi-font-size:10.0pt;font-family:Arial;mso-bidi-font-family:"Times New Roman";
  color:black'>Р</span><span style='font-size:12.0pt;mso-bidi-font-size:10.0pt'>
  <o:p></o:p></span></p>
  </td>
  <td width=578 valign=top style='width:433.6pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .75pt;mso-border-top-alt:solid windowtext .75pt;
  mso-border-bottom-alt:solid windowtext .75pt;mso-border-right-alt:solid windowtext .75pt;
  background:white;padding:0cm 2.0pt 0cm 2.0pt;height:62.55pt'>
  <p class=Normal style='margin-left:6.95pt;text-align:justify;text-indent:
  .25pt;background:white'><span style='font-size:12.0pt;mso-bidi-font-size:
  10.0pt;font-family:Arial;mso-bidi-font-family:"Times New Roman";color:black'>Признак
  присутствия в оперативной памяти. Доступ к странице, отсутст <span
  style='letter-spacing:.05pt'>вующей в памяти (Р=0) вызывает страничную
  ошибку, особую ситуацию </span><span style='letter-spacing:-.05pt'>о чем
  процессор информирует ядро, которое обрабатывает ее соответст вующим образом.</span></span><span style='font-size:12.0pt;mso-bidi-font-size:10.0pt'> <o:p></o:p></span></p>
  <p class=Normal style='text-align:justify;background:white'><span style='font-size:12.0pt;mso-bidi-font-size:10.0pt'><o:p>&nbsp;</o:p></span></p>
  </td>
 </tr>
 <tr style='height:14.9pt'>
  <td width=76 valign=top style='width:2.0cm;border:none;border-bottom:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .75pt;mso-border-top-alt:solid windowtext .75pt;
  mso-border-bottom-alt:solid windowtext .75pt;background:white;padding:0cm 2.0pt 0cm 2.0pt;
  height:14.9pt'>
  <p class=Normal style='background:white'><span lang=EN-US style='font-size:
  12.0pt;mso-bidi-font-size:10.0pt;font-family:Arial;mso-bidi-font-family:"Times New Roman";
  color:black;mso-ansi-language:EN-US'>R/W</span><span style='font-size:12.0pt;
  mso-bidi-font-size:10.0pt'> <o:p></o:p></span></p>
  </td>
  <td width=578 valign=top style='width:433.6pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .75pt;mso-border-top-alt:solid windowtext .75pt;
  mso-border-bottom-alt:solid windowtext .75pt;mso-border-right-alt:solid windowtext .75pt;
  background:white;padding:0cm 2.0pt 0cm 2.0pt;height:14.9pt'>
  <p class=Normal style='margin-top:0cm;margin-right:4.1pt;margin-bottom:0cm;
  margin-left:7.45pt;margin-bottom:.0001pt;text-align:justify;background:white'><span
  style='font-size:12.0pt;mso-bidi-font-size:10.0pt;font-family:Arial;
  mso-bidi-font-family:"Times New Roman";color:black;letter-spacing:-.25pt'>Права
  только на чтение страницы </span><span lang=EN-US style='font-size:12.0pt;
  mso-bidi-font-size:10.0pt;font-family:Arial;mso-bidi-font-family:"Times New Roman";
  color:black;letter-spacing:-.25pt;mso-ansi-language:EN-US'>(R/W=0) </span><span
  style='font-size:12.0pt;mso-bidi-font-size:10.0pt;font-family:Arial;
  mso-bidi-font-family:"Times New Roman";color:black;letter-spacing:-.25pt'>или
  на чтение и запись </span><span lang=EN-US style='font-size:12.0pt;
  mso-bidi-font-size:10.0pt;font-family:Arial;mso-bidi-font-family:"Times New Roman";
  color:black;letter-spacing:-.25pt;mso-ansi-language:EN-US'>(R/W=1).</span><span style='font-size:12.0pt;mso-bidi-font-size:10.0pt'> <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='height:48.05pt'>
  <td width=76 valign=top style='width:2.0cm;border:none;border-bottom:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .75pt;mso-border-top-alt:solid windowtext .75pt;
  mso-border-bottom-alt:solid windowtext .75pt;background:white;padding:0cm 2.0pt 0cm 2.0pt;
  height:48.05pt'>
  <p class=Normal style='background:white'><span lang=EN-US style='font-size:
  12.0pt;mso-bidi-font-size:10.0pt;font-family:Arial;mso-bidi-font-family:"Times New Roman";
  color:black;mso-ansi-language:EN-US'>U/S</span><span style='font-size:12.0pt;
  mso-bidi-font-size:10.0pt'> <o:p></o:p></span></p>
  </td>
  <td width=578 valign=top style='width:433.6pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .75pt;mso-border-top-alt:solid windowtext .75pt;
  mso-border-bottom-alt:solid windowtext .75pt;mso-border-right-alt:solid windowtext .75pt;
  background:white;padding:0cm 2.0pt 0cm 2.0pt;height:48.05pt'>
  <p class=Normal style='margin-top:0cm;margin-right:.25pt;margin-bottom:0cm;
  margin-left:6.7pt;margin-bottom:.0001pt;text-align:justify;text-indent:.25pt;
  background:white'><span style='font-size:12.0pt;mso-bidi-font-size:10.0pt;
  font-family:Arial;mso-bidi-font-family:"Times New Roman";color:black;
  letter-spacing:.05pt'>Привилегии доступа. Если </span><span lang=EN-US
  style='font-size:12.0pt;mso-bidi-font-size:10.0pt;font-family:Arial;
  mso-bidi-font-family:"Times New Roman";color:black;letter-spacing:.05pt;
  mso-ansi-language:EN-US'>U/S </span><span style='font-size:12.0pt;mso-bidi-font-size:
  10.0pt;font-family:Arial;mso-bidi-font-family:"Times New Roman";color:black;
  letter-spacing:.05pt'>= 0, только привилегированные задачи </span><span
  style='font-size:12.0pt;mso-bidi-font-size:10.0pt;font-family:Arial;
  mso-bidi-font-family:"Times New Roman";color:black'>(ядро) имеют доступ к
  адресам страницы. В противном случае, доступ к <span style='letter-spacing:
  -.05pt'>странице имеют все задачи.</span></span><span style='font-size:12.0pt;
  mso-bidi-font-size:10.0pt'> <o:p></o:p></span></p>
  </td>
 </tr>
 <tr style='mso-yfti-lastrow:yes;height:16.8pt'>
  <td width=76 valign=top style='width:2.0cm;border:none;border-bottom:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .75pt;mso-border-top-alt:solid windowtext .75pt;
  mso-border-bottom-alt:solid windowtext .75pt;background:white;padding:0cm 2.0pt 0cm 2.0pt;
  height:16.8pt'>
  <p class=Normal style='background:white'><span style='font-size:12.0pt;
  mso-bidi-font-size:10.0pt;font-family:Arial;mso-bidi-font-family:"Times New Roman";
  color:black;letter-spacing:-.2pt'>Адрес</span><span style='font-size:12.0pt;
  mso-bidi-font-size:10.0pt'> <o:p></o:p></span></p>
  </td>
  <td width=578 valign=top style='width:433.6pt;border-top:none;border-left:
  none;border-bottom:solid windowtext 1.0pt;border-right:solid windowtext 1.0pt;
  mso-border-top-alt:solid windowtext .75pt;mso-border-top-alt:solid windowtext .75pt;
  mso-border-bottom-alt:solid windowtext .75pt;mso-border-right-alt:solid windowtext .75pt;
  background:white;padding:0cm 2.0pt 0cm 2.0pt;height:16.8pt'>
  <p class=Normal style='margin-top:0cm;margin-right:100.3pt;margin-bottom:
  0cm;margin-left:6.95pt;margin-bottom:.0001pt;text-align:justify;background:
  white'><span style='font-size:12.0pt;mso-bidi-font-size:10.0pt;font-family:
  Arial;mso-bidi-font-family:"Times New Roman";color:black;letter-spacing:-.05pt'>Физический
  адрес начала страницы (адрес базы).</span><span style='font-size:12.0pt;
  mso-bidi-font-size:10.0pt'> <o:p></o:p></span></p>
  </td>
 </tr>
</table>

</div>

<h3>Адресное
пространство процесса</h3> 

<p>Адресное пространство ядра обычно совпадает с адресным пространством выполняющегося в
данный момент процесса. В этом случае говорят, что ядро расположено в том же <i>контексте,
</i>что и процесс. Каждый раз, когда процессу передаются вычислительные
ресурсы, система восстанавливает контекст
задачи этого процесса, включающий значения регистров общего назначения,
сегментных регистров, а также указатели на таблицы страниц отображающие
виртуальную память процесса в режиме задачи. При это системный контекст остается неизменным для всех
процессов. Вид адрес ного
пространства процесса представлен на рис. 3.8.</p> 

<p>Специальный регистр (CR3 для Intel) указывает на расположение каталога таблиц
страниц в памяти. В SCO UNIX используется только один каталог, независимо от выполняющегося процесса,
таким образом значение реги стра CR3 не меняется на протяжении жизни системы. Поскольку ядро (код и данные) является частью выполняющегося процесса, таблицы стра ниц, отображающие старший 1 Гбайт виртуальной памяти, принадлежа щей ядру системы, не изменяются при переключении между процессами Для
отображения ядра используются старшие 256 элементов каталога.</p> 

<p><sup><font size="2">3</font></sup><font size="2">Следует отметить, что большинство современных процессоров и, в
частности, процессор] семейства Intel, помещают данные о нескольких последних использовавшихся ими стра-ницах в сверхоперативный кэш. Только когда процессор не находит
требуемой страницы в этом кэше, он обращается к каталогу
и таблицам страниц. Как правило, 98—99% адрес-ных ссылок попадают в кэш, не
требуя для трансляции адреса обращения к оперативной памяти, где расположены каталог и таблицы.</font></p> 

<p><img width=494 height=362 src="2Part2_.files/image010.jpg" ></p> 

<p>При переключении между процессами, однако, изменяется адресное про&shy;странство
режима задачи, что вызывает необходимость изменения остав&shy;шихся 768 элементов каталога. В совокупности они отображают 3 Гбайт виртуального адресного пространства процесса в режиме задачи. Таким образом, при смене процесса адресное пространство нового процесса ста&shy;новится
видимым (отображаемым), в то время как адресное пространство предыдущего
процесса является недоступным<sup>4</sup>.</p> 

<p>Формат виртуальной памяти процесса в режиме задачи зависит, в первую очередь, от типа исполняемого файла, образом которого является процесс.
На рис. 3.9 изображено расположение различных сегментов
процесса в виртуальной памяти для двух уже рассмотренных
нами форматов испол&shy;няемых файлов — COFF и ELF. Заметим, что независимо от формата ис&shy;полняемого файла виртуальные адреса процесса не могут выходить за пре&shy;делы 3 Гбайт.</p> 

<p>Для защиты виртуальной памяти процесса от модификации другими про&shy;цессами прикладные задачи не могут менять заданное отображение. Поскольку ядро системы выполняется на привилегированном уровне, она может управлять отображением как собственного адресного пространства, так и адресного пространства процесса.</p> 

<p><sup><font size="2">4</font></sup><font size="2">При этом физические страницы, принадлежащие
предыдущему процессу, могут по-прежнему оставаться в памяти, однако доступ к ним
невозможен ввиду отсутствия уста&shy;новленного
отображения. Любой допустимый виртуальный адрес будет отображаться либо в страницы ядра, либо в страницы нового процесса.</font></p> 

<p><img width=510 height=360 src="2Part2_.files/image012.jpg"></p> 

<h3>Управление памятью процесса</h3> 

<p>Можно сказать, что каждый процесс в операционной системе UNIX вы&shy;полняется на собственной
виртуальной вычислительной машине, где все ресурсы
принадлежат исключительно данному процессу. Подсистема управления памятью
обеспечивает такую иллюзию в отношении физиче&shy;ской памяти.</p> 

<p>Как уже говорилось, аппаратная поддержка страничного механизма имеет существенное значение для реализации виртуальной памяти. Однако при этом также требуется участие операционной системы. Можно перечислить ряд операций, за выполнение которых отвечает сама операционная система:</p> 

<ul>
    <li>Размещение в памяти каталога страниц и
таблиц страниц; инициа&shy;лизация регистра -- указателя на
каталог таблиц страниц (для Intel — CR3) (в системах, использующих несколько каталогов
страниц, каждый процесс хранит в u-area значение этого регистра; в этом слу&shy;чае&nbsp;
инициализацию указателя&nbsp;
необходимо&nbsp; проводить&nbsp; при&nbsp;
каждом переключении контекста); инициализация каталога страниц.</li>
    <li>Установка отображения путем записи
соответствующих значений в таблицы страниц.</li>
    <li> Обработка страничных ошибок.
-&nbsp;&nbsp; Управление сверхоперативным кэшем.</li>
    <li>Обеспечение обмена страницами
между оперативной и вторичной памятью.</li>
</ul>
<p>&nbsp;</p>
</body> 

</html> 
