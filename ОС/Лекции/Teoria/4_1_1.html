<HTML>
<HEAD>
<TITLE>Файлы</TITLE>
<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="TEXT/HTML; CHARSET=WINDOWS-1251">
</HEAD>
<BODY>
<CENTER>
<H1>Файлы</H1>
<FONT SIZE="3">
</CENTER>
  <br>
  Файловая система — это еще одно ключевое понятие, поддерживаемое виртуально 
  всеми операционными системами. Как было замечено ранее, основной функцией операционной 
  системы является скрытие особенностей дисков и других устройств ввода-вывода 
  и предоставление пользователю понятной и удобной абстрактной модели независимых 
  от устройств файлов. Системные вызовы очевидно необходимы для создания, удаления, 
  чтения или записи файлов. Перед тем как прочитать файл, его нужно разместить 
  на диске и открыть, а после прочтения его нужно закрыть. Все эти функции осуществляют 
  системные вызовы.<BR>
<dd>Предоставляя место для хранения файлов, операционные системы используют понятие 
  каталога (directory) как способ объединения файлов в группы. Например, студент 
  может иметь по одному каталогу для каждого изучаемого им курса (для программ, 
  необходимых в рамках этого курса), каталог для электронной почты, и еще один 
  — для своей домашней web-страницы. Для создания и удаления каталогов также необходимы 
  системные вызовы. Они же обеспечивают перемещение существующего файла в каталог 
  и удаление файла из каталога. Содержимое каталогов могут составлять файлы или 
  другие каталоги. Эта модель создает структуру — файловую систему, — как показано 
  на рис. 1.14.<BR>
<dd>Иерархии процессов и файлов организованы в виде деревьев, но на этом сходство 
  заканчивается. Иерархия процессов обычно не очень глубока (в ней редко бывает 
  больше трех уровней), тогда как файловая структура достаточно часто имеет четыре, 
  пять или даже больше уровней в глубину. Иерархия процессов обычно живет очень 
  недолго, как правило, несколько минут, иерархия каталогов может существовать 
  годами. Принадлежность и защита также различны для процессов и файлов. Обычно 
  только родительский процесс может управлять или даже просто иметь доступ к дочернему 
  процессу, однако практически всегда существует механизм, позволяющий читать 
  файлы и каталоги не только владельцу файла, а более широкой группе пользователей.<BR>
<dd>Каждый файл в иерархии каталогов можно определить, задав его имя пути, называемое 
  также полным именем файла. Путь начинается из вершины структуры каталогов, называемой 
  корневым каталогом. Такое абсолютное имя пути состоит из списка каталогов, которые 
  нужно пройти от корневого каталога к файлу, с разделением отдельных компонентов 
  косой чертой. На рис. 1.14 путь к файлу CS101 выглядит как <I>/Faculty/Prof.Brown/Courses/CS101. 
  </I>Первая косая черта говорит о том, что этот путь — абсолютный, то есть начинается 
  от корневого каталога. В MS-DOS и Windows для разделения компонентов вместо 
  символа косой черты используется обратная косая черта (\). Тогда этот путь будет 
  выглядеть так: <I>\Faculty\Prof.Brown\Courses\CS101. </I>В нашей книге для записи 
  пути мы в основном будем использовать соглашения UNIX.<BR>
  <center>
    <br>
    <img src="04/Tanenbaum_1_14.jpg" alt="Файловая система факультета университета"><br>
    <br>
    <font face="Arial"><b>Рис. 1.14.</B> Файловая система факультета университета</font><BR>
  </center>
  <br>
<dd>В каждый момент времени у каждого процесса есть текущий <b>рабочий каталог, 
  </b> в котором ищутся пути файлов, не начинающиеся с косой черты. Например, 
  если на рис. 1.14 <I>/Faculty/Prof.Brown </I>является рабочим каталогом, то 
  использование пути <I>Courses/CS101 </I>даст тот же самый файл, что и абсолютный 
  путь, написанный выше. Процессы могут изменять свой рабочий каталог, используя 
  системные вызовы.<BR>
<dd>Перед тем как прочесть или записать файл, его нужно открыть, в это же время 
  проверяется разрешение доступа. Если доступ разрешен, система возвращает небольшое 
  целое число, называемое <b>дескриптором файла</b> и используемое в последующих 
  операциях. Если доступ запрещен, то возвращается код ошибки.<BR>
<dd>Другое важное понятие в UNIX — это установленная (смонтированная) файловая 
  система. Почти все персональные компьютеры имеют один или два дисковода для 
  гибких дисков, куда можно вставить и откуда можно вынуть диск. Чтобы предоставить 
  возможность общения со сменными носителями (включая компакт-диски), UNIX позволяет 
  присоединять файловую систему сменного диска к главному дереву. Рассмотрим ситуацию 
  на рис. 1.15, а. Перед вызовом системной процедуры mount <b>корневая файловая 
  система</b> на жестком диске и вторая файловая система на гибком диске существуют 
  раздельно и никак не связаны между собой.<BR>
  <center>
    <br>
    <img src="04/Tanenbaum_1_15.jpg" alt="Файловая система в разные моменты времени"><br>
    <br>
    <font face="Arial"><b>Рис. 1.15.</b> Перед установкой файлы на диске 0 недоступны 
    (а); после монтирования<br>
    они становятся частью общей файловой структуры (б)</font><BR>
  </center>
  <br>
<dd>Однако файлы на гибком диске нельзя использовать, потому что для них невозможно 
  определить путь. UNIX не позволяет присоединять к началу пути название диска 
  или его номер, так как это привело бы к жесткой зависимости от устройств, которой 
  операционная система должна избегать. Вместо этого системный вызов mount позволяет 
  присоединять файловую систему на гибком диске к корневой файловой системе в 
  том месте, где этого захочет программа. На рис. 1.15, <I>б </I>файловая система 
  гибкого диска была установлена в каталог b<I>, </I>таким образом, обеспечен 
  доступ к файлам по путям <I>/b/x/</I> и <I>/b/y</I>. Если каталог b<I> </I>содержал 
  какие-либо файлы, они будут недоступны, пока смонтирован гибкий диск, так как 
  теперь <I>/b </I>ссылается на корневой каталог гибкого диска. (Невозможность 
  доступа к этим файлам не так страшна, как кажется с первого взгляда: файловые 
  системы почти всегда устанавливаются в пустые каталоги.) Если система содержит 
  несколько жестких дисков, они все могут быть встроены в одно дерево таким же 
  образом.<BR>
<dd>Еще одно важное понятие в UNIX — это <b>специальный файл.</b> Специальные 
  файлы служат для того, чтобы устройства ввода-вывода выглядели как файлы. При 
  этом можно прочесть информацию из специальных файлов или записать ее туда с 
  помощью тех же самых системных вызовов, что используются для чтения и записи 
  файлов. Существует два вида специальных файлов: <b>блочные специальные файлы 
  и символьные специальные файлы.</b> Блочные специальные файлы используются для 
  моделирования устройств, состоящих из набора произвольно адресуемых блоков, 
  таких как диски. Открывая блочный специальный файл и читая, скажем, блок 4, 
  программа может напрямую получить доступ к четвертому блоку на устройстве, без 
  обращения к содержащейся на нем файловой системе. Таким же образом символьные 
  специальные файлы используются для моделирования принтеров, модемов и других 
  устройств, которые принимают или выдают поток символов. По соглашению специальные 
  файлы хранятся в каталоге <I>/dev. </I>Например, <I>/dev/lp </I>может быть строковым 
  принтером.<BR>
</BODY>
</HTML>
