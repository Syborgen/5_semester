<HTML>
<HEAD>
<TITLE>Избежание взаимоблокировок</TITLE>
</HEAD>
<body>
  <b><font size="6"><center>Избежание взаимоблокировок</center></font></b><br>
  <br>
  Рассматривая обнаружение взаимоблокировок, мы неявно предполагали, что когда 
  процесс запрашивает ресурсы, он требует их все сразу (матрица <i>R</i> на рис. 
  3.4). Однако в большинстве систем ресурсы запрашиваются поочередно, по одному. 
  Система должна уметь решать, является ли предоставление ресурса безопасным или 
  нет, и предоставлять его процессу только в первом случае. Таким образом, возникает 
  новый вопрос: существует ли алгоритм, который всегда может избежать ситуации 
  взаимоблокировки, все время делая правильный выбор? Ответом является условное 
  &laquo;да&raquo; — мы можем избежать тупиков, но только если заранее будет доступна 
  определенная информация. В этом разделе мы изучим способы уклонения от взаимоблокировок 
  с помощью аккуратного предоставления ресурсов.<br>
  <br>
  <br>
<a NAME="01"></a>
  <b><font size="4">Траектории ресурсов</font></b><br>
  <br>
  Основные алгоритмы, позволяющие предотвращать взаимоблокировки, базируются на 
  концепции безопасных состояний. Перед тем как начать описывать алгоритм, сделаем 
  небольшое отступление, чтобы взглянуть на идею безопасности с точки зрения простого 
  для понимания графического метода. Несмотря на то что графический подход не 
  переносится напрямую в пригодный к употреблению алгоритм, он дает прекрасное 
  интуитивное понимание существа вопроса.<br>
<dd> На рис. 3.6 представлена модель для системы с двумя процессами и двумя ресурсами, 
  например принтером и плоттером. Горизонтальная ось отображает номера команд, 
  выполняемых процессом Л. По вертикальной оси показаны номера<br>
<dd> команд, выполняемых процессом <i>В. </i> В команде <i>I</i><sub>1</sub> процесс 
  <i>А</i> запрашивает принтер, в команде <i>I</i><sub>2</sub> ему требуется плоттер. 
  Принтер и плоттер освобождаются командами <i>I</i><sub>3</sub> и <i>I</i><sub>4</sub> 
  соответственно. Процессу <i>В</i> необходим плоттер с команды <i>I</i><sub>5</sub> 
  по команду <i>I</i><sub>7 </sub>и принтер с команды <i>I</i><sub>6</sub> по 
  команду <i>I</i><sub>8</sub>.<br>
<dd> Каждая точка на диаграмме представляет совместное состояние двух процессов. 
  Изначально система находится в точке <i>р, </i> когда ни один процесс еще не 
  выполнил ни одну инструкцию. Если планировщик запустит процесс <i>А</i> первым, 
  мы попадем в точку <i>q,</i> в которой процесс <i>А</i> выполнил какое-то количество 
  команд, а процесс <i>В</i> еще ничего не сделал. В точке <i>q</i> траектория 
  становится вертикальной, показывая, что планировщик решил запустить в работу 
  процесс <i>В.</i> При наличии одного процессора все отрезки траектории могут 
  быть только вертикальными или горизонтальными, но не наклонными. Кроме того, 
  движение всегда происходит на север или восток (вверх и вправо), и никогда на 
  юг или запад (вниз и влево), так как процессы не могут работать в обратном направлении.<br>
<dd> Когда процесс <i>А</i> пересекает линию <i>I</i><sub>1</sub> на отрезке от 
  точки <i>r</i> до точки <i>s</i>, он запрашивает и получает принтер. Когда процесс 
  <i>В</i> достигает точки <i>t,</i> он запрашивает плоттер.<br>
  <center>
    <br>
    <img src="08/Tanenbaum_3_7.jpg" alt="Две траектории ресурсов процессов"><br>
    <br>
    <b><font face="Arial">Рис. 3.6.</font></b><font face="Arial"> Две траектории 
    ресурсов процессов</font><br>
  </center>
  <br>
<dd> Особенно интересны заштрихованные области. Область со штриховкой из верхнего 
  левого угла в правый нижний представляет промежуток времени, когда оба процесса 
  занимают принтер. Правило взаимного исключения делает попадание в эту область 
  невозможным. Вторая заштрихованная область соответствует тому, что оба процесса 
  используют плоттер, и это также невозможно.<br>
<dd> Если система войдет в прямоугольник, ограниченный линиями <i>I</i><sub>1</sub> 
  и <i>I<sub>2</sub></i> по сторонам и линиями <i>I</i><sub>5</sub> и <i>I</i><sub>6</sub> 
  сверху и снизу, она в конце концов доберется до пересечения линий <i>I</i><sub>2</sub> 
  и <i>I</i><sub>6</sub>, попадет в тупик. В этот момент процесс <i>А</i> запросит 
  плоттер, а процесс <i>В</i> потребует принтер, но оба ресурса будут к тому времени 
  заняты. Получается, что небезопасным является целый прямоугольник, и в него 
  нельзя входить. В точке <i>t</i><br>
<dd> единственно безопасный вариант состоит в том, чтобы оставить процесс <i>А</i> 
  работать до тех пор, пока он не достигнет команды <i>I</i><sub>4</sub>. После 
  нее любая траектория дойдет до точки <i>и.</i><br>
<dd> Важный для понимания момент заключается в том, что в точке <i>t</i> процесс 
  <i>В</i> запрашивает ресурс. Система должна принять решение: предоставлять его 
  или нет. Если выдается разрешение, система попадает в небезопасную область и 
  в итоге блокируется. Чтобы избежать тупика, нужно приостановить процесс <i>В</i> 
  до тех пор, пока процесс <i>А</i> не запросит и не освободит плоттер.<br>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Безопасные и небезопасные состояния</font></b><br>
  <br>
  Алгоритмы предотвращения взаимоблокировок, которые мы будем изучать дальше, 
  используют информацию рис. 3.4. В любой момент времени существует текущее состояние, 
  составленное из величин <i>Е, А, С</i> и <i>R.</i> Говорят, что состояние <b>безопасно,</b> 
  если оно не находится в тупике и существует некоторый порядок планирования, 
  при котором каждый процесс может работать до завершения, даже если все процессы 
  вдруг захотят немедленно получить свое максимальное количество ресурсов. Проще 
  всего проиллюстрировать эту идею на примере с одним ресурсом. На рис. 3.7, <i>а</i> 
  у нас есть состояние, в котором процесс <i>А</i> занимает 3 экземпляра ресурса, 
  но ему в итоге могут потребоваться 9 экземпляров. Процесс <i>В</i> в настоящий 
  момент занял 2 экземпляра, но позже ему могут понадобиться всего 4. Процесс 
  <i>С</i> владеет двумя, но может потребовать еще 5 штук. В системе есть всего 
  10 экземпляров данного ресурса, 7 из них уже распределены, три пока свободны.<br>
  <center>
    <br>
    <img src="08/Tanenbaum_3_8.jpg" alt="Демонстрация того, что состояние а безопасно"><br>
    <br>
    <b><font face="Arial">Рис. 3.7.</font></b><font face="Arial"> Демонстрация 
    того, что состояние <i>а</i> безопасно</font><br>
  </center>
  <br>
<dd> Состояние на рис. 3.7, <i>а</i> безопасно, потому что существует такая последовательность 
  предоставления ресурсов, которая позволяет завершиться всем процессам. А именно, 
  планировщик может просто запустить в работу только процесс <i>В</i> на то время, 
  пока он запросит и получит два дополнительных экземпляра ресурса, что приведет 
  к состоянию, изображенному на рис. 3.7, <i>б.</i> Когда процесс <i>В</i> закончится, 
  мы получим состояние рис. 3.7, <i>в.</i> Затем планировщик может запустить процесс 
  <i>С,</i> что со временем приведет нас к ситуации рис. 3.7, г. По завершении 
  процесса <i>С</i> мы получим рис. 3.7, <i>д.</i> Теперь процесс <i>А</i> наконец 
  может занять необходимые ему шесть экземпляров ресурса и также успешно завершиться. 
  Таким образом, состояние на рис. 3.7, <i>а</i> является безопасным, потому что 
  система может избежать тупика с помощью аккуратного планирования процессов.<br>
<dd> Теперь предположим, что исходное состояние системы продемонстрировано на 
  рис. 3.8, <i>а,</i> но в данный момент процесс <i>А</i> запрашивает и получает 
  еще один ресурс, приводя к рис. 3.8, <i>б.</i> Сможем ли мы найти последовательность, 
  которая гарантирует работу системы? Давайте попытаемся. Планировщик может дать 
  проработать процессу <i>В</i> до того момента, пока он не запросит все свои 
  ресурсы, как показано на рис. 3.8, <i>в.</i><br>
  <br>
  <center>
    <img src="08/Tanenbaum_3_9.jpg" alt="Демонстрация того, что состояние б небезопасно"><br>
    <br>
    <b><font face="Arial">Рис. 3.8.</font></b><font face="Arial"> Демонстрация 
    того, что состояние <i>б</i> небезопасно</font><br>
  </center>
  <br>
<dd> В итоге процесс <i>В</i> успешно завершается и мы получаем ситуацию рис. 
  3.8, <i>г.</i> В этом месте мы застряли: в системе осталось только четыре свободных 
  экземпляра ресурса, а каждому из активных процессов необходимо пять. И не существует 
  последовательности действий, гарантирующей успешное завершение всех процессов. 
  Следовательно, решение о предоставлении ресурса, которое передвинуло систему 
  из положения рис. 3.8, <i>а</i> к рис. 3.8, <i>б,</i> привело ее из безопасного 
  в небезопасное состояние. Если из ситуации рис. 3.8, <i>б</i> запустить процесс 
  <i>А</i> или <i>С,</i> мы не выйдем из тупика. Теперь, оглядываясь назад, можно 
  уверенно сказать, что нельзя было выполнять запрос процесса <i>A</i>.<br>
<dd> Следует отметить, что небезопасное состояние само по себе не является тупиком. 
  Начав с рис. 3.8, <i>б,</i> система может проработать некоторое время. Фактически 
  даже может успешно завершиться один процесс. Кроме того, возможна ситуация, 
  что процесс <i>А</i> сможет освободить один ресурс до следующего своего запроса, 
  позволяя успешно завершиться процессу <i>С,</i> а системе избежать взаимной 
  блокировки. Таким образом, разница между безопасным и небезопасным состоянием 
  заключается в следующем: в безопасном состоянии система может <i>гарантировать,</i> 
  что все процессы закончат свою работу, а в небезопасном состоянии такой гарантии 
  дать нельзя.<br>
  <br>
  <br>
<a NAME="03"></a>
  <b><font size="4">Алгоритм банкира для одного вида ресурсов</font></b><br>
  <br>
  Алгоритм планирования, позволяющий избегать взаимоблокировок, был разработан 
  Дейкстрой (Dijkstra, [96]) и носит название <b>алгоритма банкира.</b> Он представляет 
  собой расширение алгоритма обнаружения тупиков, о котором было рассказано в 
  разделе &laquo;Обнаружение взаимоблокировки при наличии одного ресурса каждого 
  типа&raquo; данной главы. Модель алгоритма основана на примере банкира в маленьком 
  городке, имеющего дело с группой клиентов, которым он выдал ряд кредитов. Алгоритм 
  проверяет, ведет ли выполнение каждого запроса к небезопасному состоянию. Если 
  да, то запрос отклоняется. Если удовлетворение запроса к ресурсу приводит к 
  безопасному состоянию, ресурс предоставляется процессу. На рис. 3.9, <i>а</i> 
  мы видим четырех клиентов: <i>А, В, С</i> и <i>D,</i> каждый из которых получил 
  определенное количество единиц кредита (например, 1 единица равна 1К долларов). 
  Банкир знает, что не всем клиентам понадобится их максимальный кредит немедленно, 
  поэтому он зарезервировал только 10 единиц, а не все 22, которые требуются клиентам. 
  (Чтобы провести аналогию с компьютерной системой, считаем, что клиенты — это 
  процессы, единицами, скажем, являются накопители на магнитной ленте, а банкир 
  — это операционная система.)<br>
  <br>
  <center>
    <img src="08/Tanenbaum_3_10.jpg" alt="Три состояния распределения ресурсов: безопасное (а); безопасное (б); небезопасное (в)"><br>
    <br>
    <b><font face="Arial">Рис. 3.9.</font></b><font face="Arial"> Три состояния 
    распределения ресурсов: безопасное (<i>а</i>);<br>
    безопасное (<i>б</i>); небезопасное (<i>в</i>)</font><br>
  </center>
  <br>
<dd> Клиенты вращаются в соответствующем бизнесе, время от времени прося у банка 
  ссуды (то есть запрашивая ресурсы). В некоторый момент возникает ситуация, показанная 
  на рис. 3.9, <i>б.</i> Это состояние безопасно, потому что остались две единицы 
  и банкир может задержать все обращения, кроме запросов клиента или процесса 
  <i>С,</i> таким образом, позволяя процессу <i>С</i> завершиться и вернуть все 
  четыре отданных ему ресурса. Имея на руках четыре единицы, банкир может отдать 
  их или клиенту <i>D,</i> или <i>В,</i> обеспечивая их необходимыми единицами 
  и т. д.<br>
<dd> Рассмотрим, что могло бы произойти, если бы в ситуации на рис. 3.9, <i>б</i> 
  был бы удовлетворен запрос еще одной единицы для клиента <i>В.</i> Мы попали 
  бы в состояние рис. 3.9, в, не являющееся безопасным. Если бы все клиенты вдруг 
  запросили максимальные ссуды, то банкир не смог бы их обеспечить и мы попали 
  бы в тупик. Небезопасное состояние не <i>обязано </i> приводить к взаимоблокировке, 
  так как клиентам не обязательно потребуется весь доступный кредит, но банкир 
  не может рассчитывать на такую ситуацию.<br>
<dd> Алгоритм банкира рассматривает каждый запрос по мере поступления и проверяет, 
  приведет ли его удовлетворение к безопасному состоянию. Если да, то процесс 
  получает ресурс, иначе запрос откладывается на более позднее время. Чтобы понять, 
  является ли состояние безопасным, банкир проверяет, может ли он предоставить 
  достаточно ресурсов для завершения работы какого-либо клиента. Если да, то эти 
  ссуды считаются погашенными, после чего проверяется следующий ближайший к пределу 
  займа клиент и т. д. Если, в конце концов, все ссуды могут быть погашены, состояние 
  является безопасным и исходный запрос можно удовлетворить.<br>
  <br>
  <br>
<a NAME="04"></a>
  <b><font size="4">Алгоритм банкира для нескольких видов ресурсов</font></b><br>
  <br>
  Алгоритм банкира можно обобщить для управления системой с несколькими видами 
  ресурсов. На рис. 3.10 показано, как он работает.<br>
  <center>
    <br>
    <img src="08/Tanenbaum_3_11.jpg" alt="Алгоритм банкира в системе с несколькими типами ресурсов"><br>
    <br>
    <b><font face="Arial">Рис. 3.10.</font></b><font face="Arial"> Алгоритм банкира 
    в системе с несколькими типами ресурсов</font><br>
  </center>
  <br>
<dd> На рис. 3.10 изображены две матрицы. Матрица слева показывает, сколько ресурсов 
  каждого вида занимает в настоящее время каждый из пяти процессов. Матрица справа 
  показывает количество ресурсов, которое нужно добавить каждому процессу для 
  успешного завершения. Эти матрицы на рис. 3.4 назывались <i>С</i> и <i>R.</i> 
  Как и в случае одного вида ресурсов, процессы должны точно определять необходимое 
  суммарное количество ресурсов до начала работы для того, чтобы система могла 
  рассчитать правую матрицу в каждый момент времени.<br>
<dd> Три вектора, изображенные справа от матриц, показывают, соответственно, существующие 
  ресурсы (вектор <i>Е),</i> занятые ресурсы (вектор <i>Р</i>) и доступные ресурсы 
  (вектор <i>А</i>). Из вектора <i>Е</i> мы видим, что система имеет шесть накопителей 
  на магнитной ленте, три плоттера, четыре принтера и два устройства для чтения 
  компакт-дисков. Из них заняты в данный момент пять накопителей, три плоттера, 
  два принтера и два устройства для чтения компакт-дисков. Чтобы увидеть этот 
  факт, нужно просуммировать четыре столбца, соответствующие ресурсам, в левой 
  матрице. Вектор доступных ресурсов является разницей между тем, что присутствует 
  в системе, и тем, что используется в настоящее время.<br>
<dd> Теперь можно изложить алгоритм для проверки безопасности состояния системы.<br>
  <br>
<dd> 1. Ищем в матрице <i>R</i> строку, соответствующую процессу, чьи неудовлетворенные 
  потребности ресурсов меньше или равны вектору <i>А.</i> Если такой строки не 
  существует, то система в конце концов попадет в тупик, так как ни один процесс 
  не может проработать до успешного завершения.<br>
<dd> 2. Допускаем, что процесс, строку которого выбрали в пункте 1, запрашивает 
  все необходимые ресурсы (гарантируется, что это возможно) и заканчивает работу. 
  Отмечаем этот процесс как завершенный и прибавляем все его ресурсы к вектору 
  <i>А.</i><br>
<dd> 3. Повторяем шаги 1 и 2 до тех пор, пока или все процессы будут помечены 
  как завершенные — и состояние в этом случае является безопасным, или произойдет 
  взаимоблокировка — тогда состояние небезопасно.<br>
  <br>
<dd> Если на первом шаге можно выбрать несколько процессов, не имеет значения, 
  какой из них будет взят: общий резерв доступных ресурсов или увеличится или, 
  в худшем случае, останется неизменным.<br>
<dd> Теперь вернемся к примеру на рис. 3.10. Текущее состояние является безопасным. 
  Предположим, что процесс <i>В</i> в данный момент запрашивает принтер. На этот 
  запрос можно ответить положительно, потому что получающееся в результате состояние 
  все еще будет безопасным (процесс <i>D </i> может доработать до конца, затем 
  процесс <i>А</i> или <i>Е,</i> затем остальные).<br>
<dd> Теперь представим, что после того, как процесс <i>В</i> получил один из двух 
  оставшихся принтеров, процесс <i>E</i> потребует последний принтер. Удовлетворение 
  этого запроса сократит вектор доступных ресурсов до (1 0 0 0), что приведет 
  к взаимоблокировке процессов. Ясно, что следует отложить на время запрос процесса 
  <i>Е.</i><br>
<dd> Дейкстра (Dijkstra) впервые опубликовал алгоритм банкира в 1965 году. С тех 
  пор практически каждая книга по операционным системам описывает его в деталях. 
  Различным аспектам этого алгоритма было посвящено бессчетное количество статей. 
  К сожалению, мало у кого из авторов хватило смелости показать, что хотя алгоритм 
  замечателен в теории, на практике он, по существу, бесполезен, потому что нечасто 
  можно определить заранее, сколько ресурсов потребуется процессам в будущем. 
  Кроме того, количество процессов не фиксировано, оно динамически изменяется 
  по мере входа пользователей в систему и выхода из нее. И, более того, ресурсы, 
  про которые считалось, что они доступны, могут внезапно исчезнуть (например, 
  накопитель на магнитной ленте может сломаться). Таким образом, на практике немногие 
  системы, если это вообще имеет место, используют алгоритм банкира для уклонения 
  от взаимоблокировок.<br>
</BODY>
</HTML>
