<HTML>
<HEAD>
<TITLE>Условия взаимоблокировки</TITLE>
</HEAD>
<body>
  <b><font size="6"><center>Условия взаимоблокировки</center></font></b><br>
  <br>
  В [70] Коффман (Coffman) и другие исследователи доказали, что для возникновения 
  ситуации взаимоблокировки должны выполняться четыре условия:<br>
<dd> 1. Условие взаимного исключения. Каждый ресурс в данный момент или отдан 
  ровно одному процессу, или доступен.<br>
<dd> 2. Условие удержания и ожидания. Процессы, в данный момент удерживающие полученные 
  ранее ресурсы, могут запрашивать новые ресурсы.<br>
<dd> 3. Условие отсутствия принудительной выгрузки ресурса. У процесса нельзя 
  принудительным образом забрать ранее полученные ресурсы. Процесс, владеющий 
  ими, должен сам освободить ресурсы.<br>
<dd> 4. Условие циклического ожидания. Должна существовать круговая последовательность 
  из двух и более процессов, каждый из которых ждет доступа к ресурсу, удерживаемому 
  следующим членом последовательности.<br>
<dd> Для того чтобы произошла взаимоблокировка, должны выполниться все эти четыре 
  условия. Если хоть одно из них отсутствует, тупиковая ситуация невозможна.<br>
<dd> Следует отметить, что каждое условие относится к стратегии определения того, 
  что в системе позволяется, а что — нет. Может ли данный ресурс быть отдан одновременно 
  больше чем одному процессу? Может ли процесс удерживать один ресурс и запрашивать 
  второй? Можно ли отнять ресурс у процесса? Может ли существовать циклическое 
  ожидание? Позже мы увидим, как можно разрушать взаимоблокировки с помощью сведения 
  &laquo;на нет&raquo; некоторых из этих условий.<br>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Моделирование взаимоблокировок</font></b><br>
  <br>
  В [156] Холт (Holt) показал, как можно смоделировать четыре условия возникновения 
  тупиков, используя направленные графы. Графы имеют два вида узлов: процессы, 
  показанные кружочками, и ресурсы, нарисованные квадратиками. Ребро, направленное 
  от узла ресурса (квадрат) к узлу процесса (круг), означает, что ресурс ранее 
  был запрошен процессом, получен и в данный момент используется этим процессом. 
  На рис. 3.1, <i>а</i> ресурс <i>R</i> в настоящее время отдан процессу A.<br>
  <center>
    <br>
    <img src="08/Tanenbaum_3_1.jpg" alt="Графы распределения ресурсов"><br>
    <br>
    <b><font face="Arial">Рис. 3.1.</font></b><font face="Arial"> Графы распределения 
    ресурсов: ресурс занят (а); запрос ресурса (б); взаимоблокировка (в)</font><br>
  </center>
  <br>
<dd> Ребро, направленное от процесса к ресурсу, означает, что процесс в данный 
  момент блокирован и находится в состоянии ожидания доступа к этому ресурсу. 
  На рис. 3.1, <i>б</i> процесс <i>В</i> ждет ресурс S. На рис. 3.1, <i>в</i> 
  мы видим взаимоблокировку: процесс <i>С</i> ожидает ресурс <i>Т,</i> удерживаемый 
  в настоящее время процессом <i>D.</i> Процесс <i>D</i> вовсе не намеревается 
  освобождать ресурс <i>Т,</i> потому что он ждет ресурс <i>U,</i> используемый 
  процессом <i>С.</i> Оба процесса будут ждать до бесконечности.<br>
<dd> Цикл в графе означает наличие взаимоблокировки, циклично включающей процессы 
  и ресурсы (предполагается, что в системе есть по одному ресурсу каждого вида). 
  В этом примере циклом является последовательность <i>C-T-D-U-C.</i><br>
<dd> Теперь рассмотрим пример того, как можно использовать графы ресурсов. Представим, 
  что у нас есть три процесса: <i>А, В</i> и С, и три ресурса: <i>R, S</i> и <i>Т.</i> 
  Последовательность запросов и возвратов ресурсов для трех процессов показаны 
  на рис. 3.2, <i>а—в.</i> Операционная система может запустить любой незаблокированный 
  процесс в любой момент времени, значит, она может решить запустить сначала процесс 
  <i>А.</i> Процесс <i>А</i> будет выполняться до тех пор, пока не закончит всю 
  свою работу, затем будет запущен процесс <i>В</i> до его завершения и, наконец, 
  процесс <i>С.</i><br>
<dd> Такой порядок не приводит к взаимоблокировке (потому что при нем не возникает 
  соперничества за использование ресурсов), но при нем также вообще нет параллельной 
  работы. Кроме запросов и возвратов ресурсов, процессы выполняют вычисления и 
  ввод-вывод данных. Когда процессы работают последовательно, невозможна ситуация, 
  при которой один процесс использует процессор, в то время как другой ждет завершения 
  операции ввода-вывода. Таким образом, строго последовательная работа процессов 
  не может быть оптимальной. С другой стороны, если вообще ни один процесс не 
  выполняет операций ввода-вывода, алгоритм &laquo;кратчайшая задача — первая&raquo; 
  работает лучше, чем циклический, поэтому в некоторой обстановке последовательный 
  запуск всех процессов может быть наилучшим.<br>
<dd> Теперь предположим, что процессы выполняют как расчеты, так и ввод-вывод, 
  так что циклический алгоритм планирования является рациональным. Запросы ресурсов 
  могут происходить в порядке, указанном на рис. 3.2, <i>г.</i> Если эти шесть 
  запросов будут осуществлены в такой последовательности, в результате мы получим 
  шесть графов, показанных на рис. 3.2, <i>д—к.</i> После запроса 4 процесс <i>А</i> 
  блокируется в ожидании ресурса <i>S</i> (рис. 3.2, з). На двух следующих шагах 
  также блокируются процессы <i>В</i> и <i>С,</i> в конечном счете приводя к циклу 
  и взаимоблокировке на рис. 3.2, <i>к.</i><br>
<dd> Однако, как мы упоминали ранее, операционная система не обязана запускать 
  процессы в каком-то особом порядке. В частности, если выполнение отдельного 
  запроса приводит в тупик, операционная система может просто приостановить процесс 
  без удовлетворения запроса (то есть не выполняя план процесса) до тех пор, пока 
  это безопасно. На рис. 3.2 операционная система могла бы приостановить процесс 
  <i>В</i> вместо того, чтобы отдавать ему ресурс 5, если бы она знала о предстоящей 
  взаимоблокировке. Работая только с процессами <i>А и С,</i> мы могли бы получить 
  порядок запросов ресурсов и их возвратов, продемонстрированный на рис. 3.2, 
  <i>л,</i> вместо показанного на рис. 3.2, г. Такая последовательность действий 
  отражена графами на рис. 3.2, <i>м—с,</i> и она не приводит к взаимоблокировке.<br>
<dd> После шага <i>с</i> процесс <i>В</i> может получить ресурс S, потому что 
  процесс <i>А</i> уже закончил свою работу, а процесс <i>С</i> имеет в своем 
  распоряжении все необходимые ему ресурсы. Даже если затем процесс <i>В,</i> 
  когда он запросит ресурс <i>Т,</i> будет заблокирован, система не попадет в 
  тупик. Процесс <i>В</i> всего лишь будет ждать завершения работы процесса <i>С.</i><br>
  <center>
    <br>
    <img src="08/Tanenbaum_3_2.jpg" alt=" Пример возникновения взаимоблокировки и способы избежать ее"><br>
    <br>
    <b><font face="Arial">Рис. 3.2.</font></b><font face="Arial"> Пример возникновения 
    взаимоблокировки и способы избежать ее</font><br>
  </center>
  <br>
<dd> Позже в этой главе мы изучим подробный алгоритм для принятия решений о распределении 
  ресурсов, которые не приведут к взаимоблокировке. В данный момент важно понять, 
  что графы ресурсов являются инструментом, позволяющим нам увидеть, станет ли 
  заданная последовательность запросов/возвратов ресурсов причиной взаимоблокировки. 
  Мы всего лишь шаг за шагом осуществляем запросы и возвраты ресурсов и после 
  каждого шага проверяем граф на содержание циклов. Если они есть, мы зашли в 
  тупик; если нет, значит, взаимоблокировки тоже нет. Хотя мы рассматривали графы 
  ресурсов для случая, когда в системе присутствует по одному ресурсу каждого 
  типа, графы также можно построить для обработки ситуации с несколькими одинаковыми 
  ресурсами [156]. Вообще говоря, при столкновении с взаимоблокировками используются 
  четыре стратегии.<br>
<dd> 1. Пренебрежение проблемой в целом. Если вы проигнорируете проблему, возможно, 
  затем она проигнорирует вас.<br>
<dd> 2. Обнаружение и восстановление. Позволить взаимоблокировке произойти, обнаружить 
  ее и предпринять какие-либо действия.<br>
<dd> 3. Динамическое избежание тупиковых ситуаций с помощью аккуратного распределения 
  ресурсов.<br>
<dd> 4. Предотвращение с помощью структурного опровержения одного из четырех условий, 
  необходимых для взаимоблокировки.<br>
<dd> Мы по очереди изучим каждый из этих методов в следующих четырех разделах.<br>
</BODY>
</HTML>
