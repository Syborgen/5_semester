<HTML>
<HEAD>
<TITLE>Моделирование алгоритмов замещения страниц</TITLE>
</HEAD>
<body>
  <b><font size="6"><center>Моделирование алгоритмов замещения страниц</center></font></b><br>
  <br>
  За годы было проведено несколько работ, посвященных теоретическому моделированию 
  алгоритмов замещения страниц. В данном разделе мы обсудим некоторые из этих 
  идей, чтобы увидеть, как работает процесс моделирования.<br>
  <br>
  <br>
<a NAME="01"></a>
  <b><font size="4">Аномалия Билэди</font></b><br>
  <br>
  Интуитивно может показаться, что чем больше страничных блоков имеет память, 
  тем меньше будет происходить страничных прерываний. Достаточно удивителен тот 
  факт, что это не всегда так. Билэди (Belady) и другие исследователи в своей 
  работе [23] описали обнаруженный ими контрпример, в котором алгоритм FIFO вызывал 
  больше страничных прерываний при четырех страничных блоках, чем при трех. Эта 
  странная ситуация стала известна как <b>аномалия Билэди</b>. Она проиллюстрирована 
  на рис. 4.22 для программы с пятью виртуальными страницами, пронумерованными 
  от 0 до 4. Буквы &laquo;P&raquo; показывают, какие обращения вызывают страничные 
  прерывания. Обращения к страницам происходят в следующем порядке:<br>
  <br>
<dd> <font face="Arial">012301401234</font><br>
  <br>
<dd> На рис. 4.22, <i>а</i> показано, как при наличии трех страничных блоков вызывается 
  в целом девять страничных прерываний. На рис. 4.22,6 изображены десять страничных 
  прерываний при работе с четырьмя страничными блоками.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_22.jpg" alt="Аномалия Билэди: алгоритм FIFO при работе с тремя страничными блоками (а); алгоритм FIFO при наличии четырех страничных блоков (б)"> 
    <br>
    <br>
    <b>Рис. 4.22.</b> Аномалия Билэди: алгоритм FIFO при работе с тремя страничными 
    блоками (а);<br>
    алгоритм FIFO при наличии четырех страничных блоков (б)<br>
  </center>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Магазинные алгоритмы</font></b><br>
  <br>
  Аномалия Билэди настолько потрясла многих исследователей в области кибернетики, 
  что они начали изучать данную ситуацию, и это привело к развитию целой теории 
  алгоритмов подкачки страниц и их свойств. Хотя большая часть данных исследований 
  лежит далеко за пределами нашей книги, ниже мы кратко рассмотрим основные моменты. 
  За более подробной информацией следует обратиться к [220].<br>
<dd> Вся работа началась с наблюдения, что каждый процесс с момента запуска формирует 
  последовательность обращений к памяти. Любая ссылка к памяти соответствует определенной 
  виртуальной странице. Таким образом, концептуально доступ процесса к памяти 
  можно описать (упорядоченным) списком номеров страниц. Этот список называется 
  последовательностью или <b>строкой обращений</b> (reference string) и играет 
  главную роль во всей теории. Для простоты далее мы будем рассматривать вариант 
  машины с одним процессом, то есть когда каждая машина имеет единственную определенную 
  последовательность обращений (при нескольких процессах мы должны были бы принять 
  во внимание чередование их строк обращений вследствие многозадачности).<br>
<dd> Систему со страничной организацией памяти можно охарактеризовать следующими 
  тремя объектами:<br>
  <br>
<dd> 1. Последовательность обращений для выполняемого процесса.<br>
<dd> 2. Алгоритм замещения страниц.<br>
<dd> 3. Количество доступных в памяти страничных блоков <i>m</i>.<br>
  <br>
<dd> Мысленно мы можем представить себе абстрактный интерпретатор, работающий 
  следующим образом. Он поддерживает внутренний массив М, отслеживающий состояние 
  памяти. Количество элементов массива равно количеству виртуальных страниц процесса, 
  это число мы назовем <i>n</i>. Массив <i>М</i> разделен на две части. В верхней 
  части, куда входит <i>m</i> записей, расположены все страницы, которые в данный 
  момент находятся в памяти. В нижней части размером <i>n — m</i> записей содержатся 
  номера всех страниц, к которым когда-то произошло обращение, но они были выгружены 
  из памяти и в данный момент в ней отсутствуют. В исходном положении массив <i>M</i> 
  пуст, так как процесс еще не обращался ни к одной странице, и в памяти страниц 
  тоже еще нет.<br>
<dd> После запуска процесс начинает вызывать страницы из строки обращений по одной. 
  Как только появляется очередная страница, интерпретатор проверяет, находится 
  ли страница в памяти (то есть в верхней части массива <i>М</i>). Если нет, происходит 
  страничное прерывание. Если в памяти есть пустой сегмент (то есть верхняя часть 
  массива <i>М</i> содержит меньше, чем <i>m</i> записей), страница загружается 
  и добавляется в верхнюю часть массива <i>М.</i> Подобная ситуация возникает 
  только на начальной стадии выполнения. Если память заполнена (то есть верхняя 
  часть массива <i>М</i> содержит <i>m</i> записей), то, чтобы удалить страницу 
  из памяти, активизируется алгоритм замещения страниц. В модели все происходит 
  так: одна страница перемещается из верхней части массива <i>М</i> в его нижнюю 
  часть, а требуемая страница входит наверх. Кроме того, верхняя и нижняя части 
  массива могут быть упорядочены отдельно друг от друга.<br>
<dd> Чтобы прояснить функционирование интерпретатора, рассмотрим конкретный пример, 
  использующий алгоритм замещения страниц LRU. Виртуальное адресное пространство 
  имеет восемь страниц, а в физической памяти есть четыре страничных блока. Сверху 
  на рис. 4.23 изображена последовательность обращений, состоящая из 24 страниц:<br>
  <br>
<dd> <font face="Arial">021354637473355311171341</font><br>
  <br>
<dd> Ниже последовательности обращений расположена таблица из 25 столбцов и 8 
  строк. Первый столбец не заполнен, так как он отражает состояние массива <i>М</i> 
  до запуска процесса. Каждый следующий столбец демонстрирует массив <i>М</i> 
  после того, как одна из страниц была извлечена обращением к ней и обработана 
  алгоритмом подкачки страниц. Жирный контур отделяет верхнюю часть массива <i>М,</i> 
  то есть первые четыре элемента, соответствующие страничным блокам в памяти. 
  Страницы внутри жирной рамки находятся в памяти, страницы, расположенные ниже, 
  были выгружены на диск.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_23.jpg" alt="Состояние массива памяти М после обработки каждого элемента строки обращений. Последовательность расстояний будет обсуждаться в следующем разделе"><br>
    <br>
    <b>Рис. 4.23.</b> Состояние массива памяти М после обработки каждого элемента 
    строки обращений.<br>
    Последовательность расстояний будет обсуждаться в следующем разделе<br>
  </center>
  <br>
<dd> Первой в последовательности обращений является страница 0, поэтому она помещается 
  на самый верх памяти, как показано во втором столбце. Следующая страница под 
  номером 2 попадает в верхнюю ячейку третьего столбца. Это действие сдвигает 
  вниз страницу 0. В данном примере заново загружаемая страница всегда занимает 
  верхнюю ячейку, а все остальное по необходимости сдвигается вниз.<br>
<dd> Каждая из первых семи страниц в последовательности обращений вызывает страничное 
  прерывание. Первые четыре можно обработать, не удаляя страницы из памяти, но 
  начиная со страницы 5 загрузка новой страницы требует удаления старой.<br>
<dd> Второе обращение к странице 3 не вызывает страничного прерывания, потому 
  что она уже находится в памяти. Тем не менее интерпретатор убирает ее с того 
  места, где она располагалась, и помещает в верхнюю ячейку столбца, как показано 
  на рисунке. Процесс продолжает работу некоторое время, до тех пор, пока не происходит 
  обращение к странице 5. Эта страница переносится из нижней части массива <i>M</i> 
  в верхнюю (то есть она загружается в память с диска). Всякий раз, когда страница, 
  к которой обращается процесс, не находится внутри рамки, очерченной жирной линией, 
  происходит страничное прерывание, что отмечено буквами &laquo;П&raquo; в строке 
  под таблицей.<br>
<dd> Теперь кратко перечислим некоторые свойства этой модели. Во-первых, когда 
  происходит обращение к странице, она всегда перемещается в верхнюю запись массива 
  <i>М.</i> Во-вторых, если запрашиваемая страница уже находилась в массиве <i>М</i>, 
  все страницы выше нее сдвигаются на одну позицию вниз. Переход из рамки за ее 
  пределы соответствует удалению страниц из памяти. В-третьих, страницы, находящиеся 
  ниже объекта обращения, не перемещаются. Таким образом, содержимое массива <i>М</i> 
  в точности представляет собой компоненты алгоритма LRU.<br>
<dd> Хотя в этом примере используется алгоритм LRU, данная модель с тем же успехом 
  работает и с другими схемами. В частности, существует один класс алгоритмов, 
  которые представляют особенный интерес, они обладают свойством:<br>
  <br>
<dd> <i><font face="Arial">М(m,r) с М(m + 1,r),</font></i><br>
  <br>
<dd> где число <i>m</i> обозначает количество страничных блоков, а <i>r</i> — 
  это индекс в последовательности обращений. Изображенное выше выражение означает, 
  что множество страниц, после <i>r</i> обращений попавших в верхнюю часть массива 
  <i>М,</i> для памяти, имеющей <i>m</i> страничных блоков, также входит в массив 
  <i>М,</i> если память состоит из <i>m</i> + 1 страничных блоков. Другими словами, 
  если мы увеличим размер памяти на один страничный блок и выполним процесс заново, 
  то в каждый момент времени все страницы, присутствовавшие в памяти во время 
  первой обработки, при втором запуске будут также находиться в памяти вместе 
  с еще одной дополнительной страницей.<br>
<dd> Если изучить пример на рис. 4.23 и немного подумать о том, как он функционирует, 
  должно стать ясно, что алгоритм LRU удовлетворяет данному условию. Некоторые 
  другие алгоритмы (например, оптимальный алгоритм замещения) также обладают этим 
  свойством, но алгоритм FIFO его не имеет. Алгоритмы, удовлетворяющие условию, 
  наложенному на массив <i>М,</i> называются <b>магазинными алгоритмами</b> (stack 
  algorithms). Они не подвержены аномалии Билэди и, соответственно, намного более 
  любимы теоретиками, занимающимися виртуальной памятью.<br>
  <br>
  <br>
<a NAME="03"></a>
  <b><font size="4">Строка расстояний</font></b><br>
  <br>
  Часто для магазинных алгоритмов удобно представить последовательность обращений 
  в более абстрактном виде, чем фактические номера страниц. С этого момента обращение 
  к странице будет обозначаться с помощью расстояния от верха стека, где расположена 
  запрашиваемая страница. Например, обращение к странице 1 в последнем столбце 
  на рис. 4.23 равносильно ссылке на страницу, имеющую расстояние 3 от вершины 
  стека (потому что страница 1 <i>перед </i> запросом находилась на третьем месте). 
  О страницах, к которым еще не было обращений и поэтому они еще не попали в стек 
  памяти (то есть они еще не находятся в массиве <i>М),</i> говорят, что они имеют 
  расстояние &deg;&deg; (бесконечность). Строка расстояний для примера на рис. 
  4.23 изображена внизу рисунка.<br>
<dd> Заметим, что строка расстояний зависит не только от последовательности обращений, 
  но и от алгоритма подкачки страниц. При одной и той же последовательности обращений 
  различные алгоритмы замещения страниц могут выбирать для удаления разные страницы. 
  В результате возникает свой порядок стека для каждого алгоритма.<br>
<dd> Статистические свойства последовательности расстояний сильно влияют на производительность 
  алгоритма. На рис. 4.24, <i>а </i> представлена функция, обозначающая плотность 
  вероятности для вхождений страниц в (воображаемую) строку расстояний <i>d.</i> 
  Большинство попаданий страниц находится между 1 и <i>k.</i> Если в памяти всего 
  <i>k</i> страничных блоков, то страничные прерывания происходят редко.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_24.jpg" alt="Плотность вероятности для двух гипотетических строк расстояний"> 
    <br>
    <br>
    <b>Рис. 4.24.</b> Плотность вероятности для двух гипотетических строк расстояний<br>
    <br>
  </center>
<dd> Напротив, на рис. 4.24, <i>б</i> обращения к памяти так разбросаны, что единственный 
  способ избежать огромного количества страничных прерываний — это предоставить 
  программе столько страничных блоков, сколько она использует виртуальных страниц. 
  Если вам приходится работать с подобными программами, значит, у вас, видимо, 
  просто плохая карма.<br>
  <br>
  <br>
<a NAME="04"></a>
  <b><font size="4">Прогнозирование частоты страничных прерываний</font></b><br>
  <br>
  Одно из приятных свойств последовательности расстояний заключается в том, что 
  ее можно использовать для прогнозирования количества страничных прерываний, 
  которые могут произойти в памяти различного размера. Мы продемонстрируем, как 
  можно выполнить подобные вычисления на основе примера с рис. 4.23. Нашей целью 
  является следующее: сделать один проход по строке расстояний и по собранной 
  информации суметь предсказать, сколько страничных прерываний мог бы вызвать 
  процесс в памяти размером в 1, 2, 3, ..., <i>n</i> страничных блоков, где <i>n 
  —</i> это количество виртуальных страниц в адресном пространстве процесса.<br>
<dd> Алгоритм начинается с изучения последовательности расстояний, страница за 
  страницей. Он подсчитывает, сколько раз встречается число 1, число 2 и т. д. 
  Пусть число <i>i</i> встречается в строке расстояний <i>C<sub>i</sub></i> количество 
  раз. Вектор <i>С</i> для последовательности расстояний на рис. 4.23 изображен 
  на рис. 4.25, <i>а,</i> В этом примере получилось так, что четыре раза происходит 
  обращение к странице, уже находящейся на вершине стека. Три раза запрашивается 
  следующая страница и т. д. Пусть С<sub>&deg;&deg;</sub> — это количество раз, 
  которое встречается символ &deg;&deg; в последовательности расстояний.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_25.jpg" alt="Вычисление количества страничных прерываний из последовательности расстояний: вектор С (а); вектор F (б)"><br>
    <br>
    <b>Рис. 4.25.</b> Вычисление количества страничных прерываний из последовательности<br>
    расстояний: вектор <i>С</i> (а); вектор <i>F</i>(б)<br>
  </center>
  <br>
<dd> Теперь вычислим вектор F в соовтветствии с формулой<br>
  <center>
    <img src="09/Tanenbaum_4_26.jpg"> 
  </center>
  <br>
<dd> Величина <i>F<sub>m</sub></i> обозначает количество страничных прерываний, 
  которое произойдет для заданной последовательности расстояний и <i>m</i> страничных 
  блоков. На рис. 4.25, <i>б</i> показан вектор <i>F</i> для строки расстояний, 
  представленной на рис. 4.23. Например, величина <i>F<sub>1</sub></i>, равная 
  20, означает, что если память состоит всего лишь из одного страничного блока, 
  то из 24-х обращений в последовательности вызовут страничное прерывание все, 
  кроме четырех, которые запрашивают ту же страницу, что и предыдущая ссылка.<br>
<dd> Чтобы увидеть, как работает формула, вернемся к рамке, очерченной жирной 
  линией на рис. 4.23. Пусть <i>m</i> - это количество страниц в верхней части 
  массива <i>М.</i> Страничное прерывание происходит всякий раз, когда элемент 
  последовательности расстояний равен <i>m+1</i> или больше. В написанной выше 
  формуле суммируется то количество раз, которое встречаются в последовательности 
  такие элементы. Эта модель также может использоваться и для других прогнозов 
  [220].<br>
</BODY>
</HTML>
