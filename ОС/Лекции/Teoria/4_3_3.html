<html >

<body lang=RU >

<center><h1>Фрагментация NTFS</h1></center>

<p >В самом начале
утверждалось, что NTFS не подвержена фрагментации файлов. Это оказалось не
совсем так, и утверждение сменили - NTFS препятствует фрагментации. Оказалось,
что и это не совсем так. То есть она, конечно, препятствует, но толк от этого
близок к нулю... Сейчас уже понятно, что NTFS - система, которая как никакая
другая предрасположена к
фрагментации, что бы не утверждалось официально. Единственное что - логически
она не очень от этого страдает. Все внутренние структуры построены таким
образом, что фрагментация не мешает быстро находить фрагменты данных. Но от
физического последствия фрагментации - лишних движений головок - она, конечно,
не спасает.</p>

<p>NTFS - очень экономная
система. Размер кластеров в ней разумно минимален - обычно это 4 кб (на
стандартных сейчас дисках в десяток-другой гигабайт). Как известно, система
сильнее всего фрагментирует файлы когда свободное место кончается, когда
приходится использовать мелкие дырки, оставшиеся от других файлов. Тут
возникает первое свойство NTFS, которое прямо способствует серьезной
фрагментации.</p>

<p >Диск NTFS поделен на две
зоны. В начала диска идет MFT зона - зона, куда растет MFT, Master File Table.
Зона занимает минимум 12% диска, и запись данных в эту зону невозможна. Это
сделано для того, чтобы не фрагментировался хотя бы MFT. Но когда весь
остальной диск заполняется - зона сокращается ровно в два раза. И так далее.
Таким образом мы имеем не один заход окончания диска, а несколько. В результате
если NTFS работает при диске, заполненном на около 90% - фрагментация растет
как бешенная.</p>

<p>Попутное следствие -
диск, заполненный более чем на 88%, дефрагментировать почти невозможно - даже
API дефрагментации не может перемещать данные в MFT зону. Может оказаться так,
что у нас не будет свободного места для маневра. </p>

<p>Далее. NTFS работает себе
и работает, и всё таки фрагментируется. Этому способствует странный алгоритм
нахождения свободного места - второе серьезное упущение. Если файл пишется
большими кусками - всё нормально. Но если файл медленно растет - алгоритм
такой: берется какой-то определенный объем диска и заполняется файлом до упора.
Причем по очень интересному алгоритму: сначала заполняются большие дырки, потом
маленькие. Т.е. типичное распределение фрагментов файла по размеру на
фрагментированной NTFS выглядит так (размеры фрагментов):16 - 16 - 16 - 16 - 16
- [скачек назад] - 15 - 15 - 15 - [назад] - 14 - 14 - 14 .... 1 - 1 - 1 -1 -
1...</p>

<p>Так процесс идет до самых
мелких дырок в 1 кластер, несмотря на то, что, на диске наверняка есть и
гораздо более большие куски свободного места.</p>

<p>Смысл в том, что никак
нельзя сказать, что NTFS препятствует фрагментации файлов. Наоборот, она с
радостью их фрагментирует. Фрагментация NTFS через пол года работы доведет до
искреннего удивления любого человека, знакомого с работой файловой системой.
Поэтому приходится запускать дефрагментатор. Но на этом все наши проблемы не
заканчиваются, а, увы, только
начинаются...</p>

<p>В NT существует
стандартное API дефрагментации. Обладающее интересным ограничением для
перемещения блоков файлов: за один раз можно перемещать не менее 16 кластеров
(!), причем начинаться эти кластеры должны с позиции, кратной 16 кластерам в
файле. В общем, операция осуществляется исключительно по 16 кластеров.
Следствия:</p>

<p>- В дырку свободного
места менее 16 кластеров нельзя ничего
переместить (кроме сжатых файлов, но это тонкости). </p>

<p>- Файл, будучи
перемещенный в друге место, оставляет после себя (на новом месте)
&quot;временно занятое место&quot;, дополняющее его по размеру до кратности 16
кластерам. </p>

<p>- При попытке как-то
неправильно (&quot;не кратно 16&quot;) переместить файл результат часто
непредсказуем. Что-то округляется, что-то просто не перемещается.. Тем не
менее, всё место действия щедро рассыпается &quot;временно занятым
местом&quot;. Наверное о нас заботятся, чтобы мы отстали от этого места - чтобы
алгоритм дефрагментации не клинило.</p>

<p>- &quot;Временно занятое
место&quot; освобождается через некоторое время, обычно где-то пол минуты. </p>

<p>Тем не менее, логично
было бы использовать это API. Его и используют. Поэтому процесс стандартной
дефрагментации, с поправками на ограниченность API, идет следующими фазами, не
обязательно в этом порядке:<o:p></o:p></p>

<p >- Вынимание файлов из MFT
зоны. Не специально - просто обратно туда их положить не представляется
возможным. </p>

<p>- Дефрагментация файлов.
Безусловно полезный процесс, несколько правда осложняемый ограничениями
кратности перемещений - файлы часто приходится перекладывать сильнее, чем это
было бы логично сделать по уму.</p>

<p class=MsoNormal style='margin-left:18.0pt;text-align:justify;line-height:
150%'><span style='font-size:14.0pt;line-height:150%'>- Дефрагментация MFT,
виртуалки (pagefile.sys) и каталогов. Возможна через API только в Windows2000,
иначе - при перезагрузке, отдельным процессом, как в Diskeeper-е. <o:p></o:p></span></p>

<p>- Складывание файлов
ближе к началу - так называемая дефрагментация свободного места. Вот это -
воистину страшный процесс... </p>

<p>Допустим, мы хотим
положить файлы подряд в начало диска. Кладем один файл. Он оставляет хвост
занятости дополнения до кратности 16. Кладем следующий - после хвоста,
естественно. Через некоторое время, по освобождению хвоста, имеем дырку &lt;16
кластеров размером. Которую потом невозможно заполнить через API
дефрагментации! В результате, до оптимизации картина свободного места выглядела
так: много дырок примерно одинакового размера. После оптимизации - одна дыра в
конце диска, и много маленьких &lt;16 кластеров дырок в заполненном файлами
участке. Какие места в первую очередь заполняются? Правильно, находящиеся ближе
к началу диска мелкие дырки &lt;16 кластеров... Любой файл, плавно созданный на
прооптимизированном диске, будет состоять из дикого числа фрагментов. Да, диск
потом можно оптимизировать снова. А потом еще раз.. и еще.. и так - желательно
каждую неделю. Бред? Реальность.</p>

<p>Таким образом, имеется
два примерно равнозначных варианта. Первый - часто оптимизировать диск таким
дефрагментатором, смиряясь при этом с дикой
фрагментацией заново созданных файлов. Второй вариант - вообще ничего не
трогать, и смириться с равномерной, но гораздо более слабой фрагментацией всех
файлов на диске.</p>

<p>Пока есть один
дефрагментатор, который игнорирует API дефрагментации и работает как-то более
напрямую - Norton Speeddisk 5.0 для NT. Когда его пытаются сравнить со всеми
остальными - Diskeeper, O&amp;O defrag, т.д. - не упоминают этого главного,
самого принципиального, отличия. Просто потому, что эта проблема тщательно
скрывается, по крайней мере уж точно не афишируется на каждом шагу. Speeddisk -
единственная на сегодняшний день
программа, которая может оптимизировать диск полностью, не создавая маленьких
незаполненных фрагментов свободного места.</p>

<p >К сожалению, в Windows
2000 засунули дефрагментатор, который работает через API, и соответственно
плодит дырки &lt;16 кластеров. Так что как только появится (если уже не
появился) - так сразу надо качать Speeddisk для W2k. Как некоторый вывод из всего
этого - все остальные дефрагментаторы при одноразовом применении просто вредны. Если вы запускали его хоть раз
- нужно запускать его потом хотя бы раз в месяц, чтобы избавится от
фрагментации новоприбывающих файлов. В этом основная суть сложности дефрагментации
NTFS теми средствами, которые сложились исторически.</p>

<p >Программа fv выводит
количество фрагментов в файлах текущего каталога, а с ключом /v [имя файла] -
список размеров блоков(фрагментов) указанного файла, в кластерах. Знак ~
означает, что следующий фрагмент находился ближе к началу диска, чем
предыдущий. </p>

</body>
</html>
