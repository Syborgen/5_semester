<HTML><HEAD><TITLE>Файловая система DOS</TITLE>
<BODY>
<center>
<h1>Файловая система DOS</h1>
</center>
<UL>
  <LI><A 
  href="#b3.1"> 
  Получение справочной информации</A> 
  <LI><A 
  href="#b3.2"> 
  Работа с каталогами</A> 
  <LI><A 
  href="#b3.3"> 
  Поиск в каталогах</A> 
  <LI><A 
  href="#b3.4"> 
  Работа с файлами</A> 
  <LI><A 
  href="#b3.5"> 
  Чтение и запись файлов</A> 
  <LI><A 
  href="#b3.6"> 
  Позиционирование</A> 
  <LI><A 
  href="#b3.7"> 
  Изменение дескриптора файла</A> 
  <LI><A 
  href="#b3.8"> 
  Буферизация</A> 
  <LI><A 
  href="#b3.9"> 
  Потоки ввода и вывода</A> 
  <LI><A 
  href="#b3.10"> 
  Другие функции для работы с файлами</A> 
  <LI><A 
  href="#b3.11"> 
  Таблица открытых файлов</A> 
  <LI><A 
  href="#b3.12"> 
  Обработка критических ошибок</A> </LI></UL>
<P>Теперь, после того как мы познакомились с логической структурой диска, можно 
приступить к изучению одной из самых развитых систем MS-DOS - файловой системы . 
</P>
<P>Сервис файловой системы доступен программе через прерывание INT&nbsp;21h . 
Многочисленные функции этого прерывания, относящиеся к файловой системе, можно 
разбить на группы: 
<UL>
  <LI><I>получение справочной информации;</I> 
  <LI><I>работа с каталогами;</I> 
  <LI><I>работа с файлами.</I> </LI></UL>
<P>Функции первой группы позволяют программе получать разностороннюю информацию, 
касающуюся текущего состояния дисковой системы - текущий диск и текущий каталог, 
размер свободного места на диске, параметры логического диска и т. д. </P>
<P>Функции второй группы выполняют все необходимые операции с каталогами - 
создание, переименование, уничтожение каталогов, изменение текущего каталога. 
</P>
<P>Третья группа функций позволяет программе выполнять практически любые 
операции над файлами - создание, удаление, чтение или запись, переименование, 
копирование, пересылка. </P>
<P>Заметим, что существует два класса функций для работы с файлами. Первый класс 
использует управляющие блоки файлов FCB . Эти функции использовались в MS-DOS 
версий 1.х и имеют в настоящее время чисто исторический интерес. Вам они, скорее 
всего, никогда не будут нужны, за исключением одного случая - если вам надо 
составить программу, способную работать под управлением MS-DOS версии 1.0 или 
1.1. В этой книге мы не будем упоминать функции, предназначенные для работы с 
файлами через FCB. </P>
<P>Второй класс использует идентификаторы файла (file handle). Этот класс 
функций впервые появился в MS-DOS версии 2.0. </P>
<P>Смысл идентификатора файла индекса очень прост. Для того чтобы приступить к 
работе с файлом, программа должна вызывать определенную функцию DOS, 
"открывающую" этот файл. Процесс открытия файла заключается в присвоении ему 
определенного числа (идентификатора) и выполнении некоторых других 
инициализирующих действий. Для выполнения каких-либо операций с файлом 
программа, вызывая соответствующую функцию MS-DOS, должна указать идентификатор 
этого файла. </P>
<P>Первые пять идентификаторов зарезервированы операционной системой: <BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD width0><STRONG>Идентификатор</STRONG></TD>
    <TD width15><STRONG>Описание</STRONG></TD></TR>
  <TR>
    <TD width0>0</TD>
    <TD width15>Стандартное устройство ввода (клавиатура) </TD></TR>
  <TR>
    <TD width0>1</TD>
    <TD width15>Стандартное устройство вывода (консоль) </TD></TR>
  <TR>
    <TD width0>2</TD>
    <TD width15>Стандартное устройство для вывода сообщений об ошибках 
      (консоль) </TD></TR>
  <TR>
    <TD width0>3</TD>
    <TD width15>Стандартное устройство последовательного ввода/вывода, 
      обычно асинхронный адаптер COM1 </TD></TR>
  <TR>
    <TD width0>4</TD>
    <TD width15>Стандартное печатающее устройство (обычно параллельный порт 
      LPT1) </TD></TR></TBODY></TABLE>
<P>Зарезервированные идентификаторы всегда доступны программе. Для устройств, 
соответствующих этим идентификаторам, не требуется выполнять операцию открытия. 
</P>
<P>Одно из преимуществ файловых функций второго класса (использующих 
идентификаторы файлов) - возможность одновременной работы с файлами, 
расположенными в разных каталогах. </P>
<P>Состав функций MS-DOS, предназначенных для работы с файловой системой, 
достаточно разнообразен. Только в очень редких случаях, связанных в основном с 
организацией защиты информации от несанкционированного доступа, вам может 
потребоваться доступ к диску на более низком уровне. Если ваша программа 
использует для работы с файлами только документированные функции операционной 
системы, ее работа не будет зависеть от аппаратных средств компьютера, а также 
от программы, с помощью которой были созданы разделы диска MS-DOS. </P>
<H2><A name="b3.1"><FONT color=#0000ff face=Arial size=4> </FONT><FONT 
color=#0000ff size=4>Получение справочной информации</FONT></A> </H2>
<P>В этом разделе мы опишем наиболее нужные, на наш взгляд, функции MS-DOS, 
предназначенные для получения справочной информации о состоянии дисковой 
системы. </P>
<H3><FONT color=#008000 size=4>Текущий диск и текущий каталог</FONT></H3>
<P>В любой момент времени программа может определить текущий диск или текущий 
каталог, а также сменить текущий диск или текущий каталог. Для этого она должна 
использовать специальные функции прерывания INT&nbsp;21h . </P>
<P>Для того чтобы узнать номер текущего диска, программа может воспользоваться 
функцией 19h:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthf>AH</TD>
    <TD width02>19h </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthf>AL</TD>
    <TD width02>Номер текущего устройства НГМД или НМД (0 - А:, 1 - В:, и т. 
      д.). </TD></TR></TBODY></TABLE>
<P>Для установки текущего диска можно использовать функцию 0Eh, которая имеет 
следующие параметры вызова:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthf>AH</TD>
    <TD width02>0Eh </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>DL</TD>
    <TD width02>Номер устройства НГМД или НМД (0 - А:, 1 - В:, и т. д.) 
  </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthf>AL</TD>
    <TD width02>Общее количество дисковых устройств в системе. Эта величина 
      соответствует параметру LASTDRIVE из файла CONFIG.SYS </TD></TR></TBODY></TABLE>
<P>Для того чтобы узнать текущий каталог, вы можете воспользоваться функцией 
47h:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthf>AH</TD>
    <TD width02>47h </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>DL</TD>
    <TD width02>Номер устройства НГМД или НМД (0 - текущий, 1 - А:, 2 - В:, 
      и т. д.) </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>DS:SI</TD>
    <TD width02>Адрес буфера для записи пути текущего каталога </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthf>AX</TD>
    <TD width02>Код ошибки, если установлен флаг переноса CF 
</TD></TR></TBODY></TABLE>
<P>Буфер должен иметь размер не менее 64 байт. Функция 47h возвращает текущий 
каталог в формате ASCIIZ (то есть строку, закрытую двоичным нулем, например: 
"path\dirname",0) без символа, обозначающего диск. Если текущим является 
корневой каталог, регистровая пара DS:SI будет указывать на нулевую строку 
(состоящую из одного двоичного нуля). </P>
<P>Функция 3Bh предназначена для установки текущего каталога:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthf>AH</TD>
    <TD width02>3Bh </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>DL</TD>
    <TD width02>Номер устройства НГМД или НМД (0 - текущий, 1 - А:, 2 - В:, 
      и т. д.) </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>DS:DX</TD>
    <TD width02>Адрес буфера, содержащего путь к каталогу, который должен 
      стать текущим </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthf>AX</TD>
    <TD width02>Код ошибки, если установлен флаг переноса CF 
</TD></TR></TBODY></TABLE>
<P>Буфер может иметь максимальный размер 64 байт. Он должен содержать путь в 
формате ASCIIZ. Строка не должна содержать символ, обозначающий диск. Если 
текущим должен стать корневой каталог, строка должна состоять только из одного 
двоичного нуля. </P>
<H3><FONT color=#008000 size=4>Определение размера кластера и 
сектора</FONT></H3>
<P>Функции MS-DOS могут помочь вам в получении информации, необходимой для 
организации доступа к диску на уровне секторов и кластеров. При этом вы будете 
избавлены от необходимости читать в память и анализировать содержимое 
загрузочного сектора логического диска. </P>
<P>Информация о таблице размещения файлов FAT для текущего диска может быть 
получена с помощью функции 1Bh прерывания INT&nbsp;21h , имеющего следующие 
параметры вызова:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthf>AH</TD>
    <TD width02>1Bh </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthf>DS:BX</TD>
    <TD width02>Адрес первого байта FAT . Это байт идентификации среды 
      носителя данных, соответствует байту media в блоке параметров BIOS </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>DX</TD>
    <TD width02>Общее количество кластеров на диске </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>AL</TD>
    <TD width02>Количество секторов в одном кластере </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>CX</TD>
    <TD width02>Количество байт в одном секторе </TD></TR></TBODY></TABLE>
<P>Дополнительно эта функция возвращает общее количество кластеров на диске, 
размер кластера в секторах и размер сектора в байтах. </P>
<P>Для старых версий MS-DOS регистровая пара DS:BX указывала на FAT , считанный 
в память. Более поздние версии операционной системы могут содержать по этому 
адресу только часть таблицы размещения файлов . </P>
<P>Для получения аналогичной информации не о текущем, а о любом диске, 
используйте функцию 1Ch. Эта функция полностью аналогична предыдущей, за 
исключением того, что в регистре DL должен быть указан номер НГМД или НМД: 0 - 
текущий, 1 - А:, 2 - В: и т. д. </P>
<H3><FONT color=#008000 size=4>Определение размера свободного 
пространства</FONT></H3>
<P>Если вас интересует размер свободного места на диске, вы можете его узнать с 
помощью функции 36h:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthf>AH</TD>
    <TD width02>36h </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>DL</TD>
    <TD width02>Номер устройства НГМД или НМД (0 - текущий, 1 - А:, 2 - В:, 
      и т. д.) </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthf>AX</TD>
    <TD width02>Количество секторов в кластере или 0FFFFh, если был задан 
      неправильный номер устройства </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>BX</TD>
    <TD width02>Количество свободных кластеров на диске </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>CX</TD>
    <TD width02>Количество байт в одном секторе </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>DX</TD>
    <TD width02>Общее количество кластеров на диске </TD></TR></TBODY></TABLE>
<P>Эта функция возвращает в регистре AX число 0FFFFh, если вы неправильно 
указали номер устройства. </P>
<H3><FONT color=#008000 size=4>Блок управления устройством DDCB </FONT></H3>
<P>При обсуждении векторной таблицы связи в предыдущем томе "Библиотеки 
системного программиста" мы рассказывали о блоках управления устройствами DDCB . 
Поле dev_cb векторной таблицы связи содержит дальний адрес цепочки этих блоков. 
</P>
<P>Для получения адреса блока DDCB можно воспользоваться недокументированной 
функцией 32h:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthf>AH</TD>
    <TD width02>32h </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>DL</TD>
    <TD width02>Номер устройства НГМД или НМД (0 - текущий, 1 - А:, 2 - В:, 
      и т. д.) </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthf>AL</TD>
    <TD width02>0, если был задан правильный номер устройства;<BR>0FFh, если 
      был задан неправильный номер устройства </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>DS:BX</TD>
    <TD width02>Адрес блока DDCB </TD></TR></TBODY></TABLE>
<P>Для получения адреса блока DDCB текущего диска можно также воспользоваться 
недокументированной функцией 1Fh, которая имеет формат, аналогичный функции 32h, 
за исключением того, что для нее не надо задавать номер устройства в регистре 
DL. </P>
<H3><FONT color=#008000 size=4>Флаг прерывания</FONT> </H3>
<P>С помощью функции 33h программа может проверить или установить флаг 
прерывания при помощи комбинации клавиш &lt;Ctrl+Break&gt; и, кроме того, узнать 
номер диска, с которого выполнялась загрузка операционной системы:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthf>AH</TD>
    <TD width12>33h </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>AL</TD>
    <TD width12>Код операции: <BR>0 - Проверить текущее состояние флага 
      прерывания при помощи комбинации клавиш &lt;Ctrl+Break&gt; ; <BR>1 - 
      Установить флаг прерывания при помощи комбинации клавиш 
      &lt;Ctrl+Break&gt;; <BR>5 - Определить номер диска, который был 
      использован для загрузки операционной системы </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthf>DL</TD>
    <TD width12>Значение флага прерывания при помощи комбинации клавиш 
      &lt;Ctrl+Break&gt; операции с кодом 1:0 - запретить прерывание,1 - 
      разрешить прерывание </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthf>DL</TD>
    <TD width12>Текущее состояние флага прерывания при помощи комбинации 
      клавиш &lt;Ctrl+Break&gt; для операции с кодом 0; Номер диска, 
      использованного для загрузки операционной системы для операции 5 (1 - А:, 
      2 - В:, и т. д.) </TD></TR></TBODY></TABLE>
<P>Сведения о диске, который был использован для загрузки операционной системы, 
могут понадобиться вам, например, для поиска файла командного интерпретатора. 
</P>
<P>Состояние флага прерывания при помощи комбинации клавиш &lt;Ctrl+Break&gt; 
влияет на возможность прервать выполнение программы. Если прерывание запрещено, 
MS-DOS проверяет эту комбинацию клавиш только при вызове функций стандартного 
ввода/вывода на консоль, принтер и последовательный порт. Если же прерывание 
разрешено, указанная комбинация клавиш проверяется и при вызове других функций 
MS-DOS. Если пользователь нажал комбинацию клавиш &lt;Ctrl+Break&gt;, 
операционная система выполняет прерывание INT&nbsp;23h , которое завершает 
работу текущей программы. </P>
<H3><FONT color=#008000 size=4>Адрес области DTA </FONT></H3>
<P>Функция 2Fh возвращает в регистровой паре ES:BX адрес текущей области DTA 
(Disk Transfer Area ), которая используется при поиске файлов в каталогах. Этот 
адрес необходим резидентным программам, о чем мы говорили в предыдущем томе 
"Библиотеки системного программиста". </P>
<H3><FONT color=#008000 size=4>Флаг проверки записи</FONT></H3>
<P>Функция 54h позволяет программе узнать текущее состояние флага проверки 
записи информации на диск. В регистре AL эта функция возвращает текущее 
состояние флага. </P>
<P>Если содержимое регистра равно 1, после записи сектора операционная система 
считывает его для проверки. Разумеется, такая проверка снижает скорость работы 
программы. Если после вызова функции регистр AL содержит 0, проверка записи не 
выполняется. </P>
<P>Для установки флага проверки записи можно использовать функцию 2Eh. Перед 
вызовом функции в регистр AL необходимо занести новое значение флага проверки: 0 
- проверка не нужна; 1 - должна выполняться проверка записанной информации. </P>
<H3><FONT color=#008000 size=4>Функции библиотеки Borland C++</FONT></H3>
<P>Стандартная библиотека Borland C++ содержит несколько функций, облегчающих 
получение справочной информации о состоянии дисковой системы. </P>
<H4><FONT color=#800000>_dos_getdiskfree </FONT></H4>
<P>Функция _dos_getdiskfree использует функцию 36h для получения информации о 
диске. Файл dos.h содержит такое описание этой функции: </P><PRE><FONT color=#000080>unsigned _dos_getdiskfree (unsigned drive,
  struct diskfree_t *diskspace);</FONT>
</PRE>
<P>Параметр drive задает номер используемого устройства: 0 - текущий, 1 - А:, и 
т. д. </P>
<P>Информация возвращается в структуре diskfree_t, которая определена также в 
файле dos.h: </P><PRE><FONT color=#000080>struct diskfree_t
{
	unsigned total_clusters;
	unsigned avail_clusters;
	unsigned sectors_per_cluster;
	unsigned bytes_per_sector;
};</FONT>
</PRE>
<P>Поля этой структуры описаны ниже:<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD width7><STRONG>Поле</STRONG></TD>
    <TD width%8><STRONG>Описание</STRONG></TD></TR>
  <TR>
    <TD width7>unsigned total_clusters</TD>
    <TD width%8>Общее количество кластеров на диске </TD></TR>
  <TR>
    <TD width7>unsigned avail_clusters</TD>
    <TD width%8>Количество свободных кластеров </TD></TR>
  <TR>
    <TD width7>unsigned sectors_per_cluster</TD>
    <TD width%8>Количество секторов, занимаемых одним кластером </TD></TR>
  <TR>
    <TD width7>unsigned bytes_per_sector</TD>
    <TD width%8>Размер сектора в байтах </TD></TR></TBODY></TABLE>
<H4><FONT color=#800000>_dos_getdrive и _dos_setdrive </FONT></H4>
<P>Для получения номера текущего диска и для установки номера текущего диска 
можно использовать, соответственно, функции _dos_getdrive и _dos_setdrive . </P>
<P>Функция _dos_getdrive имеет следующий прототип: </P><PRE><FONT color=#000080>void _dos_getdrive (unsigned *drive);</FONT>
</PRE>
<P>Она пользуется функцией 19h для получения номера текущего диска, который 
записывается по адресу, задаваемому параметром drive. Значение 1 соответствует 
диску А:, 2 - В:, и т. д. </P>
<P>Функция _dos_setdrive предназначена для установки текущего диска и может быть 
использована для определения общего числа дисков в системе: </P><PRE><FONT color=#000080>void _dos_setdrive (unsigned drive, unsigned *drivecount);</FONT>
</PRE>
<P>Параметр drive определяет текущий диск (1 - А:, и т. д.). В переменную, адрес 
которой передается через второй параметр, функция записывает общее количество 
логических дисков, установленных в системе. Функция _dos_setdrive использует 
функцию 0Eh прерывания INT&nbsp;21h . </P>
<H3><FONT color=#008000 size=4>Программа DISKINF2</FONT></H3>
<P>Для иллюстрации способов использования функций _dos_getdrive , _dos_setdrive 
и _dos_getdiskfree мы составили программу DISKINF2 (листинг 4.1). </P>
<HR>

<P><B>Листинг 4.1. Файл diskinf2\diskinf2.cpp</B> </P>
<HR>
<PRE><FONT color=#000080>#include &lt;dos.h&gt;
#include &lt;bios.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;

void main(void)
{
  struct diskfree_t dinfo;
  unsigned drive, drivecount;

  printf("\n"
    "\nОпределение параметров текущего логического диска"
    "\n  (C)Фролов А., 1995\n");

  // Определяем номер текущего диска
  _dos_getdrive (&amp;drive);

  // Выводим на экран обозначение текущего диска
  printf("\nТекущий диск:                        %c:\n",
    'A' + drive - 1);

  // Вызываем функцию установки текущего диска.
  // Мы не изменяем текущий диск, вызов этой функции
  // нужен нам для определения количества установленных
  // в системе логических дисков
  _dos_setdrive (drive, &amp;drivecount);

  // Получаем характеристики текущего диска
  _dos_getdiskfree (drive, &amp;dinfo);

  printf("\nОбщее количество кластеров на диске: %u"
    "\nКоличество свободных кластеров:      %u"
    "\nКоличество секторов в кластере:      %u"
    "\nКоличество байт   в секторе:         %u"
    "\nРазмер свободного пространства в байтах: %ld"
    "\n",
    dinfo.total_clusters, dinfo.avail_clusters,
    dinfo.sectors_per_cluster, dinfo.bytes_per_sector,
    (long)dinfo.avail_clusters * 
    dinfo.sectors_per_cluster *
    dinfo.bytes_per_sector );

    printf("\nКоличество логических дисков:        %d"
      "\n", drivecount);
}</FONT>
</PRE>
<HR>

<H2><A name="b3.2"><FONT color=#0000ff face=Arial size=4> </FONT><FONT 
color=#0000ff size=4>Работа с каталогами</FONT></A> </H2>
<P>После форматирования логический диск содержит корневой каталог. Если диск 
форматируется как системный, в этом каталоге могут находится дескрипторы файлов 
операционной системы io.sys , msdos.sys , command.com . </P>
<P>Операционная система предоставляет программам пользователя удобный сервис для 
создания, уничтожения и переименования каталогов. Используя сведения, 
приведенные в этой книге, вы сможете изменять структуру каталогов сами, не 
прибегая к услугам MS-DOS. Однако это следует делать только тогда, когда 
операции с каталогами по каким-то причинам нежелательно выполнять с 
использованием функций операционной системы. </P>
<H3><FONT color=#008000 size=4>Создание каталога</FONT></H3>
<P>Для создания каталога используйте функцию 39h прерывания INT&nbsp;21h 
:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>39h </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:DX</TD>
    <TD width12>Адрес строки в формате ASCIIZ, содержащей путь создаваемого 
      каталога </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AL</TD>
    <TD width12>Код ошибки, если был установлен флаг переноса CF 
  </TD></TR></TBODY></TABLE>
<P>Строка, адрес которой передается в регистрах DS:DX, может содержать полный 
путь, состоящий из имени диска и имени каталога, в котором должен быть создан 
каталог, или она может состоять только из одного имени каталога. В последнем 
случае каталог создается в текущем каталоге на текущем диске. </P>
<P>Размер строки с именем каталога не должен превышать по длине 64 байта. </P>
<H3><FONT color=#008000 size=4>Удаление каталога</FONT></H3>
<P>Удалить существующий каталог можно с помощью функции 3Ah:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>3Ah </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:DX</TD>
    <TD width12>Адрес строки в формате ASCIIZ, содержащей путь к каталогу 
  </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AL</TD>
    <TD width12>Код ошибки, если был установлен флаг переноса CF 
  </TD></TR></TBODY></TABLE>
<P>Необходимо заметить, что удалить можно только пустой каталог. И это понятно, 
так как если вы в обход операционной системы удалите непустой каталог, то 
описанные в этом каталоге файлы и каталоги будут потеряны, а занимаемое ими 
место невозможно будет распределить другим файлам. </P>
<H3><FONT color=#008000 size=4>Переименование каталога</FONT></H3>
<P>Для изменения имени каталогов и файлов предназначена функция 56h: <BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>56h </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:DX</TD>
    <TD width12>Адрес строки в формате ASCIIZ, содержащей старое имя 
      каталога или файла </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>ES:DI</TD>
    <TD width12>Адрес строки в формате ASCIIZ, содержащей новое имя каталога 
      или файла </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AL</TD>
    <TD width12>Код ошибки, если был установлен флаг переноса CF 
  </TD></TR></TBODY></TABLE>
<P>Файл или каталог, который будет переименован, должен существовать. Если в 
имени не указан диск или каталог, то подразумевается, что файл или каталог 
находится в текущем каталоге на текущем диске. Напротив, каталог или файл с 
новым именем не должен существовать, иначе функция возвратит признак ошибки. 
</P>
<P>Эта функция может перемещать файл из одного каталога в другой, если вы 
укажите разные пути. Каталоги перемещать нельзя, их можно только 
переименовывать. </P>
<H3><FONT color=#008000 size=4>Функции библиотеки Borland C++</FONT></H3>
<P>Стандартная библиотека Borland C++ содержат несколько функций, 
предназначенных для работы с каталогами. </P>
<H4><FONT color=#800000>getcwd </FONT></H4>
<P>Функция getcwd предназначена для определения текущего каталога. Прототип этой 
функции описан в файле direct.h: </P><PRE><FONT color=#000080>char *getcwd (char *path, int n);</FONT>
</PRE>
<P>Первый параметр этой функции - адрес буфера, в который функция запишет 
строку, содержащую имя текущего каталога. Размер этого буфера определяется 
вторым параметром. </P>
<P>Если в качестве первого параметра указать NULL, функция динамически закажет 
буфер длиной n байт из области кучи и вернет его адрес. Эту память впоследствии 
необходимо будет освободить при помощи функции free. </P>
<P>Функция getcwd всегда возвращает указатель на буфер, содержащий текущий 
каталог. </P>
<H4><FONT color=#800000>mkdir , rmdir , chdir </FONT></H4>
<P>Для создания и удаления каталогов, изменения текущего каталога имеются 
функции mkdir , rmdir , chdir . </P>
<P>Все эти функции имеют один параметр - путь каталога, который имеет тип (char 
*). В случае успешного выполнения операции функции возвращают 0, при ошибке - 1. 
</P>
<H4><FONT color=#800000>rename </FONT></H4>
<P>Для переименования каталогов (и файлов) предназначена функция rename : </P><PRE><FONT color=#000080>int rename (char *oldname, char *newname);</FONT>
</PRE>
<P>Способ ее использования очевиден: необходимо задать старое и новое имя 
каталога. Можно задавать как полный путь, так и просто имя каталога либо файла. 
В последнем случае операция переименования выполняется над каталогами или 
файлами, находящимися в текущем каталоге. </P>
<P>Функция может возвращать один из приведенных ниже кодов ошибки: <BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD width4><STRONG>Код ошибки</STRONG></TD>
    <TD width31><STRONG>Описание</STRONG></TD></TR>
  <TR>
    <TD width4>ENOENT</TD>
    <TD width31>Нет такого файла или каталога </TD></TR>
  <TR>
    <TD width4>EACCES</TD>
    <TD width31>Нет прав доступа</TD></TR>
  <TR>
    <TD width4>EXDEV</TD>
    <TD width31>Другой диск</TD></TR></TBODY></TABLE>
<P>Код ошибки EXDEV возвращается в том случае, когда программа указывает разные 
диски для старого и нового имен файлов или каталогов. </P>
<P>Важное замечание: если вы задаете полный путь в программе, составленной на С 
или С++, повторяйте символ '' два раза в строке пути. Это нужно для того, чтобы 
избежать конфликта с форматом представления констант в языке С. Например: </P><PRE><FONT color=#000080>ret_code = rename ("c:\\games","c:\\games_new");</FONT>
</PRE>
<H3><FONT color=#008000 size=4>Программа DIRCTL</FONT></H3>
<P>Приведем исходный текст небольшой программы DIRCTL (листинг 4.2), 
использующий перечисленные выше функции. </P>
<HR>

<P><B>Листинг 4.2. Файл dirctl\dirctl.cpp</B> </P>
<HR>
<PRE><FONT color=#000080>#include &lt;direct.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;

void main(void)
{
  // Константа MAXPATH задает максимальный
  // размер пути для каталога
  char current_dir[MAXPATH];
  char test_dir[] = "TEST_DIR";

  // Запоминаем текущий каталог
  getcwd (current_dir, MAXPATH);

  // Пытаемся создать в текущем каталоге новый каталог
  if(!mkdir (test_dir))
  {
    // Если удалось создать каталог, делаем его текущим
    chdir (test_dir);
    printf("\nКаталог создан, для удаления нажмите"
      "\n клавишу &lt;Enter&gt;, для сохранения - '0'");
    if(getche() != '0')
    {
      // Для удаления только что созданного каталога
      // возвращаемся в каталог более высокого уровня
      chdir (current_dir);
      rmdir (test_dir);
    }
  }

  // Если каталог с таким именем уже существует или
  // произошла другая ошибка при создании каталога,
  // выводим сообщение о невозможности создания каталога.
  else
    printf("\nНе могу создать каталог!");
}</FONT>
</PRE>
<HR>

<H2><A name="b3.3"><FONT color=#0000ff face=Arial size=4> </FONT><FONT 
color=#0000ff size=4>Поиск в каталогах</FONT></A> </H2>
<P>Часто перед программистом стоит задача определения содержимого каталога. При 
описании логической структуры диска мы приводили текст программы, выводящей на 
экран содержимого корневого каталога и других каталогов. Эта программа 
использовала загрузочный сектор логического диска и таблицу размещения файлов . 
Вы можете использовать такой способ, однако если вам не требуется информация о 
номерах начальных кластеров файлов и дескрипторы удаленных файлов, лучше 
применить специальные функции MS-DOS, предназначенные для поиска файлов в 
каталогах. </P>
<P>Это функции 4Eh и 4Fh. </P>
<P>Указанные выше функции используются вместе следующим образом: </P>
<P>Вначале вызывается функция 4Eh для поиска в каталоге файла, соответствующего 
образцу. В образце можно использовать символы "?" и "*", которые означают, 
соответственно, один любой символ и любое количество любых символов. Информация 
о найденном файле располагается в специальной области, распределенной каждой 
работающей программе - области DTA . </P>
<P>Затем для поиска остальных файлов, удовлетворяющих заданному ранее образцу, в 
цикле вызывается функция 4Fh. Условие завершения цикла - отсутствие в каталоге 
указанных файлов. </P>
<P>Функция 4Eh вызывается следующим образом:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>4Eh </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>CX</TD>
    <TD width12>Атрибуты файла, которые будут использованы при поиске. Будут 
      найдены файлы, имеющие атрибут, заданный в регистре CX </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:DX</TD>
    <TD width12>Адрес строки в формате ASCIIZ, содержащей путь каталога или 
      файла </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AL</TD>
    <TD width12>Код ошибки, если был установлен флаг переноса CF 
  </TD></TR></TBODY></TABLE>
<P>Функция 4Fh имеет следующие параметры вызова:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>4Fh </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AL</TD>
    <TD width12>Код ошибки, если был установлен флаг переноса CF 
  </TD></TR></TBODY></TABLE>
<P>Обе функции устанавливают флаг переноса в том случае, когда каталог не 
содержит файлов, удовлетворяющих заданному критерию поиска. </P>
<P>Для работы с областью DTA в составе MS-DOS имеются две функции. Это функция 
2Fh, позволяющая получить адрес области DTA (она возвращает этот адрес в 
регистрах ES:BX), и функция 1Ah, предназначенная для установки своей области DTA 
(адрес новой области DTA должен быть указан в регистрах DS:DX). </P>
<P>Напомним, что по умолчанию область DTA занимает 128 байт в префиксе сегмента 
программы PSP со смещением 80h. </P>
<P>В случае успешного поиска функции 4Eh и 4Fh помещают в DTA информацию о 
найденных файлах в следующем формате:<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD widthѓ><STRONG>Смещение</STRONG></TD>
    <TD widthf><STRONG>Размер</STRONG></TD>
    <TD width02><STRONG>Содержимое </STRONG></TD></TR>
  <TR>
    <TD widthѓ>0</TD>
    <TD widthf>20</TD>
    <TD width02>Зарезервировано </TD></TR>
  <TR>
    <TD widthѓ>21</TD>
    <TD widthf>1</TD>
    <TD width02>Атрибуты найденного файла </TD></TR>
  <TR>
    <TD widthѓ>22</TD>
    <TD widthf>2</TD>
    <TD width02>Поле времени последнего обновления файла </TD></TR>
  <TR>
    <TD widthѓ>24</TD>
    <TD widthf>2</TD>
    <TD width02>Поле даты последнего обновления файла </TD></TR>
  <TR>
    <TD widthѓ>26</TD>
    <TD widthf>4</TD>
    <TD width02>Длина файла </TD></TR>
  <TR>
    <TD widthѓ>30</TD>
    <TD widthf>13</TD>
    <TD width02>Имя файла и расширение в формате ASCIIZ </TD></TR></TBODY></TABLE>
<P>Номер начального кластера, распределенного файлу или каталогу, невозможно 
получить с помощью функций 4Eh и 4Fh. </P>
<P>Стандартная библиотека Borland C++ содержат две функции, предназначенные для 
сканирования каталогов. Это _dos_findfirst и _dos_findnext . </P>
<P>Приведем прототипы этих функций, описанные в файле dos.h: </P><PRE><FONT color=#000080>int _dos_findfirst (char *pattern, struct find_t *found,
  unsigned attr);
int _dos_findnext (struct find_t *found);</FONT>
</PRE>
<P>В этих функциях параметр pattern определяет образец для поиска файлов, 
параметр attr (атрибуты файла) используется в качестве дополнительного критерия 
поиска. Параметр found представляет собой указатель на структуру, в которую 
будет записываться информация о найденных файлах. Эта структура определена в 
файле dos.h: </P><PRE><FONT color=#000080>struct find_t 
{
  char reserved[21]; // зарезервировано для DOS
  char attrib;       // атрибуты файла
  unsigned wr_time;  // время изменения файла
  unsigned wr_date;  // дата изменения файла
  long size;         // размер файла в байтах
  char name[13];     // имя файла и расширение
};</FONT>
</PRE>
<H3><FONT color=#008000 size=4>Программа DIRLIST</FONT></H3>
<P>Приведем текст программы просмотра содержимого каталога DIRLIST (листинг 
4.3). Программа принимает из командной строки параметр - образец для показа 
файлов. Если вы укажете параметр *.*, будет выведена информация обо всех файлах. 
Можно задавать полный путь: c:\*.*. </P>
<HR>

<P><B>Листинг 4.3. Файл dirlist\dirlist.cpp</B> </P>
<HR>
<PRE><FONT color=#000080>#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;
#include &lt;dos.h&gt;

void print_info(struct find_t *find);
char *time_conv(unsigned time, char *char_buf);
char *date_conv(unsigned date, char *char_buf);

#pragma argsused
int main(int argc, char *argv[])
{
  struct find_t find;

  // Находим первый файл, удовлетворяющий критериям поиска.
  // В качестве критерия используем образец, полученный
  // из командной строки. Для поиска используем 
  // файлы с любыми атрибутами
  if(!_dos_findfirst (argv[1], 0xffff, &amp;find))
  {
    printf("\n"
     "\nИмя файла    Аттр. Дата        Время     Размер"
     "\n------------ ----- ----------  --------  ------");

    // Выводим информацию о первом найленном файле на экран
    print_info(&amp;find);
  }
  else
  {
    printf("Задайте образец для поиска файлов !");
    return(-1);
  }

  // Выводим информацию об остальных найденных файлах
  while(!_dos_findnext (&amp;find)) print_info( &amp;find );
  return(0);
}

// Функция для вывода информации о найденных файлах
void print_info(struct find_t *pfind)
{
  char timebuf[10], datebuf[12];

  // Преобразуем формат даты и времени 
  // последнего изменения файла
  date_conv(pfind-&gt;wr_date, datebuf);
  time_conv(pfind-&gt;wr_time, timebuf);

  // Выводим содержимое дескриптора файла
  printf("\n%-12s",pfind-&gt;name);
  printf(" X    %8s  %8s %8ld ",
    pfind-&gt;attrib, datebuf, timebuf, pfind-&gt;size);
}

// Функция преобразования формата времени
char *time_conv(unsigned t, char *buf)
{
  int h, m;

  h = (t &gt;&gt; 11) &amp; 0x1f;
  m = (t &gt;&gt; 5) &amp; 0x3f;
  sprintf(buf, "%2.2d:.2d:.2d",
    h, m, (t &amp; 0x1f) * 2);
  return buf;
}

// Функция преобразования формата даты
char *date_conv(unsigned d, char *buf)
{
  sprintf(buf, "%2.2d..2d..2d",
    d &amp; 0x1f,(d &gt;&gt; 5) &amp; 0x0f, (d &gt;&gt; 9) + 1980);
  return buf;
}</FONT>
</PRE>
<HR>

<H2><A name="b3.4"><FONT color=#0000ff face=Arial size=4> </FONT><FONT 
color=#0000ff size=4>Работа с файлами</FONT></A> </H2>
<P>В этом разделе мы рассмотрим функции MS-DOS, предназначенные для создания, 
открытия, удаления, переименования и перемещения файлов. Операции чтения из 
файла и записи в файл будут описаны в следующем разделе. </P>
<H3><FONT color=#008000 size=4>Создание файлов</FONT></H3>
<P>Для создания файла предназначена функция 3Ch прерывания INT 21h. С помощью 
этой функции может быть создан файл как в текущем, так и в любом другом 
каталоге. Если файл с указанным именем уже существует, он обрезается до нулевой 
длины. Будьте осторожны при использовании этой функции - она может уничтожить 
файл. </P>
<P>Дополнительно функция 3Ch выполняет операцию открытия только что созданного 
файла, возвращая программе идентификатор файла. При создании файла программа 
может указать атрибуты файла. </P>
<P>Приведем параметры вызова функции создания файла:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>3Ch </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>CX</TD>
    <TD width12>Атрибуты создаваемого файла: <BR>00h - обычный файл;<BR>01h 
      - только читаемый файл;<BR>02h - скрытый файл;<BR>04h - системный файл 
  </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:DX</TD>
    <TD width12>Адрес строки, содержащей путь к файлу </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AX</TD>
    <TD width12>Код ошибки, если был установлен флаг переноса CF; 
      <BR>Идентификатор файла, если флаг переноса CF сброшен 
</TD></TR></TBODY></TABLE>
<P>При выполнении этой функции возможно возникновение следующих ошибок: 
<UL>
  <LI><I>отсутствует какой-либо элемент в пути для создаваемого файла, например, 
  диск или каталог;</I> 
  <LI><I>была сделана попытка создать файл в корневом каталоге, но корневой 
  каталог переполнен;</I> 
  <LI><I>в указанном каталоге уже есть файл с таким именем, и этот файл имеет 
  атрибут "Только читаемый";</I> 
  <LI><I>пользователь, который работает в сети, не имеет прав доступа для 
  выполнения указанной операции.</I> </LI></UL>
<P>Операционная система игнорирует попытки создания с помощью этой функции 
каталога или метки диска. </P>
<P>Для того чтобы при создании файла случайно не уничтожить содержимое уже 
существующего файла с таким же именем, программа может использовать функцию 5Bh. 
Эта функция проверяет заданный путь на предмет наличия указанного файла. Если 
такой файл уже существует, функция возвращает программе признак ошибки:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>5Bh </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>CX</TD>
    <TD width12>Атрибуты создаваемого файла: <BR>00h - обычный файл;<BR>01h 
      - только читаемый файл;<BR>02h - скрытый файл;<BR>04h - системный файл 
  </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:DX</TD>
    <TD width12>Адрес строки, содержащей путь к файлу </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AX</TD>
    <TD width12>Код ошибки, если был установлен флаг переноса CF; 
      <BR>Идентификатор файла, если флаг переноса CF сброшен 
</TD></TR></TBODY></TABLE>
<P>Если вам требуется временный файл, вы можете создать его с помощью функции 
5Ah:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>5Ah </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>CX</TD>
    <TD width12>Атрибуты создаваемого файла: <BR>00h - обычный файл;<BR>01h 
      - только читаемый файл;<BR>02h - скрытый файл;<BR>04h - системный файл 
  </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:DX</TD>
    <TD width12>Адрес блока памяти, в который функция запишет путь 
      созданного временного файла. Размер этого блока памяти должен быть по 
      крайней мере 13 байт </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AX</TD>
    <TD width12>Код ошибки, если был установлен флаг переноса 
      CF;<BR>Идентификатор файла, если флаг переноса CF сброшен 
</TD></TR></TBODY></TABLE>
<P>Операционная система не будет автоматически удалять созданный временный файл 
после завершения работы программы или перезагрузки. Программа должна сама 
удалить этот файл. </P>
<H3><FONT color=#008000 size=4>Открытие файла</FONT></H3>
<P>Перед тем, как начать работу с файлом, его нужно открыть. Функции, создающие 
новые файлы, открывают их автоматически. Для того, чтобы открыть существующий 
файл, вы можете воспользоваться функцией 3Dh:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>3Dh </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>AL</TD>
    <TD width12>Требуемый режим доступа: <BR><BR>Бит 7: флаг наследования 
      <BR><BR>0 - идентификатор файла наследуется порожденным процессом <BR>1 - 
      идентификатор файла не наследуется порожденным процессом<BR><BR>Биты 
      4...6: режим разделения <BR><BR>000 - режим совместимости <BR>001 - 
      запрещение всех видов доступа <BR>010 - запрещение записи <BR>011 - 
      запрещение чтения <BR>100 - разрешение всех видов доступа <BR><BR>Бит 3:0 
      - зарезервировано <BR><BR>Биты 0...2: вид доступа <BR><BR>000 - чтение 
      <BR>001 - запись <BR>010 - чтение и запись </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:DX</TD>
    <TD width12>Адрес строки, содержащей путь к файлу </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AX</TD>
    <TD width12>Код ошибки, если установлен флаг переноса CF; 
      <BR>Идентификатор файла, если флаг переноса CF сброшен 
</TD></TR></TBODY></TABLE>
<P>С помощью функции 3Dh можно открыть любой файл (но не каталог). Если 
требуется вид доступа "запись", открываемый файл не должен иметь атрибут "Только 
читаемый". </P>
<P>Для использования битов 4...7 (управляющих доступом к файлу другими 
программами в сети) должна быть запущена программа share.exe . </P>
<P>Если используется бит наследования, то порожденному процессу наследуются вид 
доступа, запрошенный при открытии файла. </P>
<P>Функция 6Ch обладает расширенными возможностями по созданию и открытию 
файлов:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>6Ch </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>AL</TD>
    <TD width12>00h</TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>BX</TD>
    <TD width12>Байт флагов расширенного режима открытия файла </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>CX</TD>
    <TD width12>Атрибуты создаваемого файла, используется только при 
      создании файлов </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DX</TD>
    <TD width12>Выполняемая функция, если файл существует или не существует: 
      <BR><BR>Биты 0-3 регистра DX задают действие, если файл 
      существует:<BR><BR>0000h - если файл существует, вернуть признак 
      ошибки;<BR>0001h - если файл существует, открыть его; <BR>0002h - если 
      файл существует, заместить и открыть его.<BR><BR>Биты 4-7 регистра DX 
      задают действие, если файл не существует: <BR><BR>0000h - если файл не 
      существует, вернуть признак ошибки;<BR>0001h - если файл не существует, 
      создать и открыть его </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:SI</TD>
    <TD width12>Адрес строки, содержащей путь к файлу </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AX</TD>
    <TD width12>Код ошибки, если флаг переноса CF 
      установлен;<BR>Идентификатор файла, если флаг переноса CF сброшен </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>CX</TD>
    <TD width12>Код выполненных действий:<BR>0 - файл был открыт; <BR>1 - 
      файл был создан и открыт; <BR>2 - файл был замещен и открыт 
</TD></TR></TBODY></TABLE>
<P>Регистр BX на входе задает флаги расширенного режима открытия файла в 
следующем формате:<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD width‘>Биты</TD>
    <TD width60>Назначение</TD></TR>
  <TR>
    <TD width‘>0...2</TD>
    <TD width60>Режим доступа при чтении или записи </TD></TR>
  <TR>
    <TD width‘>3</TD>
    <TD width60>Зарезервировано, должно быть равно 0 </TD></TR>
  <TR>
    <TD width‘>4...6</TD>
    <TD width60>Режим разделения</TD></TR>
  <TR>
    <TD width‘>7</TD>
    <TD width60>Флаг наследования</TD></TR>
  <TR>
    <TD width‘>8...12</TD>
    <TD width60>Зарезервировано, должно быть равно 0 </TD></TR>
  <TR>
    <TD width‘>13</TD>
    <TD width60>0 - Режим обычного использования обработчика критических 
      ошибок INT&nbsp;24h (обработчик критических ошибок будет описан 
      позже)<BR>1 - Блокировка обработчика критических ошибок INT&nbsp;24h. Для 
      того, чтобы узнать причину ошибки, программа должна использовать функцию 
      59h прерывания INT&nbsp;21h </TD></TR>
  <TR>
    <TD width‘>14</TD>
    <TD width60>Управление буферизацией: <BR>0 - Использование стандартной 
      для MS-DOS буферизации;<BR>1 - Отмена буферизации. Использование этого 
      режима замедлит работу с диском, однако вероятность потери информации при 
      аварии в питающей сети уменьшится </TD></TR></TBODY></TABLE>
<P>Описанная выше функция является как бы комбинацией функций 3Dh и 3Ch 
(открытие и создание файла). Она удобна, но при ее использовании программа 
должна убедиться в том, что версия MS-DOS не ниже, чем 4.0. </P>
<H3><FONT color=#008000 size=4>Удаление файла</FONT></H3>
<P>Удалить файл можно при помощи функции 41h прерывания INT&nbsp;21h :<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>41h </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:DX</TD>
    <TD width12>Адрес строки в формате ASCIIZ, содержащей путь удаляемого 
      файла </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AL</TD>
    <TD width12>Код ошибки, если установлен флаг переноса CF 
</TD></TR></TBODY></TABLE>
<P>С помощью этой функции нельзя удалить файл, имеющий атрибут "Только 
читаемый". </P>
<P>Под удалением файла понимается вычеркивание файла из каталога и освобождение 
всех принадлежавших ранее этому файлу кластеров. Эти кластеры отмечаются в 
таблице размещения файлов как свободные. При стирании файлов не происходит 
уничтожение информации, записанной на диске, поэтому в некоторых случаях можно 
полностью восстановить случайно удаленные файлы. </P>
<H3><FONT color=#008000 size=4>Переименование или перемещение файла</FONT></H3>
<P>Программа может изменить имя файла или переместить его в другой каталог того 
же самого диска, воспользовавшись функцией 56h прерывания INT&nbsp;21h :<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>56h </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:DX</TD>
    <TD width12>Адрес строки в формате ASCIIZ, содержащей старое имя </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>ES:DI</TD>
    <TD width12>Адрес строки в формате ASCIIZ, содержащей новое имя или 
      новый путь к файлу </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AL</TD>
    <TD width12>Код ошибки, если установлен флаг переноса CF 
</TD></TR></TBODY></TABLE>
<P>С помощью этой функции можно переименовать (но не переместить) не только 
файл, но и каталог. </P>
<H3><FONT color=#008000 size=4>Функции библиотеки Borland C++</FONT></H3>
<P>Стандартная библиотека Borland C++ содержит функции для работы с файлами. Эти 
функции можно разделить на две группы - функции низкого уровня и функции 
ввода/вывода потоком. Вторая группа функций использует буферизацию и будет 
рассмотрена в разделе, посвященном буферизованному вводу/выводу. </P>
<P>Функции низкого уровня отображаются на описанные выше функции прерывания 
INT&nbsp;21h (а также на функции этого же прерывания, предназначенные для чтения 
или записи, позиционирования и т. д.). </P>
<H4><FONT color=#800000>creat </FONT></H4>
<P>Для создания файла можно использовать функцию creat : </P><PRE><FONT color=#000080>int creat (char *filename, int mode);</FONT>
</PRE>
<P>Эта функция и ее параметры описаны в файлах io.h, sys\types.h, sys\stat.h, 
errno.h. </P>
<P>Первый параметр определяет путь создаваемого файла и его имя. Если файл с 
указанным именем существует, и не имеет атрибут "Только читаемый", функция 
сбрасывает длину файла до нуля. Содержимое файла при этом уничтожается. </P>
<P>Второй параметр позволяет задать атрибуты создаваемого файла. Он может иметь 
следующие значения:<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD width8><STRONG>Параметр</STRONG></TD>
    <TD width(3><STRONG>Операции, разрешенные для создаваемого файла 
      </STRONG></TD></TR>
  <TR>
    <TD width8>S_IWRITE</TD>
    <TD width(3>Запись</TD></TR>
  <TR>
    <TD width8>S_IREAD</TD>
    <TD width(3>Чтение</TD></TR>
  <TR>
    <TD width8>S_IREAD | S_IWRITE</TD>
    <TD width(3>Чтение и запись </TD></TR></TBODY></TABLE>
<P>В операционной системе MS-DOS невозможно создать файл, в который можно было 
бы писать, но из которого было бы нельзя читать информацию. Поэтому если указать 
второй параметр как S_IWRITE, будет создан такой файл, для которого разрешены 
как операция записи, так и операция чтения. </P>
<P>После создания файла функция creat открывает новый файл, возвращая 
идентификатор файла или код ошибки. </P>
<H4><FONT color=#800000>open </FONT></H4>
<P>Мощная функция open предназначена как для открытия существующих файлов, так и 
для создания новых: </P><PRE><FONT color=#000080>int open (char *filename, int oflag [, int pmode]);</FONT>
</PRE>
<P>Первый и третий параметры этой функции аналогичны параметрам функции creat , 
причем третий параметр нужен только при создании нового файла. Квадратные скобки 
указывают на то, что этот параметр можно не указывать. </P>
<P>Параметр oflag может являться результатом логической операции ИЛИ над 
следующими константами, определенными в файле fcntl.h: <BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD width4><STRONG>Константа</STRONG></TD>
    <TD width21><STRONG>Описание</STRONG></TD></TR>
  <TR>
    <TD width4>O_APPEND </TD>
    <TD width21>При записи в файл информация будет добавляться в конец файла 
    </TD></TR>
  <TR>
    <TD width4>O_BINARY </TD>
    <TD width21>Файл открывается для работы в двоичном режиме (игнорируются 
      управляющие символы, такие как конец строки) </TD></TR>
  <TR>
    <TD width4>O_CREAT </TD>
    <TD width21>Создается новый файл и открывается для записи. Эта константа 
      игнорируется, если указанный в первом параметре файл уже существует </TD></TR>
  <TR>
    <TD width4>O_EXCL </TD>
    <TD width21>Используется вместе с O_CREAT . Если указанный в первом 
      параметре файл существует, функция возвратит признак ошибки </TD></TR>
  <TR>
    <TD width4>O_RDONLY </TD>
    <TD width21>Файл открывается только для чтения, попытка записи в файл 
      приведет к тому, что функция записи вернет признак ошибки </TD></TR>
  <TR>
    <TD width4>O_RDWR </TD>
    <TD width21>Файл открывается как для чтения, так и для записи </TD></TR>
  <TR>
    <TD width4>O_TEXT </TD>
    <TD width21>Файл открывается в текстовом режиме </TD></TR>
  <TR>
    <TD width4>O_TRUNC </TD>
    <TD width21>Существующий файл открывается и обрезается до нулевой длины 
      (если для этого файла разрешена операция записи) </TD></TR>
  <TR>
    <TD width4>O_WRONLY </TD>
    <TD width21>Файл открывается только для записи (в MS-DOS для файла, 
      открытого с признаком O_WRONLY , разрешено выполнение операции чтения) 
  </TD></TR></TBODY></TABLE>
<H4><FONT color=#800000>close </FONT></H4>
<P>Для того, чтобы закрыть файл, открытый функциями creat или open , нужно 
использовать функцию close : </P><PRE><FONT color=#000080>int close (int handle);</FONT>
</PRE>
<P>В качестве параметра функции передается идентификатор файла, полученный при 
открытии или создании файла. Функция возвращает 0 при успешном закрытии файла 
или -1 при ошибке. </P>
<H4><FONT color=#800000>Коды ошибок</FONT></H4>
<P>Код ошибки для этой и других функций стандартной библиотеки Borland C++ 
записывается в глобальную переменную errno. </P>
<H2><A name="b3.5"><FONT color=#0000ff face=Arial size=4> </FONT><FONT 
color=#0000ff size=4>Чтение и запись файлов</FONT></A> </H2>
<P>После того как вы открыли файл, можно выполнять над ним операции чтения или 
записи. При этом соответствующим функциям необходимо передать идентификатор 
файла. После завершения операций чтения или записи файл следует закрыть. </P>
<H3><FONT color=#008000 size=4>Запись данных в файл</FONT></H3>
<P>Для записи данных в файл предназначена функция 40h прерывания INT&nbsp;21h . 
В качестве параметров для этой функции необходимо указать идентификатор файла, 
полученный при открытии существующего файла или создании нового, адрес блока 
памяти, содержащего данные для записи и размер этого блока памяти:<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>40h </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>BX</TD>
    <TD width12>Идентификатор открытого файла </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>CX</TD>
    <TD width12>Количество записываемых байт </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:DX</TD>
    <TD width12>Адрес блока памяти, содержащего записываемые данные </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AX</TD>
    <TD width12>Код ошибки, если был установлен флаг переноса CF; 
      <BR>Количество действительно записанных байт, если флаг переноса CF 
      сброшен </TD></TR></TBODY></TABLE>
<P>При записи данные попадают в то место внутри файла, которое определяется 
содержимым так называемого файлового указателя позиции. При создании нового 
файла этот указатель сбрасывается в 0, что соответствует началу файла. При 
открытии файла с помощью функции 3Dh указатель также устанавливается на начало 
файла. Операция записи в файл с помощью функции 40h продвигает указатель вперед 
к концу файла на количество записанных байт. </P>
<P>По мере увеличения размера файла ему будут распределяться все новые и новые 
кластеры из числа отмеченных как свободные. </P>
<P>Если вам необходимо перезаписать содержимое файла, а не дописывать данные в 
конец, необходимо воспользоваться функцией позиционирования. Эта функция будет 
описана в следующем разделе. Она позволяет управлять содержимым файлового 
указателя позиции. </P>
<P>Следует учитывать, что количество действительно записанных байт может не 
совпадать с заданным в регистре CX при вызове функции 40h. Такая ситуация 
возможна, например, при записи в файл, открытый в текстовом режиме, байта 1Ah. 
Этот байт означает конец текстового файла. Другая возможная причина - отсутствие 
свободного места на диске. </P>
<P>Если функция вызывается с содержимым регистра CX, равным 0, файл будет 
обрезан или расширен до текущего положения файлового указателя. </P>
<P>Разумеется, если программа, выполняющая запись в файл, работает в сети, она 
должна иметь соответствующие права доступа к каталогу и файлу. </P>
<P>Функция 40h может выполнять запись не только в файл, но и в символьное 
устройство, предварительно открытое функцией 3Dh. Об этом мы говорили в разделах 
книги, посвященных драйверам. </P>
<H3><FONT color=#008000 size=4>Чтение данных из файла</FONT></H3>
<P>Для чтения данных из файла (или символьного устройства) предназначена функция 
3Fh прерывания INT&nbsp;21h :<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>3Fh </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>BX</TD>
    <TD width12>Идентификатор открытого файла </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>CX</TD>
    <TD width12>Количество читаемых байт </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:DX</TD>
    <TD width12>Адрес блока памяти, в который будут записаны прочитанные 
      данные </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AX</TD>
    <TD width12>Код ошибки, если установлен флаг переноса CF; <BR>Количество 
      действительно прочитанных байт, если флаг переноса CF сброшен 
  </TD></TR></TBODY></TABLE>
<P>Эта функция используется аналогично функции записи. Для нее верны все 
замечания, касающиеся файлового указателя позиции, количества действительно 
прочитанных байт и прав доступа. </P>
<H3><FONT color=#008000 size=4>Функции библиотеки Borland C++</FONT></H3>
<P>Если ваша программа составлена на языке программирования С или C++, для 
записи и чтения данных она может воспользоваться функциями write и read : </P><PRE><FONT color=#000080>int write (int handle, void *buffer, unsigned count);
int read (int handle, void *buffer, unsigned count);</FONT>
</PRE>
<P>Эти функции работают аналогично функциям 40h и 3Fh прерывания INT&nbsp;21h . 
Параметр handle определяет файл, для которого необходимо выполнить операцию 
записи или чтения. Параметр buffer - указатель на блок памяти, который содержит 
данные для записи или в который необходимо поместить прочитанные данные. 
Количество записываемых или читаемых байт определяется третьим параметром - 
count. </P>
<P>После выполнения операции функция возвращает количество действительно 
записанных или прочитанных байт или -1 при ошибке. </P>
<P>Будьте внимательны, если вы записываете или читаете больше 32 Кбайт - вы 
можете получить признак ошибки, хотя передача данных выполнилась правильно. 
Большие массивы данных можно записывать по частям. </P>
<H3><FONT color=#008000 size=4>Программа FCOPY</FONT></H3>
<P>В качестве примера мы приведем программу копирования файлов FCOPY (листинг 
4.4), которая пользуется описанными выше функциями. </P>
<HR>

<P><B>Листинг 4.4. Файл fcopy\fcopy.cpp</B> </P>
<HR>
<PRE><FONT color=#000080>#include &lt;io.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;sys\types.h&gt;
#include &lt;sys\stat.h&gt;
#include &lt;malloc.h&gt;
#include &lt;errno.h&gt;

int main(int argc, char *argv[])
{
  int source, taget, i;
  char *buffer;
  int count;

  if(argc == 3)
  {
    // Открываем исходный файл
    if((source = open (argv[1],
      O_BINARY  | O_RDONLY )) == - 1)
    {
      printf("\nОшибка: %d", errno);
      return(-1);
    }

    // Открываем выходной файл. При необходимости
    // создаем новый. Если файл уже существует,
    // выводим на экран запрос на перезапись
    // содержимого существующего файла
    taget = open (argv[2],
      O_BINARY  | O_WRONLY  | O_CREAT  | O_EXCL ,
      S_IREAD | S_IWRITE);

    if(errno == EEXIST)
    {
      printf("\nФайл существует. "
        "Перезаписать? (Y,N)\n");

      // Ожидаем ответ и анализируем его
      i = getch();
      if((i == 'y') || (i == 'Y'))
        taget = open (argv[2],
          O_BINARY  | O_WRONLY  | O_CREAT  | O_TRUNC ,
	  S_IREAD | S_IWRITE);
    }

    // Если выходной файл открыть невозможно,
    // выводим сообщение об ошибке
    // и завершаем работу программы
    if(taget == -1)
    {
      printf("\nОшибка: %d", errno);
      return(-1);
    }

    // Будем читать и писать за один раз 10000 байт
    count = 10000;

    // Заказываем буфер для передачи данных
    if((buffer = (char *)malloc(count)) == NULL)
    {
      printf("\nМало памяти");
      return(-1);
    }

    // Копируем исходный файл
    while(!eof(source))
    {
      // Читаем count байт в буфер buffer
      if((count = read (source, buffer, count)) == -1)
      {
        printf("\nОшибка при чтении: %d", errno);
        return(-1);
      }

      // Выполняем запись count байт
      // из буфера в выходной файл
      if((count = write (taget, buffer, count)) == - 1)
      {
        printf("\nОшибка при записи: %d", errno);
	return(-1);
      }
    }

    // Закрываем входной и выходной файлы
    close (source);
    close (taget);

    // Освобождаем память, заказанную под буфер
    free(buffer);
  }

  // Если при запуске программы не были указаны
  // пути для входного или выходного файла,
  // выводим сообщение об ошибке
  else
    printf("\nЗадайте пути для файлов!\n");
  return 0;
}</FONT>
</PRE>
<HR>

<P>Для определения момента достижения конца исходного файла в программе 
использована функция eof: </P><PRE><FONT color=#000080>int eof(int handle);</FONT>
</PRE>
<P>Для файла с идентификатором handle эта функция возвращает одно из трех 
значений:<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD width’><STRONG>Значение</STRONG></TD>
    <TD width59><STRONG>Описание</STRONG></TD></TR>
  <TR>
    <TD width’>1</TD>
    <TD width59>Достигнут конец файла</TD></TR>
  <TR>
    <TD width’>0</TD>
    <TD width59>Конец файла не достигнут </TD></TR>
  <TR>
    <TD width’>-1</TD>
    <TD width59>Ошибка, например, неправильно указан идентификатор файла 
  </TD></TR></TBODY></TABLE>
<P>Программа, которая читает файл с помощью функции 3Fh прерывания INT&nbsp;21h 
, может определить момент достижения конца файла анализируя код ошибки, 
передаваемый в регистре AX. </P>
<H2><A name="b3.6"><FONT color=#0000ff face=Arial size=4> </FONT><FONT 
color=#0000ff size=4>Позиционирование</FONT></A> </H2>
<P>Управляя содержимым файлового указателя позиции программа может произвольно 
считывать или перезаписывать различные участки файла, то есть организовать 
прямой доступ к содержимому файла. Прямой доступ к файлу может вам пригодиться, 
например, для создания системы управления базами данных. </P>
<H3><FONT color=#008000 size=4>Установка файлового указателя</FONT></H3>
<P>Установить файловый указатель в нужную вам позицию можно с помощью функции 
42h прерывания INT&nbsp;21h :<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>42h </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>AL</TD>
    <TD width12>Метод кодирования смещения: <BR>00h - абсолютное смещение от 
      начала файла;01h - смещение от текущей позиции;02h - смещение от конца 
      файла </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>BX</TD>
    <TD width12>Идентификатор открытого файла </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>CX</TD>
    <TD width12>Старший байт смещения </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DX</TD>
    <TD width12>Младший байт смещения </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AX</TD>
    <TD width12>Код ошибки, если установлен флаг переноса CF;Младший байт 
      текущей позиции, если флаг переноса CF сброшен </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DX</TD>
    <TD width12>Старший байт текущей позиции </TD></TR></TBODY></TABLE>
<P>Функция 42h позволяет указывать новое значение указателя либо как абсолютное 
смещение от начала файла, либо как смещение от текущей позиции, либо как 
смещение от конца файла. В последних двух случаях используется смещение со 
знаком. Для указания смещения или абсолютной позиции программа должна задать в 
регистрах CX, DX соответствующее 32-битное значение. </P>
<P>Что произойдет, если при использовании методов кодирования 01h или 02h 
попытаться установить указатель позиции до начала файла? </P>
<P>Функция 42h при этом не возвратит признак ошибки, однако если будет сделана 
попытка прочитать или записать данные, то соответствующая функция чтения/записи 
завершится с ошибкой. </P>
<H3><FONT color=#008000 size=4>Определение размера файла</FONT></H3>
<P>Если использовать метод кодирования 02h и при этом задать нулевое смещение, 
функция установит указатель на конец файла. Это обстоятельство может быть 
использовано для определения размера файла в байтах. </P>
<H3><FONT color=#008000 size=4>Функции библиотеки Borland C++</FONT></H3>
<P>Стандартная библиотека Borland C++ содержит функции, предназначенные для 
управления файловым указателем позиции и получения текущего значения этого 
указателя. Это функции lseek , tell , filelength . </P>
<H4><FONT color=#800000>lseek </FONT></H4>
<P>Функция lseek работает аналогично только что описанной функции 42h. Приведем 
ее прототип: </P><PRE><FONT color=#000080>long lseek (int handle, long offset, int origin);</FONT>
</PRE>
<P>Первый параметр определяет файл, для которого выполняется операция 
позиционирования. Параметр offset определяет смещение. Последний параметр задает 
метод кодирования смещения. Он может принимать следующие значения, описанные в 
фале stdio.h:<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD width7><STRONG>Значение</STRONG></TD>
    <TD width38><STRONG>Описание</STRONG></TD></TR>
  <TR>
    <TD width7>SEEK_SET </TD>
    <TD width38>Абсолютное смещение от начала файла </TD></TR>
  <TR>
    <TD width7>SEEK_CUR </TD>
    <TD width38>Смещение относительно текущей позиции </TD></TR>
  <TR>
    <TD width7>SEEK_END </TD>
    <TD width38>Смещение относительно конца файла </TD></TR></TBODY></TABLE>
<P>Функция возвращает величину текущего смещения в байтах относительно начала 
файла или -1 в случае ошибки. Как и для остальных функций библиотеки, код ошибки 
находится в глобальной переменной errno. </P>
<H4><FONT color=#800000>filelength </FONT></H4>
<P>Вы, конечно, можете использовать функцию lseek для определения размера файла 
или текущей файловой позиции. Однако для того чтобы узнать размер файла, лучше 
воспользоваться специальной функцией filelength : </P><PRE><FONT color=#000080>long filelength (int handle);</FONT>
</PRE>
<P>Эта функция возвращает размер файла в байтах. Файл задается параметром 
handle. В случае ошибки функция возвращает значение -1. </P>
<H4><FONT color=#800000>tell </FONT></H4>
<P>Для того, чтобы определить текущую файловую позицию, можно использовать 
функцию tell : </P><PRE><FONT color=#000080>long tell (int handle);</FONT>
</PRE>
<P>Эта функция возвращает текущую позицию для файла, определенного параметром 
handle, или -1 в случае ошибки. </P>
<H3><FONT color=#008000 size=4>Программа SETPOS</FONT></H3>
<P>Для демонстрации использования функций позиционирования приведем простую 
программу SETPOS (листинг 4.5), которая для заданного файла и позиции внутри 
файла отображает содержимое одного байта. Дополнительно программа определяет 
размер файла и текущую позицию после чтения байта. </P>
<HR>

<P><B>Листинг 4.5. Файл setpos\setpos.cpp</B> </P>
<HR>
<PRE><FONT color=#000080>#include &lt;io.h&gt;
#include &lt;stdio.h&gt;
#include &lt;fcntl.h&gt;

int main(void)
{
  int handle;
  long position, length;
  char buffer[2], fname[80];

  // Запрашиваем имя файла, с которым будем работать
  printf("Введите имя файла: ");
  gets(fname);

  // Открываем файл
  handle = open (fname, O_BINARY  | O_RDONLY );

  // Если такого файла нет, выводим сообщение об ошибке
  // и завершаем работу программы
  if(handle == -1)
  {
    printf("\nНет такого файла!");
    return(-1);
  }

  // Определяем и выводим на экран
  // размер файла в байтах
  length = filelength (handle);

  printf("\nДлина файла %s составляет %ld байт\n",
    fname, length);

  // Запрашиваем позицию для чтения и отображения байта
  do
  {
    printf("Введите позицию: ");
    scanf ("%ld", &amp;position);
  } while(position &gt; length);

  // Устанавливаем заданную позицию
  lseek (handle, position, SEEK_SET );

  // Читаем один байт в буфер, начиная с установленной
  // позиции
  if(read (handle, buffer, 1) == -1)
  {
    // Для вывода сообщения об ошибке используем
    // функцию perror(), которая добавляет к сообщению,
    // заданному в параметре, расшифрованное
    // системное сообщение об ошибке.
    // Код ошибки функция perror() берет
    // из переменной errno
    perror("Ошибка при чтении");
    return(-1);
  }

  // Выводим считанный байт на экран
  printf( "Смещение: %ld; байт: .2x ('%c')\n",
    position, (unsigned char)*buffer, *buffer);

  // Определяем текущую позицию и выводим ее
  // на экран
  position = tell (handle);
  printf("\nТекущая позиция в файле: %ld\n", position);

  // Закрываем файл
  close (handle);
  return 0;
}</FONT>
</PRE>
<HR>

<H2><A name="b3.7"><FONT color=#0000ff face=Arial size=4> </FONT><FONT 
color=#0000ff size=4>Изменение дескриптора файла</FONT></A> </H2>
<P>Напомним: атрибуты файла, время и дата его последней модификации, а также 
размер файла хранятся в дескрипторе файла. Дескриптор файла находится в 
каталоге. </P>
<P>Операционная система предоставляет вам все необходимые средства для изменения 
всех полей дескриптора файла, кроме номера начального кластера. Для изменения 
этого номера вам придется работать с каталогом через таблицу размещения файлов 
FAT . Для этого нужно сначала считать каталог по кластерам с помощью прерывания 
INT&nbsp;25h , модифицировать нужные поля и записать каталог обратно на диск при 
помощи прерывания INT&nbsp;26h . </P>
<H3><FONT color=#008000 size=4>Атрибуты файла </FONT></H3>
<P>Для работы с полем атрибутов файла предназначена функция 43h прерывания 
INT&nbsp;21h :<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>43h </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>AL</TD>
    <TD width12>Выполняемая операция: 00h - чтение атрибутов файла;01h - 
      установка новых атрибутов файла </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>CX</TD>
    <TD width12>Новые атрибуты файла, если AL = 01h:Биты регистра CX:5 - бит 
      архивации; 4 - каталог;3 - метка диска;2 - системный файл; 1 - скрытый 
      файл; 0 - только читаемый файл </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DS:DX</TD>
    <TD width12>Путь к файлу в формате строки ASCIIZ </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AX</TD>
    <TD width12>Код ошибки, если установлен флаг переноса CF </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>CX</TD>
    <TD width12>Если не было ошибки, этот регистр содержит атрибуты файла 
  </TD></TR></TBODY></TABLE>
<P>При изменении атрибутов файла допустимо указывать комбинации битов в регистре 
CX. </P>
<P>Если ваша программа работает в сети, она должна иметь соответствующие права 
доступа к каталогу, содержащему файл, для которого программа собирается изменять 
байт атрибутов. </P>
<H3><FONT color=#008000 size=4>Время и дата изменения файла</FONT></H3>
<P>Для работы с полями времени и даты последней модификации файла предназначена 
функция 57h прерывания INT&nbsp;21h :<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>57h </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>AL</TD>
    <TD width12>Выполняемая операция: <BR>00h - чтение даты и времени;01h - 
      установка даты и времени </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>BX</TD>
    <TD width12>Идентификатор открытого файла </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>CX</TD>
    <TD width12>Время </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DX</TD>
    <TD width12>Дата</TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AX</TD>
    <TD width12>Код ошибки, если установлен флаг переноса CF </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>CX</TD>
    <TD width12>Если не было ошибки, этот регистр содержит время последнего 
      изменения файла </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>DX</TD>
    <TD width12>Если не было ошибки, этот регистр содержит дату последнего 
      изменения файла </TD></TR></TBODY></TABLE>
<P>Для того чтобы изменить время или дату последней модификации файла с помощью 
этой функции, файл предварительно должен быть открыт. Формат времени и даты для 
этой функции такой же, как и используемый в дескрипторе каталога (рис. 2.4 и 
2.5). </P>
<H3><FONT color=#008000 size=4>Функции библиотеки Borland C++</FONT></H3>
<P>Стандартная библиотека Borland C++ содержит функции для чтения и изменения 
атрибутов файлов, а также времени и даты их последней модификации. </P>
<H4><FONT color=#800000>_dos_getfileattr </FONT></H4>
<P>Для определения атрибутов файла можно использовать функцию _dos_getfileattr : 
</P><PRE><FONT color=#000080>unsigned _dos_getfileattr (char *path, unsigned *attrib);</FONT>
</PRE>
<P>Эта функция получает атрибуты файла, заданного первым аргументом, и 
записывает байт атрибутов в младший байт по адресу, указанному вторым 
параметром. </P>
<P>В случае успешного завершения функция возвращает 0. При ошибке она возвращает 
код ошибки, полученный от операционной системы и устанавливает глобальную 
переменную errno в значение ENOENT, что означает отсутствие файла, указанного в 
параметре path. </P>
<H4><FONT color=#800000>_dos_setfileattr </FONT></H4>
<P>Для изменения атрибутов файла можно использовать функцию _dos_setfileattr : 
</P><PRE><FONT color=#000080>unsigned _dos_setfileattr (char *path, unsigned attrib);</FONT>
</PRE>
<P>Параметр attrib может принимать следующие значения:<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD width8><STRONG>Значение</STRONG></TD>
    <TD width17><STRONG>Описание</STRONG></TD></TR>
  <TR>
    <TD width8>_A_ARCH</TD>
    <TD width17>Установка бита архивации </TD></TR>
  <TR>
    <TD width8>_A_HIDDEN</TD>
    <TD width17>Скрытый файл</TD></TR>
  <TR>
    <TD width8>_A_NORMAL</TD>
    <TD width17>Обычный файл</TD></TR>
  <TR>
    <TD width8>_A_RDONLY</TD>
    <TD width17>Только читаемый файл </TD></TR>
  <TR>
    <TD width8>_A_SUBDIR</TD>
    <TD width17>Каталог</TD></TR>
  <TR>
    <TD width8>_A_SYSTEM</TD>
    <TD width17>Системный файл</TD></TR>
  <TR>
    <TD width8>_A_VOLID</TD>
    <TD width17>Метка диска</TD></TR></TBODY></TABLE>
<H4><FONT color=#800000>_dos_getftime </FONT></H4>
<P>Для определения времени последней модификации файла можно использовать 
функцию _dos_getftime : </P><PRE><FONT color=#000080>unsigned _dos_getftime (int handle, unsigned *date, 
  unsigned *time);</FONT>
</PRE>
<P>Перед использованием этой функции программа должна открыть файл. Дата и время 
записываются по адресу, указываемому, соответственно, вторым и третьим 
параметрами. </P>
<H4><FONT color=#800000>_dos_setftime </FONT></H4>
<P>Если вам надо изменить время или дату последней модификации файла, 
используйте функцию _dos_setftime : </P><PRE><FONT color=#000080>unsigned _dos_setftime (int handle, unsigned date,
  unsigned time);</FONT>
</PRE>
<P>Параметры этой функции аналогичны используемым в функции _dos_getftime , за 
исключением того что в качестве второго и третьего параметра применяются не 
указатели, а непосредственные значения даты и времени. </P>
<H3><FONT color=#008000 size=4>Программа READONLY</FONT></H3>
<P>Приведем программу READONLY (листинг 4.6), изменяющую на противоположное 
значение бита файла атрибутов "Только читаемый" для файла, имя которого 
передается программе в качестве параметра. </P>
<HR>

<P><B>Листинг 4.6. Файл readonly\readonly.cpp</B> </P>
<HR>
<PRE><FONT color=#000080>#include &lt;dos.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

#pragma argsused
void main(int argc, char *argv[])
{
  unsigned fattr;

  _dos_getfileattr (argv[1], &amp;fattr);
  _dos_setfileattr (argv[1], fattr ^ _A_RDONLY);
}</FONT>
</PRE>
<HR>

<P>Программа сначала считывает байт атрибутов, затем инвертирует соответствующий 
бит и устанавливает новое значение байта атрибутов. </P>
<H2><A name="b3.8"><FONT color=#0000ff face=Arial size=4> </FONT><FONT 
color=#0000ff size=4>Буферизация</A> </FONT></H2>
<P>Ввод и вывод для дисков в операционной системе MS-DOS буферизован. Это 
означает, что данные не сразу записываются на диск, а накапливаются в 
специальном массиве (буфере). По мере заполнения буфер сбрасывается на диск. При 
чтении информация заполняет весь входной буфер, независимо от количества байт, 
которые программа читает из файла. В дальнейшем если программе потребуются 
данные, которые уже были считаны с диска и записаны во входной буфер, она 
получит их непосредственно из этого буфера без обращения к диску. </P>
<P>Буферизация сокращает затраты времени на ввод и вывод, особенно в тех 
случаях, когда программе периодически требуется одни и те же участки файлов. При 
копировании файлов буферизация сокращает время на перемещение головок от 
исходного файла к выходному и обратно, причем эффект получается тем больше, чем 
больше размер используемого буфера. </P>
<P>Операционная система MS-DOS может создать несколько буферов. Их количество 
зависит от оператора BUFFERS из файла config.sys . Этот оператор позволяет 
определить от 2 до 99 буферов. Если файл config.sys не содержит оператора 
BUFFERS, по умолчанию используются два буфера. </P>
<P>При увеличении количества буферов увеличивается вероятность того, что нужная 
часть файла уже считана и находится в оперативной памяти. Однако необходимо 
учитывать, что для хранения буферов расходуется основная оперативная память. 
Кроме того, с ростом количества буферов увеличивается время, необходимое 
операционной системе на анализ состояния буферов, что может привести к снижению 
производительности. Значительное снижение скорости работы наступает при 
количестве буферов порядка 50. </P>
<P>Еще один способ организовать буферизацию данных для жестких дисков и 
устройств CD-ROM - использовать драйвер smartdrv.exe . Этот драйвер позволяет 
создать для диска кеш-память в расширенной памяти. </P>
<P>Кеш-память особенно эффективна при работе с базами данных, когда вам 
периодически требуется одна и та же информация. Если создать кеш-память 
достаточно большого размера, можно значительно сократить количество обращений к 
диску. </P>
<P>Буферизация данных имеет и свои недостатки. Если в результате аварии в 
питающей сети или по какой-то другой причине компьютер выключился, то 
информация, хранящаяся в буферах и не записанная на диск, будет потеряна. </P>
<P>При закрытии файла все буферы, связанные с ним, сбрасываются на диск. Если 
вам надо сбросить буферы, не закрывая файл, это можно сделать с помощью функции 
68h прерывания INT&nbsp;21h :<BR></P>
<TABLE>
  <TBODY>
  <TR>
    <TD widthѓ>На входе:</TD>
    <TD widthW>AH</TD>
    <TD width12>68h </TD></TR>
  <TR>
    <TD widthѓ></TD>
    <TD widthW>BX</TD>
    <TD width12>Идентификатор открытого файла </TD></TR>
  <TR>
    <TD widthѓ>На выходе:</TD>
    <TD widthW>AX</TD>
    <TD width12>Код ошибки, если установлен флаг переноса CF; <BR>0, если 
      операция выполнена успешно </TD></TR></TBODY></TABLE>
<P>При вызове этой функции дополнительно обновляется дескриптор файла в 
каталоге, а именно поля времени, даты и размера файла. </P>
<P>Обратите также внимание на функцию расширенного открытия файлов 6Ch. Эта 
функция позволяет при открытии файла отменить буферизацию. </P>
<H2><A name="b3.9"><FONT color=#0000ff face=Arial size=4> </FONT><FONT 
color=#0000ff size=4>Потоки ввода и вывода</FONT></A> </H2>
<P>Стандартная библиотека Borland C++ содержит многочисленные функции, 
использующие собственный механизм буферизации при работе с файлами. Их часто 
называют функциями потокового ввода/вывода . Такую буферизацию не следует путать 
с буферизацией, выполняемой операционной системой. Имена всех этих функций 
начинаются на f - fopen , fclose , fprintf и т. д. </P>
<P>Функции потокового ввода/вывода хорошо описаны во многих учебных пособиях по 
языку программирования С, поэтому мы приведем лишь краткий обзор, делая акцент 
на особенностях их применения. </P>
<P>Существуют потоки , соответствующие стандартным устройствам ввода, вывода, 
вывода сообщений об ошибках, стандартному устройству последовательного 
ввода/вывода и стандартному устройство печати:<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD widthЃ><STRONG>Поток</STRONG></TD>
    <TD width64><STRONG>Описание</STRONG></TD></TR>
  <TR>
    <TD widthЃ>stdin</TD>
    <TD width64>Стандартное устройство ввода </TD></TR>
  <TR>
    <TD widthЃ>stdout</TD>
    <TD width64>Стандартное устройство вывода </TD></TR>
  <TR>
    <TD widthЃ>stderr</TD>
    <TD width64>Стандартное устройство для вывода сообщений об ошибках 
</TD></TR>
  <TR>
    <TD widthЃ>stdaux</TD>
    <TD width64>Стандартное последовательное устройство ввода/вывода </TD></TR>
  <TR>
    <TD widthЃ>stdprn</TD>
    <TD width64>Стандартное печатающее устройство </TD></TR></TBODY></TABLE>
<P>Для использования этих потоков не требуются выполнять процедуру открытия и 
закрытия. </P>
<P>Для работы со стандартными устройствами ввода/вывода в библиотеках 
трансляторов языка программирования С имеется соответствующий набор функций, 
которые должны быть вам хорошо известны - printf, scanf , putchar и т. д. Мы не 
будем их описывать, так как объем книги ограничен. </P>
<H3><FONT color=#008000 size=4>Открытие и закрытие потоков</FONT></H3>
<P>При использовании функций потокового ввода/вывода файлы открываются функцией 
fopen , а закрываются функцией fclose . Эти функции не только открывают и 
закрывают файлы (получают и освобождают их идентификаторы), но и, 
соответственно, создают и уничтожают переменную типа FILE , описанную в файле 
stdio.h и связанную с данным файлом. </P>
<H4><FONT color=#800000>fopen </FONT></H4>
<P>Для организации потокового ввода/вывода вначале необходимо при помощи функции 
fopen открыть файл. Функция fopen имеет следующий прототип: </P><PRE><FONT color=#000080>FILE  *fopen (char *filename, char *mode);</FONT>
</PRE>
<P>Первый параметр указывает на строку, содержащую путь открываемого файла, 
второй - на строку режима открытия файла. Возможны следующие режимы:<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD widths><STRONG>Режим</STRONG></TD>
    <TD width72><STRONG>Операция, для выполнения которой открывается файл 
      </STRONG></TD></TR>
  <TR>
    <TD widths>"r"</TD>
    <TD width72>Чтение</TD></TR>
  <TR>
    <TD widths>"w"</TD>
    <TD width72>Запись</TD></TR>
  <TR>
    <TD widths>"a"</TD>
    <TD width72>Запись, данные будут добавляться в конец файла 
</TD></TR></TBODY></TABLE>
<P>К буквам r, w, a справа могут добавляться буквы t и b. </P>
<P>Буква t означает, что файл будет открыт в текстовом режиме, b - в двоичном. 
Для двоичного режима не выполняется обработка таких символов, как конец строки, 
конец файла и т. д. </P>
<P>Строка режима открытия файла может дополнительно содержать символ '+'. Этот 
символ означает, что для файла разрешены операции чтения и записи одновременно. 
</P>
<H4><FONT color=#800000>fclose </FONT></H4>
<P>Для закрытия файлов, открытых для ввода или вывода потоком, должна 
использоваться функция fclose : </P><PRE><FONT color=#000080>int fclose (FILE  *stream);</FONT>
</PRE>
<P>При закрытии файла освобождаются и сбрасываются на диск все буферы, 
распределенные этому файлу. </P>
<H4><FONT color=#800000>fdopen </FONT></H4>
<P>Если вы открыли файл с помощью функции open , вы можете создать поток для 
этого файла, используя функцию fdopen : </P><PRE><FONT color=#000080>FILE  *fdopen (int handle, char *mode);</FONT>
</PRE>
<P>В качестве первого параметра используется идентификатор файла, полученный от 
функции open . Второй параметр аналогичен параметру mode для функции fopen . 
</P>
<P>Для того чтобы закрыть поток, созданный функцией fdopen , необходимо 
использовать функцию fclose , а не close . </P>
<H4><FONT color=#800000>fileno </FONT></H4>
<P>Для открытого потока вы можете узнать идентификатор соответствующего файла с 
помощью функции fileno : </P><PRE><FONT color=#000080>int fileno (FILE  *stream);</FONT>
</PRE>
<P>Функция возвращает идентификатор файла, связанного с данным потоком. </P>
<H4><FONT color=#800000>fwrite </FONT></H4>
<P>Для записи данных в поток предназначена функция fwrite : </P><PRE><FONT color=#000080>size_t fwrite (void *buffer, size_t size,
  size_t count, FILE  *stream);</FONT>
</PRE>
<P>Эта функция записывает в файл stream блоки информации, каждый из которых 
имеет длину size байт. Количество блоков - count. Данные для записи расположены 
по адресу buffer. </P>
<P>Если файл открыт в текстовом режиме, каждый символ возврата каретки CR 
заменяется на два символа - возврата каретки CR и перевода строки LF. </P>
<P>Функция возвращает количество действительно записанных блоков информации без 
учета замены символа CR в текстовом режиме. </P>
<H4><FONT color=#800000>fread </FONT></H4>
<P>Чтение данных потоком можно выполнить с помощью функции fread : </P><PRE><FONT color=#000080>size_t fread (void *buffer, size_t size,
  size_t count, FILE  *stream);</FONT>
</PRE>
<P>Эта функция используется аналогично предыдущей. Для распознавания конца файла 
и обнаружения ошибок после вызова этой функции необходимо использовать функции 
feof и ferror. </P>
<P>Если при использовании функции fread вы задали значения параметров size или 
count, равные нулю, функция fread не изменяет содержимое буфера buffer. </P>
<H4><FONT color=#800000>fseek </FONT></H4>
<P>Для позиционирования внутри файла, открытого потоком с помощью функции fopen, 
предназначена функция fseek : </P><PRE><FONT color=#000080>int fseek (FILE  *stream, long offset, int origin);</FONT>
</PRE>
<P>В этой функции параметр offset задает новое содержимое указателя текущей 
позиции в файле stream, а параметр origin определяет способ задания новой 
позиции. Этот оператор может иметь значения, аналогичные используемым в функции 
lseek :<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD width4><STRONG>Значение</STRONG></TD>
    <TD width21><STRONG>Описание</STRONG></TD></TR>
  <TR>
    <TD width4>SEEK_SET </TD>
    <TD width21>Абсолютное смещение от начала файла </TD></TR>
  <TR>
    <TD width4>SEEK_CUR </TD>
    <TD width21>Смещение относительно текущей позиции </TD></TR>
  <TR>
    <TD width4>SEEK_END </TD>
    <TD width21>Смещение относительно конца файла </TD></TR></TBODY></TABLE>
<P>При открытии файла указатель текущей позиции устанавливается на начало файла. 
Операции ввода или вывода вызывают увеличение значения этого указателя на 
количество, соответственно, прочитанных или записанных байт. </P>
<P>Функция fseek позволяет вам установить указатель за конец файла, однако при 
попытке установит указатель до начала файла функция возвратит признак ошибки - 
ненулевое значение. </P>
<P>При использовании функции fseek для позиционирования внутри файлов, открытых 
в текстовом режиме, необходимо учитывать особенность обработки текстовых файлов 
- автоматическую замену символа возврата каретки CR на пару символов: возврат 
каретки CR и перевод строки LF. Для текстовых файлов функция fseek будет 
правильно работать только в следующих двух случаях: 
<UL>
  <LI><I>если поиск выполняется со смещением offset, равным нулю, при любом 
  значении параметра origin;</I> 
  <LI><I>если поиск выполняется относительно начала файла, причем в качестве 
  смещения offset используется значение, полученное специальной функцией ftell 
  .</I> </LI></UL>
<H4><FONT color=#800000>ftell </FONT></H4>
<P>Функция ftell возвращает текущее значение указателя позиции для файла, или -1 
при ошибке: </P><PRE><FONT color=#000080>long ftell (FILE  *stream);</FONT>
</PRE>
<P>Пара функций ftell и fseek позволит вам правильно организовать 
позиционирование для файлов, открытых в текстовом режиме. </P>
<H4><FONT color=#800000>fgetpos , fsetpos </FONT></H4>
<P>Есть еще одна возможность организовать позиционирование внутри файлов, 
открытых потоком - вызов пары функций fgetpos и fsetpos : </P><PRE><FONT color=#000080>int fgetpos (FILE  *stream, fpos_t *pos);
int fsetpos (FILE  *stream, fpos_t *pos);</FONT>
</PRE>
<P>Эти две функции используют для запоминания и установки позиции переменную с 
типом fpos_t, определенным в файле stdio.h. Функция fgetpos записывает в эту 
переменную текущую позицию в потоке stream. Содержимое переменной затем может 
быть использовано для установки позиции в потоке с помощью функции fsetpos . 
</P>
<P>Обе эти функции возвращают нулевое значение в случае успешного завершения 
работы, или ненулевое - при ошибке. </P>
<H3><FONT color=#008000 size=4>Форматный ввод и вывод</FONT></H3>
<P>Среди потоковых функций можно выделить группу функций форматного ввода и 
вывода. Это такие функции, как fputc , fgetc , fputs , fgets , fprintf , fscanf 
. </P>
<P>Функции форматного ввода и вывода сильно облегчают запись и чтение таких 
элементов данных, как отдельные байты, текстовые строки, числа в различных 
форматах. </P>
<H4><FONT color=#800000>fputc </FONT></H4>
<P>Для записи в поток отдельных байт используется функция fputc : </P><PRE><FONT color=#000080>int fputc (int c, FILE  *stream);</FONT>
</PRE>
<P>Байт c записывается в поток stream начиная с текущей позиции. После записи 
текущая позиция увеличивается на единицу. Функция возвращает записанный байт или 
значение EOF , которое служит признаком ошибки. </P>
<H4><FONT color=#800000>fgetc </FONT></H4>
<P>Для побайтового чтения содержимого файла, открытого потоком, удобно 
использовать функцию fgetc : </P><PRE><FONT color=#000080>int fgetc (FILE  *stream);</FONT>
</PRE>
<P>Эта функция возвращает байт, считанный из потока stream и преобразованный к 
типу int. После чтения байта текущая позиция в потоке увеличивается на единицу. 
</P>
<P>При достижении конца файла или в случае ошибок функция fgetc возвращает 
значение EOF . Однако для проверки на ошибку или конец файла лучше пользоваться 
специальными функциями ferror и feof. Если вы открыли файл в двоичном режиме, 
единственный способ определить момент достижения конца файла - использовать 
функцию feof, так как значение константы EOF может находиться в любом месте 
двоичного файла. </P>
<H4><FONT color=#800000>fputs и fgets </FONT></H4>
<P>Для работы со строками предназначены функции fputs и fgets . </P>
<P>Функция fputs предназначена для вывода строки в файл, открытый потоком: </P><PRE><FONT color=#000080>int fputs (char *string, FILE  *stream);</FONT>
</PRE>
<P>Первый параметр - указатель на строку, второй - поток, в который эта строка 
выводится. Двоичный нуль, закрывающий строку, в выходной файл не копируется. 
После вывода строки содержимое текущего указателя позиции увеличивается на 
количество записанных байт. </P>
<P>Для ввода строк из текстового файла удобна функция fgets : </P><PRE><FONT color=#000080>int fgets (char *string, int n, FILE  *stream);</FONT>
</PRE>
<P>Функция читает байты из потока stream и записывает их в блок памяти, 
указатель на который задан параметром string, до тех пор, пока не произойдет 
одно из двух событий - будет прочитан символ новой строки '\n' или количество 
прочитанных символов не станет равно n-1. </P>
<P>После того, как байты будут прочитаны в блок памяти, в конец строки 
образованной из этих байт, функция запишет двоичный нуль. Если был прочитан 
символ новой строки '\n', он тоже будет записан. </P>
<P>Для анализа достижения конца файла или ошибок необходимо использовать функции 
feof и ferror. </P>
<H4><FONT color=#800000>fprintf </FONT></H4>
<P>Для форматного вывода в файл содержимого переменных удобно использовать 
функцию fprintf : </P><PRE><FONT color=#000080>int fprintf (FILE  *stream, char *format [,arg]...);</FONT>
</PRE>
<P>Эта функция аналогична хорошо известной вам функции форматного вывода на 
экран printf, с которой обычно начинают изучение языка программирования С. 
Вспомните такую программу: </P><PRE><FONT color=#000080>#include &lt;stdio.h&gt;
main() 
{
  printf("Hello, world!");
}</FONT>
</PRE>
<P>Функция fprintf имеет дополнительно один параметр - stream, который 
определяет выходной поток. </P>
<P>После завершения работы функция возвращает количество записанных байт или 
отрицательную величину, если при записи произошла ошибка. </P>
<H4><FONT color=#800000>fscanf </FONT></H4>
<P>Для форматного ввода информации из файла можно использовать функцию fscanf , 
аналогичную известной вам функции scanf : </P><PRE><FONT color=#000080>int fscanf (FILE  *stream, char *format [,arg]...);</FONT>
</PRE>
<P>Эта функция читает данные, начиная с текущей позиции в потоке stream, в 
переменные, определенные аргументами arg. Каждый аргумент должен являться 
указателем на переменную, соответствующую типу, определенному в строке формата 
format. </P>
<P>Функция fscanf возвращает количество успешно считанных и преобразованных в 
указанный формат полей. Те поля, которые были считаны, но не преобразовывались, 
в возвращаемом функцией значении не учитываются. </P>
<P>При достижении конца файла функция возвращает значение EOF . Если функция 
возвратила нулевое значение, это означает, что преобразование полей не 
производилось. </P>
<H3><FONT color=#008000 size=4>Буферизация потоков</FONT></H3>
<P>Рассмотрим теперь функции, управляющие буферизацией для потокового 
ввода/вывода. <BR></P>
<H4><FONT color=#800000>setbuf </FONT></H4>
<P>Функция setbuf позволяет вам заменить системный буфер на свой собственный: 
</P><PRE><FONT color=#000080>void setbuf (FILE  *stream, char *buffer);</FONT>
</PRE>
<P>Параметр buffer должен указывать на подготовленный пользователем массив, 
имеющий размер BUFSIZ байт. Константа BUFSIZ описана в файле stdio.h. </P>
<H4><FONT color=#800000>setvbuf </FONT></H4>
<P>Функция setvbuf позволяет программе не только указать свой буфер, но и задать 
его размер: </P><PRE><FONT color=#000080>int setvbuf (FILE  *stream, char *buffer, int mode,
  size_t size);</FONT>
</PRE>
<P>Параметр stream должен указывать на открытый поток, причем для этого потока 
до вызова функции setvbuf нельзя выполнять операции чтения и записи. </P>
<P>Параметр buffer должен указывать на подготовленный программой буфер размером 
size байт. Этот буфер будет использоваться для работы с потоком stream. </P>
<P>Параметр mode может принимать значения _IOFBF , _IOLBF , _IONBF . Если mode 
равен _IOFBF или _IOLBF, параметр size указывает размер буфера. Если параметр 
mode равен _IONBF, буферизация не используется, а параметры buffer и size 
игнорируются. </P>
<P>Параметры _IOFBF и _IOLBF эквивалентны друг другу. </P>
<P>Если в качестве адреса буфера buffer задать значение NULL, функция 
автоматически закажет буфер размером size. </P>
<P>Функция setvbuf возвращает нуль при успешном завершении и ненулевую величину, 
если указан неправильный параметр mode или неправильный размер буфера size. </P>
<P>Для чего может понадобиться изменение размера буфера? </P>
<P>Главным образом - для сокращения времени, необходимого для позиционирования 
магнитных головок при выполнении операций одновременно над несколькими файлами, 
например, при копировании файлов, слиянии нескольких файлов в один и т. д. </P>
<H4><FONT color=#800000>fflush </FONT></H4>
<P>При закрытии потока функцией fclose содержимое буфера записывается на диск. 
Если программе необходимо выполнить запись содержимого буфера на диск без 
закрытия файла, она может воспользоваться функцией fflush : </P><PRE><FONT color=#000080>int fflush (FILE  *stream);</FONT>
</PRE>
<P>Эта функция возвращает нуль при успешной записи буфера на диск, а так же в 
тех случаях, когда поток либо совсем не имеет буфера, либо открыт только для 
чтения. При ошибке возвращается значение EOF . </P>
<P>Если поток открыт только для чтения, функция fflush очищает содержимое 
буфера, связанного с этим потоком. </P>
<H3><FONT color=#008000 size=4>Программа BUFCOPY</FONT></H3>
<P>В качестве примера приведем текст программы BUFCOPY (листинг 4.7), копирующей 
содержимое текстового файла. </P>
<P>Программа копирует этот файл три раза. В первый раз она использует буфер 
стандартного размера, затем увеличивает размер буфера в десять раз, и наконец, 
копирует файл без использования механизма буферизации. Каждый раз программа 
измеряет продолжительность копирования файла с помощью функции clock, входящей в 
состав стандартной библиотеки Borland C++. </P>
<HR>

<P><B>Листинг 4.7. Файл bufcopy\ bufcopy.cpp</B> </P>
<HR>
<PRE><FONT color=#000080>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;

void filecpy(FILE  *stream_from, FILE *stream_to);

// Буферы для файлов
char buf1[BUFSIZ * 10];
char buf2[BUFSIZ * 10];

int main(int argc, char *argv[])
{
  time_t start, end;
  FILE  *stream_from, *stream_to;

  if(argc &lt; 3)
  {
    printf("Задайте имена файлов!\n");
    return(-1);
  }

  // Открываем файлы и используем для копирования
  // буфер стандартного размера
  if((stream_from = fopen (argv[1], "rt")) == NULL)
  {
    printf("Задайте имя входного файла!\n");
    return(-1);
  }

  stream_to = fopen (argv[2], "wt+");

  // Определяем время начала копирования
  start = clock();

  // Выполняем копирование файла
  filecpy(stream_from,stream_to);

  // Определяем время завершения копирования
  end = clock();

  // Выводим время копирования при использовании
  // буферов стандартного размера
  printf("Время копирования: %5.1f "
    "Размер буфера, байтов: %d\n",
    ((float)end - start) / CLK_TCK, BUFSIZ);

  // Задаем свой буфер большего размера
  if((stream_from = fopen (argv[1], "rt")) == NULL)
    return(-1);

  stream_to = fopen (argv[2], "wt+");

  // Устанавливаем буферы как для входного,
  // так и для выходного файлов
  setvbuf (stream_from, buf1, _IOFBF , sizeof(buf1));
  setvbuf (stream_to,   buf2, _IOFBF , sizeof(buf2));

  // Копируем файл и измеряем продолжительность
  // копирования
  start = clock();
  filecpy(stream_from,stream_to);
  end = clock();

  printf("Время копирования: %5.1f "
    "Размер буфера: %d\n",
    ((float)end - start) / CLK_TCK, BUFSIZ * 10);

  // Копируем без использования буферизации
  if((stream_from = fopen (argv[1], "rt")) == NULL)
    return(-1);

  stream_to = fopen (argv[2], "wt+");
  setvbuf (stream_from, NULL, _IONBF , 0);
  setvbuf (stream_to,   NULL, _IONBF , 0);

  start = clock();
  filecpy(stream_from,stream_to);
  end = clock();

  printf("Время копирования: %5.1f "
    "Буферизация  не используется\n",
    ((float)end - start) / CLK_TCK);

  return(0);
}

// Функция для копирования файлов
void filecpy(FILE  *stream_from, FILE *stream_to)
{
  char linebuf[256];

  // Цикл копирования. Условие выхода из цикла -
  // достижение кнеца входного файла
  while(!feof(stream_from))
  {
    // Читаем в буфер linebuf одну строку
    if(fgets (linebuf, 255, stream_from) == NULL)
      break;

    // Записываем содержимое буфера linebuf
    // в выходной файл
    if(fputs (linebuf, stream_to) != 0)
      break;
  }

  // Закрываем входной и выходной файлы
  fclose (stream_from);
  fclose (stream_to);
}</FONT>
</PRE>
<HR>

<H2><A name="b3.10"><FONT color=#0000ff face=Arial size=4> </FONT><FONT 
color=#0000ff size=4>Другие функции для работы с файлами</FONT></A></H2>
<P>В задачу данной книги не входит описание всех функций стандартных библиотек 
трансляторов Borland C++, Microsoft Quick C или аналогичных, предназначенных для 
работы с дисками и файловой системой. Но мы приведем еще несколько интересных и 
полезных на наш взгляд функций. </P>
<P>Как мы уже отметили, программа может использовать два режима ввода/вывода для 
файлов - текстовый и двоичный. Переключение этого режима для открытого файла 
можно выполнять с помощью функции setmode : </P><PRE><FONT color=#000080>int setmode (int handle, int mode);</FONT>
</PRE>
<P>Первый параметр - идентификатор файла. Второй параметр может принимать два 
значения:<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD width2><STRONG>Значение</STRONG></TD>
    <TD width49><STRONG>Описание</STRONG></TD></TR>
  <TR>
    <TD width2>O_TEXT </TD>
    <TD width49>Установить текстовый режим </TD></TR>
  <TR>
    <TD width2>O_BINARY </TD>
    <TD width49>Установить двоичный режим </TD></TR></TBODY></TABLE>
<P>Функция setmode должна вызываться перед началом операций ввода или вывода в 
открытый файл. </P>
<P>Мы рассказывали о позиционировании внутри файла. Если вам нужно просто 
установить указатель позиции на начало файла, открытого для потока, вы можете 
воспользоваться функцией rewind : </P><PRE><FONT color=#000080>void rewind (FILE  *stream);</FONT>
</PRE>
<P>Если вам нужно переназначить ввод или вывод для стандартных потоков (stdin, 
stdout, stderr), вы можете использовать функцию freopen : </P><PRE><FONT color=#000080>FILE  *freopen (char *filename, char *mode, FILE *stream);</FONT>
</PRE>
<P>Функция freopen закрывает файл, с которым был связан поток stream, и 
переназначает этот поток на файл, определенный параметром filename. Параметр 
mode задается так же, как и для функции fopen . </P>
<P>Можно переназначить идентификатор файла, открытого функцией open . Для этого 
можно воспользоваться одной из двух функций - dup или dup2 : </P><PRE><FONT color=#000080>int dup (int handle);
int dup2 (int handle1, int handle2);</FONT>
</PRE>
<P>Первая функция связывает с открытым файлом еще один идентификатор. Она 
возвращает этот идентификатор при успешном завершении. В случае ошибки она 
возвращает значение -1. </P>
<P>Новый идентификатор может быть использован для любых операций над файлом. 
</P>
<P>Функция dup2 переназначает идентификатор файла handle2, связывая его с тем же 
файлом, которому соответствует идентификатор handle1. Если во время вызова 
функции dup2 с идентификатором handle2 связан какой-либо открытый файл, этот 
файл закрывается. В случае успешного завершения функция dup2 возвращает нулевое 
значение. Если произошла ошибка, возвращается значение -1. </P>
<H2><A name="b3.11"><FONT color=#0000ff face=Arial size=4> </FONT><FONT 
color=#0000ff size=4>Таблица открытых файлов</A> </FONT></H2>
<P>В предыдущем томе при описании векторной таблицы связи мы говорили о том, что 
для всех открытых файлов MS-DOS хранит различную информацию в специальной 
таблице. Ее адрес находится в поле file_tab векторной таблицы связи. </P>
<P>В этой таблице для каждого открытого файла хранится информация о количестве 
идентификаторов, связанных с данным файлом, режиме открытия файла (чтение, 
запись и т. д.), слово информации об устройстве, указатель на заголовок 
драйвера, обслуживающего данное устройство, элемент дескриптора файла (дата, 
время, имя файла, номер начального кластера, распределенного файлу), номер 
последнего прочитанного кластера и т. д. </P>
<P>Теперь, когда вы изучили способы работы с файлами, имеет смысл еще раз 
вернуться к разделу, посвященному таблице открытых файлов. </P>
<P>Вы можете самостоятельно экспериментировать с этой таблицей. Можно, например, 
попробовать создать несколько идентификаторов для какого-либо файла и посмотреть 
после этого содержимое поля, в котором находится количество идентификаторов, 
связанных с данным файлом. </P>
<P>Можно попробовать организовать чтение файла порциями размером в один кластер, 
и при этом каждый раз выводить содержимое поля, в котором находится номер 
последнего прочитанного кластера. Это один из самых простых способов получить 
список кластеров, распределенных данному файлу. </P>
<P>Однако не обольщайтесь - все что связано с таблицей файлов, отсутствует в 
документации по операционной системе MS-DOS. Используя эту таблицу для 
определения списка кластеров или для каких-либо других целей, вы рискуете 
потерять совместимость с последующими версиями операционной системы. </P>
<H2><A name="b3.12"><FONT color=#0000ff face=Arial size=4> </FONT><FONT 
color=#0000ff size=4>Обработка критических ошибок</FONT></A> </H2>
<P>Операционная система MS-DOS позволяет программам устанавливать собственный 
обработчик критических ошибок аппаратуры. Мы уже говорили о том, что вектор 
0000h:0090h, соответствующий прерыванию INT&nbsp;24h , содержит адрес 
обработчика критических ошибок. Этот обработчик получает управление от 
операционной системы, когда драйвер какого-либо устройства обнаруживает ошибку 
аппаратуры. </P>
<P>Обратите внимание на то, что обработчик критических ошибок не вызывается при 
работе с диском через прерывания INT&nbsp;25h или INT 26h. Тем более, он не 
вызывается при работе с диском на уровне прерывания INT&nbsp;13h . </P>
<P>При запуске программы операционная система MS-DOS копирует адрес обработчика 
в префикс сегмента программы PSP, а после завершения работы программы - 
восстанавливает его из PSP. </P>
<P>Стандартный обработчик MS-DOS выводит на экран сообщение: </P><PRE><FONT color=#000080>Abort, Retry, Ignore, Fail?</FONT>
</PRE>
<P>Если ваша программа должна сама обрабатывать ошибки аппаратуры, она может 
установить свой собственный обработчик критических ошибок. </P>
<H3><FONT color=#008000 size=4>Анализ регистров</FONT></H3>
<P>Когда обработчик получает управление, регистры процессора содержат 
информацию, необходимую для определения причины и места появления 
ошибки:<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD widthq><STRONG>Регистр</STRONG></TD>
    <TD width74><STRONG>Содержимое</STRONG></TD></TR>
  <TR>
    <TD widthq>AH</TD>
    <TD width74>Информация об ошибке.Бит 0: тип операции: <BR>0 - чтение, 1 
      - запись <BR>Биты 1,2: область диска, где произошла ошибка: <BR>00 - 
      системные файлы; <BR>01 - область FAT ; <BR>10 - область каталога; <BR>11 
      - область данных. <BR>Бит 3: если равен 1, возможен выход с кодом FAIL 
      <BR>Бит 4: если равен 1, возможен выход с кодом RETRY <BR>Бит 5: если 
      равен 1, возможен выход с кодом IGNORE <BR>Бит 6 зарезервирован, равен 
      0<BR>Бит 7 тип устройства: 0 - диск; 1 - символьное устройство </TD></TR>
  <TR>
    <TD widthq>AL</TD>
    <TD width74>Номер диска (если бит 7 регистра AH равен 0) </TD></TR>
  <TR>
    <TD widthq>DI</TD>
    <TD width74>Код ошибки (биты 0...7, остальные биты не определены) </TD></TR>
  <TR>
    <TD widthq>BP:SI</TD>
    <TD width74>Адрес заголовка драйвера устройства, в котором произошла 
      ошибка </TD></TR></TBODY></TABLE>
<P>Обработчик критических ошибок не должен пользоваться функциями MS-DOS с 
кодами, большими чем 0Ch (из-за того, что функции MS-DOS не реентерабельны). 
</P>
<P>Программа обработки критических ошибок может вывести на экран сообщение об 
ошибке и запросить оператора о необходимых действиях. Ей разрешено также 
получить дополнительную уточняющую информацию об ошибке с помощью функции 59h 
прерывания INT&nbsp;21h или узнать версию MS-DOS с помощью функции 30h этого же 
прерывания. </P>
<P>Дополнительная информация об устройстве, в котором произошла ошибка, может 
быть получена с использованием адреса заголовка драйвера устройства, который 
передается операционной системой при вызове обработчика в регистрах BP:SI. </P>
<H3><FONT color=#008000 size=4>Анализ стека</FONT></H3>
<P>Для определения номера функции MS-DOS, в которой произошла критическая 
ошибка, программа-обработчик может выполнить анализ стека. Когда обработчик 
получает управление, стек имеет следующую структуру: <BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD widthD2>
      <P alignОnter>Адрес возврата в DOS для команды IRET </P></TD></TR>
  <TR>
    <TD widthD2>
      <P alignОnter>IP</P></TD></TR>
  <TR>
    <TD widthD2>
      <P alignОnter>CS</P></TD></TR>
  <TR>
    <TD widthD2>
      <P alignОnter>FLAGS</P></TD></TR>
  <TR>
    <TD widthD2>
      <P alignОnter>Содержимое регистров программы перед вызовом INT 21h 
    </P></TD></TR>
  <TR>
    <TD widthD2>
      <P alignОnter>AX, BX, CX, DX, SI, DI, BP, DS, ES </P></TD></TR>
  <TR>
    <TD widthD2>
      <P alignОnter>Адрес возврата в программу, вызвавшую функцию DOS 
  </P></TD></TR>
  <TR>
    <TD widthD2>
      <P alignОnter>IP</P></TD></TR>
  <TR>
    <TD widthD2>
      <P alignОnter>CS</P></TD></TR>
  <TR>
    <TD widthD2>
      <P alignОnter>FLAGS</P></TD></TR></TBODY></TABLE>
<P>Выполнив анализ регистра AH, можно определить номер функции MS-DOS, при 
вызове которой произошла ошибка, а зная содержимое остальных регистров - и все 
параметры этой функции. </P>
<H3><FONT color=#008000 size=4>Код действия</FONT> </H3>
<P>После выполнения всех необходимых действий программа обработки критических 
ошибок должна возвратить в регистре AL код действия, которое должна выполнить 
операционная система для обработки данной ошибки:<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD widthH><STRONG>Код</STRONG></TD>
    <TD width97><STRONG>Описание</STRONG></TD></TR>
  <TR>
    <TD widthH>0</TD>
    <TD width97>Игнорировать ошибку</TD></TR>
  <TR>
    <TD widthH>1</TD>
    <TD width97>Повторить операцию</TD></TR>
  <TR>
    <TD widthH>2</TD>
    <TD width97>Завершить задачу аварийно, используя адрес завершения, 
      записанный в векторе прерывания INT&nbsp;23h </TD></TR>
  <TR>
    <TD widthH>3</TD>
    <TD width97>Вернуть программе управление с соответствующим кодом ошибки 
    </TD></TR></TBODY></TABLE>
<P>При открытии файлов с помощью функции 6Ch программа может заблокировать вызов 
обработчика критических ошибок. </P>
<H3><FONT color=#008000 size=4>Функции библиотеки Borland C++</FONT></H3>
<P>Для составления программы обработки критических ошибок вы можете 
воспользоваться языком ассемблера или функциями стандартной библиотеки Borland 
C++ с именами _dos_getvect , _dos_setvect , _chain_intr . Однако лучше всего 
использовать специально предназначенные для этого функции _harderr , _hardresume 
и _hardretn . </P>
<H4><FONT color=#800000>_harderr </FONT></H4>
<P>Функция _harderr предназначена для установки нового обработчика критических 
ошибок, она имеет следующий прототип: </P><PRE><FONT color=#000080>void _harderr (void (far *handler)());</FONT>
</PRE>
<P>Параметр handler - указатель на новую функцию обработки критических ошибок. 
</P>
<H4><FONT color=#800000>_hardresume </FONT></H4>
<P>Функция _hardresume и описанная ниже функция _hardretn должны быть 
использованы в обработчике критических ошибок, установленном функцией _harderr . 
</P>
<P>Функция _hardresume возвращает управление операционной системе, она имеет 
прототип: </P><PRE><FONT color=#000080>_hardresume (int result);</FONT>
</PRE>
<P>Параметр result может иметь следующие значения (в соответствии с необходимыми 
действиями):<BR></P>
<TABLE border=1>
  <TBODY>
  <TR>
    <TD width2><STRONG>Значение</STRONG></TD>
    <TD width(9><STRONG>Описание</STRONG></TD></TR>
  <TR>
    <TD width2>_HARDERR_ABORT</TD>
    <TD width(9>Завершить программу аварийно </TD></TR>
  <TR>
    <TD width2>_HARDERR_FAIL</TD>
    <TD width(9>Вернуть код ошибки </TD></TR>
  <TR>
    <TD width2>_HARDERR_IGNORE</TD>
    <TD width(9>Игнорировать ошибку </TD></TR>
  <TR>
    <TD width2>_HARDERR_RETRY</TD>
    <TD width(9>Повторить операцию </TD></TR></TBODY></TABLE>
<P>Эти параметры описаны в файле dos.h. </P>
<H4><FONT color=#800000>_hardretn </FONT></H4>
<P>Функция _hardretn возвращает управление непосредственно программе, передавая 
ей код ошибки, определяемый параметром функции error: </P><PRE><FONT color=#000080>void _hardretn (int error);</FONT>
</PRE>
<P>При этом программа получает код ошибки error после возврата из вызванной ей 
функции MS-DOS. Если ошибка произошла при выполнении функции с номером, большим 
чем 38h, дополнительно устанавливается флаг переноса. Если номер функции был 
меньше указанного значения, в регистр AL записывается величина FFh. </P>
<H4><FONT color=#800000>Функция обработки критических ошибок</FONT> </H4>
<P>Функция обработки критических ошибок handler имеет следующие параметры: </P><PRE><FONT color=#000080>void far handler(unsigned deverror, unsigned errcode,
  unsigned far *devhdr);</FONT>
</PRE>
<P>Первый параметр - код ошибки устройства. Он равен содержимому регистра AX при 
вызове обработчика прерывания INT&nbsp;24h . Аналогично, параметр errcode 
соответствует содержимому регистра DI - код ошибки. Третий параметр devhdr - это 
указатель на заголовок драйвера устройства (передаваемый в регистрах BP:SI). 
</P>
<H3><FONT color=#008000 size=4>Программа CRITERR</FONT></H3>
<P>Для демонстрации использования функций установки обработчика критических 
ошибок приведем программу, которая пытается создать каталог на диске А:. Эта 
программа сама обрабатывает критические ошибки, запрашивая у оператора 
информацию о необходимых действиях. </P>
<HR>

<P><B>Листинг 4.8. Файл criterr\criterr.cpp</B> </P>
<HR>
<PRE><FONT color=#000080>// Эту программу можно запускать только из командной
// строки. При запуске из интегрированной среды
// Borland C++ возможен конфликт с используемым в этих
// средах обработчиком критических ошибок

#include &lt;stdio.h&gt;
#include &lt;conio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;direct.h&gt;
#include &lt;string.h&gt;
#include &lt;dos.h&gt;
#include &lt;bios.h&gt;

void far hhandler(unsigned deverr,
  unsigned doserr, unsigned far *hdr);
void _bios_str(char *p);

int main()
{
  // Устанавливаем обработчик критических ошибок
  _harderr (hhandler);

  // Моделируем критическую ошибку.
  // Выполняем попытку создать каталог на диске А:.
  // Если мы "забудем" вставить в дисковод
  // дискету, будет вызван обработчик
  // критической ошибки
  printf("\nВставьте (или не вставляйте) "
    "дискету в дисковод A:"
    "\nи нажмите любую клавишу...\n");
  getch();

  // Создаем каталог
  if(mkdir ("a:\\test_ctl"))
  {
    printf("\nОшибка при создании каталога");
    return(-1);
  }
  else
  {
    // Удаляем только что созданный каталог
    rmdir ("a:test_ctl");
  }
  return 0;
}

// Новый обработчик критических ошибок
#pragma argsused
void far hhandler(unsigned deverr,
  unsigned doserr, unsigned far *hdr)
{
  int ch;
  static char buf[200];

  // Выводим сообщение о критической ошибке
  sprintf(buf,"\n\r"
    "\n\rКод ошибки устройтсва: .4X"
    "\n\rКод ошибки DOS:        %d"
    "\n\r\n\r"
    "\n\rВыполняемые действия:"
    "\n\r  0 - повторить"
    "\n\r  1 - отменить"
    "\n\r  2 - завершить"
    "\n\r----&gt; ?",
     deverr, doserr);

  _bios_str(buf);

  // Вводим ответ с клавиатуры
  ch = _bios_keybrd(_KEYBRD_READ) &amp; 0x00ff;
  _bios_str("\n\r");

  switch(ch)
  {
    case '0':  // Пытаемся повторить операцию
    default:
      _hardresume (_HARDERR_RETRY);

    case '2':  // Завершаем работу программы
      _hardresume (_HARDERR_ABORT);

    case '1':  // Возврат в DOS с кодом ошибки
      _hardretn (doserr);
  }
}

// Программа для вывода строки символов на экран
// с помощью функции BIOS 0Eh
void _bios_str(char *ptr)
{
  union REGS inregs, outregs;

  inregs.h.ah = 0x0e;
  for(; *ptr; ptr++)
  {
    inregs.h.al = *ptr;
    int86(0x10, &amp;inregs, &amp;outregs);
  }
}</FONT>
</PRE>
<HR>
</BODY></HTML>
