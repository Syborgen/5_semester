<HTML>
<HEAD>
<TITLE>Алфавитно-цифровые терминалы</TITLE>
</HEAD>
<BODY>
  <b><font size="6"><center>Алфавитно-цифровые терминалы</center></font></b><br>
  <br>
  У каждого универсального компьютера есть по крайней мере одна клавиатура и один 
  дисплей (монитор или плоский экран), используемые для общения с компьютером. 
  Хотя клавиатура и дисплей персонального компьютера технически являются отдельными 
  устройствами, они сообща образуют пользовательский интерфейс. К мэйнфреймам 
  часто присоединяются специальные устройства, состоящие из клавиатуры и дисплея, 
  за которыми могут работать удаленные пользователи. Такие устройства исторически 
  называются <b>терминалами.</b> Мы будем продолжать использовать этот термин 
  даже при обсуждении персональных компьютеров (по большей части из-за отсутствия 
  лучшего термина).<br>
<dd> Существует много разновидностей терминалов. На практике сегодня наиболее 
  часто встречаются следующие три типа терминалов:<br>
  <br>
<dd> 1. Автономные терминалы с последовательным интерфейсом RS-232 для связи с 
  мэйнфреймами.<br>
<dd> 2. Дисплеи персональных компьютеров с графическим интерфейсом пользователя.<br>
<dd> 3. Сетевые терминалы.<br>
  <br>
<dd> Каждый из этих типов терминалов занимает свою &laquo;экологическую&raquo; 
  нишу. В следующих разделах мы опишем все эти типы терминалов по очереди.<br>
  <br>
  <br>
<a NAME="01"></a>
  <b><font size="4">Технические средства терминалов с интерфейсом RS-232</font></b><br>
  <br>
  Терминалы с интерфейсом RS-232 представляют собой технические устройства, состоящие 
  из клавиатуры и дисплея, общающиеся по последовательному интерфейсу (рис. 5.30). 
  Эти терминалы соединяются с интерфейсной платой при помощи 9-контактного или 
  25-контактного разъема. Один из контактов разъема используется для передачи 
  данных, другой контакт — для получения данных, еще один контакт представляет 
  собой заземление. Остальные контакты используются для различных управляющих 
  функций, большая часть которых не используется. Линии, по которым символы посылаются 
  побитно (в противоположность передаче стразу по 8 бит параллельно, как обычно 
  соединяются с персональными компьютерами принтеры), называются линиями последовательной 
  передачи. Этот интерфейс также используется всеми модемами. В системе UNIX линии 
  последовательной передачи имеют имена вроде <i>/dev/tty1 или /dev/tty2.</i> 
  В системе Windows они обычно называются <i>СОМ1 </i> и <i>COM2</i>.<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_28.jpg" alt="Терминал с интерфейсом RS-232 общается с компьютером побитно"><br>
    <br>
    <b><font face="Arial">Рис. 5.30.</font></b><font face="Arial"> Терминал с 
    интерфейсом RS-232 общается с компьютером побитно</font><br>
  </center>
  <br>
<dd> Чтобы послать символ по линии последовательной передачи на терминал с интерфейсом 
  RS-232 или модем, компьютер должен передавать данные по одному биту, начиная 
  передачу каждого символа со стартового бита и заканчивая одним или двумя стоповыми 
  битами для разделения символов. Перед стоповыми битами может также добавляться 
  бит четности, обеспечивающий рудиментарное обнаружение ошибок, что обычно требуется 
  только при связи с мэйнфреймами.<br>
<dd> Терминалы с интерфейсом RS-232 все еще применяются на мэйнфреймах, иногда 
  соединенные по телефонной линии через модем. Их можно встретить в аэропортах, 
  банках и других организациях. Даже когда они заменяются персональными компьютерами, 
  эти персональные компьютеры часто просто эмулируют старые терминалы с интерфейсом 
  RS-232, чтобы не менять программное обеспечение мэйнфреймов.<br>
<dd> Такие терминалы также доминировали в мире мини-компьютеров. Большая часть 
  программного обеспечения, созданного в тот период, основывалось на этих терминалах. 
  Например, этот тип устройств поддерживается всеми системами UNIX.<br>
<dd> Однако, что еще важнее, многие современные системы UNIX (а также и другие 
  операционные системы) предоставляют возможность создать окно, состоящее из текстовых 
  строк. Многие программисты работают практически исключительно в текстовом режиме 
  в таких окнах, даже на персональных компьютерах или рабочих станциях. Эти окна 
  обычно эмулируют терминалы с интерфейсом RS-232 (либо ANSI-стандарт терминала 
  этого типа), поэтому в них может работать огромное количество программ, написанных 
  для подобных терминалов. За долгие годы это программное обеспечение, например 
  текстовые редакторы <i>vi </i> и <i>emacs,</i> было полностью очищено от ошибок 
  и обладает исключительной надежностью, свойством, чрезвычайно ценимым программистами.<br>
<dd> Программное обеспечение, работающее с клавиатурой и дисплеем для этих окон, 
  эмулирующих терминал, ничем не отличается от программного обеспечения, использующегося 
  для настоящих терминалов. Поскольку эмуляторы этих терминалов пользуются такой 
  широкой популярностью, программное обеспечение для них сохраняет свое значение, 
  поэтому мы опишем его в следующих двух разделах.<br>
<dd> Терминалы с интерфейсом RS-232 являются алфавитно-цифровыми терминалами. 
  Это означает, что экран или окно отображает определенное количество строк текста. 
  Обычный размер такого окна составляет 25 строк по 80 символов. Хотя иногда такие 
  терминалы (и эмуляторы) поддерживают определенные специальные символы, в основном 
  они являются исключительно текстовыми.<br>
<dd> Поскольку как компьютеры, так и терминалы работают с целыми символами, но 
  вынуждены обмениваться битами по последовательной линии, были разработаны специальные 
  микросхемы для выполнения преобразований символов в последовательность битов 
  и обратно. Они называются <b>универсальными асинхронными приемопередатчиками</b> 
  (UART, Universal asynchronous receiver/transmitter). Микросхемы UART монтируются 
  на интерфейсных картах, вставляемых в разъем шины компьютера, как показано на 
  рис. 5.30. На многих компьютерах один или два последовательных порта встроены 
  в материнскую плату.<br>
<dd> Чтобы вывести символ на экран, драйвер терминала записывает этот символ в 
  интерфейсную карту, в которой она буферизируется, после чего поразрядно выдвигается 
  в последовательную линию универсальным асинхронным приемопередатчиком. Например, 
  для аналогового модема, работающего со скоростью 56 000 бит/с, для передачи 
  одного символа требуется немного более 179 мкс. Поскольку такая скорость передачи 
  низка, драйвер обычно передает один символ в интерфейсную карту RS-232. После 
  этого драйвер блокируется и ждет прерывания, которое инициирует интерфейс, передав 
  символ и перейдя в состояние готовности к приему следующего символа. Микросхема 
  UART способна одновременно передавать и принимать символы. Прерывание также 
  генерируется при получении символа, и обычно несколько принятых символов могут 
  сохраняться в буфере. Получив прерывание, драйвер терминала должен проверить 
  регистр, чтобы определить причину прерывания. Некоторые интерфейсные карты имеют 
  собственный процессор и память и могут одновременно поддерживать несколько линий, 
  разгружая тем самым центральный процессор.<br>
<dd> Терминалы с интерфейсом RS-232 могут быть разделены на три категории. Наиболее 
  простыми являются печатающие терминалы или телетайпы. Символы, набираемые на 
  клавиатуре, посылаются компьютеру. Символы, посланные компьютером, печатаются 
  на бумаге. Такие терминалы уже давно считаются устаревшими и почти не встречаются, 
  разве только в качестве примитивных принтеров.<br>
<dd> Примитивные электронно-лучевые терминалы работают похоже, но вместо бумаги 
  они выводят символы на экран. Их также называют &laquo;стеклянными телетайпами&raquo; 
  (glass ttys), поскольку функционально они аналогичны печатающим телетайпам. 
  Термин &laquo;tty&raquo; является сокращением слова Teletype<sup>&reg;</sup>, 
  означающего имя компании, бывшей пионером в области компьютерных терминалов. 
  Теперь сокращение &laquo;tty&raquo; используется для обозначения любого терминала. 
  Стеклянные телетайпы также устарели.<br>
<dd> Умные электронно-лучевые терминалы на самом деле представляют собой небольшие 
  специализированные компьютеры. У них есть процессор и память. Они также содержат 
  программное обеспечение, хранящееся, как правило, в ПЗУ. С точки зрения операционной 
  системы основное различие между стеклянным телетайпом и умным терминалом состоит 
  в том, что последний понимает управляющие последовательности символов, называемые 
  ESC-последовательностями. При помощи передачи такому терминалу символа ASCII 
  ESC (OxlB), за которым передается еще несколько других символов, можно управлять 
  выводом на экран терминала. Например, с помощью ESC-последовательности можно 
  переместить курсор на новую позицию, вывести текст в любое заданное место экрана, 
  очистить экран и т. д. Именно такие терминалы используются в системах мэйнфреймов 
  и эмулируются другими операционными системами. Ниже мы обсудим программное обеспечение 
  умных терминалов.<br>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Программное обеспечение ввода</font></b><br>
  <br>
  Клавиатура и дисплей являются почти независимыми устройствами, поэтому мы будем 
  рассматривать их здесь по отдельности. Однако они не совсем независимы, так 
  как вводимый с клавиатуры символ обычно выводится на экран.<br>
<dd> Основная работа клавиатурного драйвера состоит в сборе ввода с клавиатуры 
  и передаче его программам, читающим с терминала. Существует две философские 
  концепции, описывающие работу драйвера. Согласно первой концепции, работа драйвера 
  заключается в сборе ввода и передаче его программам безо всяких изменений. Программа, 
  читающая с терминала, получает необработанные последовательности ASCII-символов. 
  (Передавать программам пользователя коды клавиш неприемлемо, так как они в большой 
  степени зависят от конкретной машины.)<br>
<dd> Эта философия хорошо удовлетворяет потребности таких сложных текстовых редакторов, 
  как <i>emacs,</i> который позволяет пользователю связать любое действие с любым 
  символом или последовательностью символов. Однако это означает, что если пользователь 
  вместо <i>date</i> наберет на клавиатуре <i>dste, а</i> затем исправит ошибку, 
  удалив три последние символа и допечатав символы <i>ate,</i> за которыми нажмет 
  Enter, программа пользователя получит 11 следующих ASCII-символов:<br>
  <br>
<dd> <font face="Arial">dste &lt;- &lt;- &lt;- ateCR</font><br>
  <br>
<dd> Не всем программам нужны эти подробности. Чаще всего им нужна уже исправленная 
  строка, а не вся последовательность введенных символов. Таким образом, формируется 
  вторая философская концепция: драйвер выполняет все редактирование внутри строки, 
  а программе пользователя передает уже исправленную строку. Первая философская 
  концепция является символьно-ориентированной, вторая — строчно-ориентированной. 
  Изначально эти режимы работы драйвера назывались <b>режимом без обработки</b> 
  (или &laquo;сырым&raquo; режимом) и <b>режимом с обработкой.</b> В стандарте 
  POSIX режим с обработкой называется <b>каноническим режимом. Неканонический 
  режим</b> соответствует режиму без обработки, хотя многие детали поведения терминала 
  могут различаться. Совместимые со стандартом POSIX системы предоставляют несколько 
  библиотечных функций, поддерживающих выбор любого из этих двух режимов, а также 
  изменение многих аспектов конфигурации терминала.<br>
<dd> Основная задача клавиатурного драйвера состоит в сборе символов. Если каждое 
  нажатие на клавишу вызывает прерывание, драйвер может получать введенный символ 
  во время обработки прерывания. Если прерывания преобразуются низкоуровневым 
  программным обеспечением в сообщения, каждый полученный символ может помещаться 
  в сообщение. В качестве альтернативы символ может помещаться в небольшой буфер 
  в памяти, а сообщение использовать только для извещения драйвера о том, что 
  что-то прибыло. Второй подход более надежен, особенно если сообщение может быть 
  послано только ожидающему его процессу, а драйвер клавиатуры может оказаться 
  занятым обработкой предыдущего символа.<br>
<dd> Если терминал находится в каноническом режиме (режиме с обработкой), введенные 
  символы должны храниться в буфере до тех пор, пока не будет введена полная строка. 
  Даже если терминал находится в &laquo;сыром&raquo; режиме, может оказаться, 
  что программа еще не запрашивала входные данные, поэтому введенные символы все 
  равно должны буферизироваться, чтобы позволить пользователю производить упреждающий 
  ввод. (Разработчиков систем, не позволяющих пользователям вводить символы с 
  клавиатуры заранее, следует обмазывать дегтем и вываливать в перьях, так как 
  заставлять их пользоваться собственной системой было бы слишком жестоким наказанием.)<br>
<dd> Для буферизации символов обычно применяются два метода. В первом случае в 
  драйвере содержится центральный пул буферов, в каждом из которых хранится около 
  10 символов. С каждым терминалом связана структура данных, содержащая, среди 
  прочего, указатель на цепочку буферов, в которых находятся символы, введенные 
  с данного терминала. Чем больше символов введено, тем больше выделяется буферов, 
  соединенных в цепь. Когда символ передается программе пользователя, буферы удаляются 
  и память возвращается центральному пулу.<br>
<dd> Другой подход состоит в том, что буферизация производится прямо в структуре 
  данных терминала, без центрального пула буферов. Поскольку пользователи часто 
  печатают команду, обработка которой требует некоторого времени (например, перекомпиляция 
  и сборка большой двоичной программы), а затем печатают еще несколько строк, 
  буфер драйвера должен вмещать не меньше 200 символов для каждого терминала. 
  В крупной системе разделения времени с 100 терминалами постоянное выделение 
  20 Кбайт на буфер ввода с клавиатур кажется чрезмерным, поэтому центральный 
  пул буферов размера около 5 Кбайт будет, видимо, достаточным. С другой стороны, 
  при выделенном буфере для отдельного терминала драйвер становится проще (не 
  требуется управления связанным списком). Такой подход является предпочтительным 
  на персональном компьютере с единственной клавиатурой. Рисунок 5.31 иллюстрирует 
  разницу между этими двумя методами.<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_29.jpg" alt="Центральный пул буферов (а); выделенный буфер для каждого терминала (б)"><br>
    <br>
    <b><font face="Arial">Рис. 5.31.</font></b><font face="Arial"> Центральный 
    пул буферов (<i>а</i>); выделенный буфер для каждого терминала (<i>б</i>)</font><br>
  </center>
  <br>
<dd> Хотя клавиатура и дисплей являются логически раздельными устройствами, многие 
  пользователи привыкли видеть только что введенные с клавиатуры символы отображаемыми 
  на экране. Некоторые (старые) терминалы должны были автоматически (аппаратно) 
  отображать все, что вводилось с клавиатуры, что не только крайне неудобно при 
  вводе паролей, но также значительно ограничивает гибкость сложных редакторов 
  и других программ. К счастью, на большинстве терминалов при нажатии клавиши 
  ничего автоматически не отображается. Отображением символов на экране занимается 
  исключительно программное обеспечение. Этот процесс называется печатью эха или 
  эхопечатью.<br>
<dd> Печать эха усложняется тем фактом, что во время нажатия пользователем клавиши 
  программа может осуществлять вывод на экран. По меньшей мере, драйвер должен 
  решить, где поместить эхо так, чтобы оно не исчезло под <a href="../comment.html#09">выводом 
  программы</a>.<br>
<dd> Кроме того, если пользователь ввел более 80 символов в одной строке, вывод 
  эха на 80-символьном экране может осуществляться по-разному. В зависимости от 
  приложения переход на следующую строку может оказаться приемлемым либо неприемлемым. 
  Некоторые драйверы просто усекают все введенные строки до 80 символов, игнорируя 
  все символы после 80-й колонки.<br>
<dd> Еще одна <a href="../comment.html#10">проблема</a> заключается в обработке табуляторов. 
  Обычно драйвер вычисляет текущую позицию курсора, учитывая как вывод программы, 
  так и вывод эха ввода, после чего вычисляет число отображаемых вместо табулятора 
  пробелов.<br>
<dd> Наконец, существует проблема эквивалентности устройств. Логически в конце 
  строки текста требуется символ возврата каретки, чтобы переместить курсор обратно 
  к колонке 1, и символ перевода строки для перемещения курсора на следующую строку. 
  Требовать от пользователя вводить оба символа — вряд ли удачная мысль, хотя 
  на некоторых терминалах имеется специальная клавиша, посылающая оба символа 
  с 50-процентной вероятностью сделать это именно в том порядке, в котором их 
  ожидает программа. Преобразование всего, что поступает с клавиатуры в стандартный 
  внутренний формат, используемый операционной системой, является одной из задач 
  драйвера.<br>
<dd> Если стандартом предусматривается хранение только символов перевода строки 
  (соглашение UNIX), тогда символы возврата каретки должны преобразовываться в 
  символы перевода строки. Если внутренний формат предусматривает хранение обоих 
  символов (соглашение Windows), тогда драйвер должен формировать символ перевода 
  строки при получении символа возврата каретки и символ возврата каретки при 
  получении символа перевода строки. Независимо от внутренних соглашений, терминал 
  может требовать вывода обоих символов для корректного управления выводом на 
  экран. Поскольку к большому компьютеру могут оказаться подключенными терминалы 
  различных типов, драйвер клавиатуры должен заниматься преобразованием всех различных 
  комбинаций символа возврата каретки и символа перевода строки во внутренний 
  стандарт, а также следить за правильностью эхопечати.<br>
<dd> При работе в каноническом режиме некоторые вводимые символы имеют особое 
  значение. В табл. 5.4. показаны все специальные символы, требуемые стандартом 
  POSIX. По умолчанию все они являются управляющими символами, которые не должны 
  конфликтовать с вводимым текстом или кодами, используемыми программами. Однако 
  все символы, кроме последних двух, могут быть программно изменены.<br>
  <br>
  <center>
    <b><font face="Arial">Таблица 5.4.</font></b><font face="Arial"> Специальные 
    символы канонического режима</font><br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="649" HEIGHT="249">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="center" VALIGN="center" WIDTH="74" HEIGHT="36"> <b> Символ</b> 
        </TD>
        <TD ALIGN="center" VALIGN="center" WIDTH="115" HEIGHT="36"> <b> Имя в 
          POSIX</b> </TD>
        <TD ALIGN="center" VALIGN="center" WIDTH="354" HEIGHT="36"> <b> Комментарий</b> 
        </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="74" HEIGHT="26"> CTRL+H </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="115" HEIGHT="26"> ERASE </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="354" HEIGHT="26"> Удалить один символ 
          слева </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="74" HEIGHT="22"> CTRL+U </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="115" HEIGHT="22"> KILL </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="354" HEIGHT="22"> Удалить всю введенную 
          строку </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="74" HEIGHT="20"> CTRL+V </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="115" HEIGHT="20"> LNEXT </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="354" HEIGHT="20"> Интерпретировать 
          следующий символ буквально </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="74" HEIGHT="21"> CTRL+S </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="115" HEIGHT="21"> STOP </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="354" HEIGHT="21"> Остановить вывод 
        </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="74" HEIGHT="20"> CTRL+Q </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="115" HEIGHT="20"> START </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="354" HEIGHT="20"> Начать вывод </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="74" HEIGHT="22"> DEL </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="115" HEIGHT="22"> INTR </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="354" HEIGHT="22"> Прервать процесс 
          (SIGINT) </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="74" HEIGHT="21"> CTRL+\ </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="115" HEIGHT="21"> QUIT </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="354" HEIGHT="21"> Форсировать дамп 
          памяти (SIGQUIT) </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="74" HEIGHT="21"> CTRL+D </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="115" HEIGHT="21"> EOF </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="354" HEIGHT="21"> Конец файла </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="74" HEIGHT="20"> CTRL+M </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="115" HEIGHT="20"> CR </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="354" HEIGHT="20"> Возврат каретки 
          (неизменный) </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="74" HEIGHT="21"> CTRL+J </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="115" HEIGHT="21"> NL </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="354" HEIGHT="21"> Перевод строки 
          (неизменный) </TD>
      </TR>
    </TABLE>
  </center>
  <br>
<dd> Символ <i>ERASE</i> позволяет пользователю удалить один только что введенный 
  символ. Обычно для этого применяется клавиша &laquo;забой&raquo; (backspace) 
  или комбинация клавиш CTRL+H (обоим вариантам соответствует код 0x08). Этот 
  символ не добавляется к очереди символов, а, наоборот, удаляет предыдущий символ 
  из очереди. Печать эха для такого символа должна выглядеть как последовательность 
  трех символов: перемещение курсора на одну позицию влево, пробел и еще раз возврат 
  на одну позицию, чтобы удалить с экрана предыдущий символ. Если же предыдущим 
  символом был табулятор, его удаление зависит от того, как табулятор был отработан 
  при печати. Если он был преобразован в пробелы, то необходима дополнительная 
  информация о том, насколько далеко следует возвращать курсор. Если же сам табулятор 
  хранится в очереди ввода, он может быть удален, а вся строка напечатана еще 
  раз. В большинстве систем символ <i>ERASE </i> удаляет символы текущей строки. 
  Символы предыдущей строки и разделяющие строки символы возврата каретки или 
  перевода строки не удаляются.<br>
<dd> Если пользователь обнаруживал ошибку в начале введенной строки, то единственным 
  способом ее исправления во многих старых системах, не позволяющих перемещать 
  курсор по строке, являлось полное удаление всей строки. В этом случае бывало 
  удобнее воспользоваться специальным символом <i>KILL,</i> удалявшим всю строку 
  сразу. В некоторых системах эта строка полностью исчезала с экрана, но в некоторых 
  она оставалась на экране, включая возврат каретки и перевод строки, так как 
  многие пользователи любят видеть свою старую строку. Как и символ <i>ERASE,</i> 
  символ <i>KILL</i> работает только с текущей строкой. При удалении блока символов 
  драйвер может вернуть освободившиеся буферы в пул.<br>
<dd> Иногда символы <i>ERASE</i> или <i>KILL </i> должны быть введены в строку 
  как обычные данные. Для этого служит символ <i>LNEXT,</i> действующий в качестве 
  <b><a href="../comment.html#11">префиксного символа</a></b>. В системе UNIX для 
  этого по умолчанию используется сочетание клавиш CTRL+V (код 0x16). В более 
  старых системах UNIX в качестве символа <i>KILL </i> часто используется символ 
  @, но впоследствии этот символ стал использоваться в адресах электронной почты 
  сети Интернет, как, например, linda@cs.washington.edu. Те, кому привычнее старые 
  соглашения, могут переопределить символ <i>KILL</i> как @, но тогда им придется 
  вводить символ @ буквально при вводе адреса электронной почты. Это можно сделать, 
  нажав на клавиатуре последовательно клавиши CTRL+V и @. Сам символ <i>LNEXT</i> 
  может быть введен, если дважды нажать клавиши CTRL+V. Встретив символ <i>LNEXT,</i> 
  драйвер установит флаг, означающий, что следующий символ не следует подвергать 
  специальной обработке. Сам символ <i>LNEXT</i> не устанавливается в очередь 
  символов.<br>
<dd> Чтобы приостановить и продолжить вывод на экран, также предоставляются специальные 
  управляющие коды. В UNIX это символы <i>STOP</i> (CTRL+S) и <i>START</i> (CTRL+Q). 
  Эти символы не хранятся в буфере, но используются для установки и сброса флага 
  в структуре данных терминала. При каждой операции вывода на экран проверяется 
  значение этого флага. Если флаг установлен, вывод не производится. Эхо при этом 
  обычно также подавляется.<br>
<dd> Часто возникает необходимость прервать выполнение отлаживаемой программы. 
  Для этой цели могут использоваться символы <i>INTR</i> (DEL) и <i>QUIT</i> (CTRL+\). 
  В системе UNIX клавиша DEL посылает сигнал прерывания SIGINT всем процессам, 
  запущенным с этого терминала. Реализация может быть непростой. Наиболее сложным 
  является передача информации от драйвера в ту часть системы, которая занимается 
  обработкой сигналов, поскольку она не ожидает получения подобной информации. 
  Результат нажатия клавиш CTRL+\ (код 0x1С) аналогичен нажатию клавиши DEL, с 
  той разницей, что процессам посылается сигнал SIGQUIT, вызывающий прекращение 
  работы процесса с сохранением дампа памяти, если этот сигнал специально не перехватывается 
  процессом. При нажатии любой из этих клавиш драйвер должен вывести эхо в виде 
  перевода строки и возврата каретки, а также очистить свой буфер с накопленными 
  введенными символами, чтобы позволить начать новый ввод. Часто вместо клавиши 
  DEL для символа <i>INTR</i> по умолчанию используется сочетание клавиш CTRL+C 
  (код 0x03), так как с появлением электронно-лучевых дисплеев многие программы 
  стали использовать клавишу DEL для удаления символа справа от курсора при редактировании.<br>
<dd> Специальный символ <i>EOF</i> (CTRL+D), означающий конец файла в системе 
  UNIX, сообщает ожидающей ввода программе, что информации на входе больше не 
  будет. Программа действует так, как если бы при чтении из файла достигла его 
  конца.<br>
<dd> Некоторые драйверы терминала предоставляют возможность более сложного редактирования 
  строки, чем было описано здесь. Они имеют специальные управляющие символы, позволяющие 
  удалять целиком слова, перемещать курсор вперед и назад по символам и по словам, 
  вставлять текст в середину уже набранной строки и т. д. Добавление подобных 
  функций к драйверу значительно увеличивает его. Кроме того, эти функции чаще 
  всего оказываются неиспользуемыми экранными редакторами, предпочитающими работать 
  с драйверами клавиатуры в &laquo;сыром&raquo; режиме.<br>
  <br>
  <br>
<a NAME="03"></a>
  <b><font size="4">Программное обеспечение вывода</font></b><br>
  <br>
  Терминальный вывод несколько проще ввода. По большей части компьютер посылает 
  символы терминалу, который их отображает. Обычно блок символов, например строка, 
  записывается на терминал за один системный вызов. Как правило, метод, используемый 
  для терминалов с интерфейсом RS-232, состоит в том, что для каждого терминала 
  выделяется выходной буфер. Эти буферы могут входить в тот же пул буферов, что 
  и входные буферы, или представлять собой выделенные буферы. Вывод эха на терминал 
  также копируется в буфер. После того как символы помещены в выходной буфер, 
  первый символ выводится на терминал, после чего драйвер блокируется. Когда приходит 
  прерывание, извещающее драйвер о готовности терминала принять следующий символ, 
  посылается следующий символ и т. д.<br>
<dd> Экранным редакторам и другим сложным программам бывает нужно перерисовать 
  экран, заменив определенные участки экрана и не меняя остального текста. Для 
  этого многие терминалы поддерживают наборы управляющих команд, позволяющие перемещать 
  курсор, удалять строки и т. д. Эти команды часто реализуются в виде <b>ESC-последовательностей</b>, 
  то есть последовательностей символов, начинающихся с символа ESC (0x1В). Во 
  времена расцвета терминалов с интерфейсом RS-232 существовали сотни разновидностей 
  терминалов, у каждого из которых был свой набор ESC-последовательностей. В результате 
  было довольно сложно написать программное обеспечение, работающее более чем 
  на одном типе терминалов.<br>
<dd> В системе Berkley UNIX было предложено решение этой проблемы, заключающееся 
  в базе данных терминалов и называющееся <b>termcap.</b> Этот программный пакет 
  определял множество основных действий, таких как перемещение курсора на нужную 
  колонку и строку. Чтобы переместить курсор в определенное место, программа, 
  например текстовый редактор, формировала свою ESC-последователь-ность, которая 
  преобразовывалась в ESC-последовательность, соответствующую тому конкретному 
  терминалу, на который производился вывод. Таким образом, текстовый редактор 
  мог работать на любом терминале, включенном в базу данных termcap.<br>
<dd> В конце концов производители компьютеров и программного обеспечения осознали 
  необходимость стандартизации ESC-последовательностей, в результате чего был 
  разработан стандарт ANSI. Некоторые примеры ESC-последовательностей этого стандарта 
  приведены в табл. 5.5.<br>
  <br>
  <center>
    <b><font face="Arial">Таблица 5.5.</font></b><font face="Arial"> Некоторые 
    ESC-последовательности стандарта ANSI</font><br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="711" HEIGHT="361">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="center" VALIGN="center" WIDTH="95" HEIGHT="54"> <b> ESC- последовательность</b> 
        </TD>
        <TD ALIGN="center" VALIGN="center" WIDTH="496" HEIGHT="54"> <b> Значение</b> 
        </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95" HEIGHT="26"> ESC [nА </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="496" HEIGHT="26"> Переместить курсор 
          вверх на <I>п</I> строк </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95" HEIGHT="20"> ESC [nВ </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="496" HEIGHT="20"> Переместить курсор 
          вниз на <I>п</I> строк </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95" HEIGHT="22"> ESC [nС </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="496" HEIGHT="22"> Переместить курсор 
          вправо на <I>п</I> позиций </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95" HEIGHT="20"> ESC [nD </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="496" HEIGHT="20"> Переместить курсор 
          влево на <I>п</I> позиций </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95" HEIGHT="21"> ESC [m;nH </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="496" HEIGHT="21"> Переместить курсор 
          в позицию <I>(т, п)</I> </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95" HEIGHT="20"> ESC [sJ </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="496" HEIGHT="20"> Очистить экран 
          от курсора (0 до конца, 1 от начала, 2 весь) </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95" HEIGHT="21"> ESC [sK </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="496" HEIGHT="21"> Очистить строку 
          от курсора (0 до конца, 1 от начала, 2 всю) </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95" HEIGHT="20"> ESC [nL </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="496" HEIGHT="20"> Вставить <I>п</I> 
          строк у курсора </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95" HEIGHT="21"> ESC [nM </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="496" HEIGHT="21"> Удалить <I>п</I> 
          строк у курсора </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95" HEIGHT="21"> ESC [nP </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="496" HEIGHT="21"> Удалить <I>п</I> 
          символов у курсора </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95" HEIGHT="21"> ESC [n@ </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="496" HEIGHT="21"> Вставить п символов 
          у курсора </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95" HEIGHT="37"> ESC [nm </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="496" HEIGHT="37"> Разрешить выделение 
          текста (0 — нормальный, 4 — полужирный, 5 — мерцающий, 7 — инверсный) 
        </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="95" HEIGHT="36"> ESC M </TD>
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="496" HEIGHT="36"> Скроллинг экрана 
          в обратную сторону, если курсор находится в верхней строке </TD>
      </TR>
    </TABLE>
  </center>
  <br>
<dd> Рассмотрим, как эти ESC-последовательности могут использоваться текстовым 
  редактором. Предположим, пользователь дает редактору команду удалить строку 
  3, а затем закрыть промежуток между строками 2 и 4. Для этого редактор может 
  послать терминалу по последовательной линии следующую ESC-последовательность:<br>
  <br>
<dd> <font face="Arial">ESC [3;1H ESC [OK ESC [1M</font><br>
  <br>
<dd> (где пробелы используются только для разделения символов и не передаются 
  в линию). Эти последовательности перемещают курсор на начало строки 3, удаляют 
  всю строку, а затем сдвигают строки, начиная с четвертой, вверх на одну позицию. 
  Аналогичные ESC-последовательности могут использоваться для вставки в середину 
  текста. Подобным же образом добавляются и удаляются слова.<br>
</BODY>
</HTML>
