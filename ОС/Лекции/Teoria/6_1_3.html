<HTML>
<HEAD>
<TITLE>Межпроцессное взаимодействие</TITLE>
</HEAD>
<body>
  
<h1 align="center">Межпроцессное взаимодействие
</h1>
<p>Процессам часто бывает необходимо взаимодействовать между собой. Например, в 
  конвейере ядра выходные данные первого процесса должны передаваться второму 
  и т. д. по цепочке. Поэтому необходимо правильно организованное взаимодействие 
  между процессами, по возможности не использующее прерываний. В этом разделе 
  мы рассмотрим некоторые аспекты межпроцессного взаимодействия (IPC, interprocess 
  communication).<BR>
</p>
<p>Проблема разбивается на три пункта. Первый мы уже упомянули: передача информации 
  от одного процесса другому. Второй связан с контролем над деятельностью процессов: 
  как гарантировать, что два процесса не пересекутся в критических ситуациях (представьте 
  себе два процесса, каждый из которых пытается завладеть последним мегабайтом 
  памяти). Третий касается согласования действий процессов: если процесс <i>А</i> 
  должен поставлять данные, а процесс <i>В</i> выводить их на печать, то процесс 
  <i>В</i> должен подождать и не начинать печатать, пока не поступят данные от 
  процесса <i>А</i>. Мы рассмотрим все три случая в следующем подразделе.<BR>
</p>
<p>Важно понимать, что два из трех описанных пунктов в равной мере относятся 
  и к потокам. Первый — передача информации — в случае потоков проблемой не является, 
  поскольку у потоков общее адресное пространство (передача информации между потоками 
  с разным адресным пространством уже является проблемой передачи информации между 
  процессами). Остальные два с тем же успехом касаются потоков: те же проблемы, 
  и те же решения. Мы будем рассматривать эти ситуации в контексте процессов, 
  но имейте в виду, что эти же рассуждения применимы и для потоков.<BR>
  <br>
  <br>
<a NAME="01"></a>
  <B><font size="4">Состояние состязания</font></B><BR>
  <br>
  В некоторых операционных системах процессы, работающие совместно, могут сообща 
  использовать некое общее хранилище данных. Каждый из процессов может считывать 
  из общего хранилища данных и записывать туда информацию. Это хранилище представляет 
  собой участок в основной памяти (возможно, в структуре данных ядра) или файл 
  общего доступа. Местоположение совместно используемой памяти не влияет на суть 
  взаимодействия и возникающие проблемы. Рассмотрим межпроцессное взаимодействие 
  на простом, но очень распространенном примере: спулер печати. Если процессу 
  требуется вывести на печать файл, он помещает имя файла в специальный каталог 
  спулера. Другой процесс, демон печати, периодически проверяет наличие файлов, 
  которые нужно печатать, печатает файл и удаляет его имя из каталога.<BR>
</p>
<p>Представьте, что каталог спулера состоит из большого числа сегментов, пронумерованных 
  0, 1, 2,..., в каждом их которых может храниться имя файла. Также есть две совместно 
  используемые переменные: <i>out, </i>указывающая на следующий файл для печати, 
  и <i>in, </i>указывающая на следующий свободный сегмент. Эти две переменные 
  можно хранить в одном файле (состоящем из двух слов), доступном всем процессам. 
  Пусть в данный момент сегменты с 0 по 3 пусты (эти файлы уже напечатаны), а 
  сегменты с 4 по 6 заняты (эти файлы ждут своей очереди на печать). Более или 
  менее одновременно процессы <i>A </i>и<i> В </i>решают поставить файл в очередь 
  на печать. Описанная ситуация схематически изображена на рис. 2.14.<BR>
  
</p>
<center>
    <br>
    <img src="06/Tanenbaum_2_13.jpg" alt="Два процесса хотят одновременно получить доступ к совместно используемой памяти"><br>
    <br>
    <font face="Arial"><B>Рис. 2.14.</B> Два процесса хотят одновременно получить 
    доступ<br>
    к совместно используемой памяти</font><BR>
  </center>
  <br>
<p>В соответствии с законом Мерфи (он звучит примерно так: &laquo;Если что-то 
  плохое может случиться, оно непременно случится&raquo;) возможна следующая ситуация. 
  Процесс <i>А </i>считывает значение (7) переменной от и сохраняет его в локальной 
  переменной <i>next_free_slot. </i>После этого происходит прерывание по таймеру, 
  и процессор переключается на процесс <i>В. </i>Процесс <i>В, </i>в свою очередь, 
  считывает значение переменной <i>in </i>и сохраняет его (опять 7) в своей локальной 
  переменной <i>next_free_slot. </i>В данный момент оба процесса считают, что 
  следующий свободный сегмент -седьмой.<BR>
</p>
<p>Процесс <i>В </i>сохраняет в каталоге спулера имя файла и заменяет значение 
  от на 8, затем продолжает заниматься своими задачами, не связанными с печатью.<BR>
</p>
<p>Наконец управление переходит к процессу <i>А, </i>и он продолжает с того места, 
  на котором остановился. Он обращается к переменной <i>next_free_slot, </i>считывает 
  ее значение и записывает в седьмой сегмент имя файла (разумеется, удаляя при 
  этом имя файла, записанное туда процессом <i>В). </i>Затем он заменяет значение 
  <i>in </i>на 8 <i>(next_free_slot </i>+ 1 = 8). Структура каталога спулера не 
  нарушена, так что демон печати не заподозрит ничего плохого, но файл процесса 
  <i>В </i>не будет напечатан. Пользователь, связанный с процессом <i>В, </i>может 
  в этой ситуации полдня описывать круги вокруг принтера, ожидая требуемой распечатки. 
  Ситуации, в которых два (и более) процесса считывают или записывают данные одновременно 
  и конечный результат зависит от того, какой из них был первым, называются состояниями 
  состязания. Отладка программы, в которой возможно состояние состязания, вряд 
  ли может доставить удовольствие. Результаты большинства тестовых прогонов будут 
  хорошими, но изредка будет происходить нечто странное и необъяснимое.<BR>
  <br>
  <br>
<a NAME="02"></a>
  <B><font size="4">Критические области</font></B><BR>
  <br>
  Как избежать состязания? Основным способом предотвращения проблем в этой и любой 
  другой ситуации, связанной с совместным использованием памяти, файлов и чего-либо 
  еще, является запрет одновременной записи и чтения разделенных данных более 
  чем одним процессом. Говоря иными словами, необходимо взаимное исключение. Это 
  означает, что в тот момент, когда один процесс использует разделенные данные, 
  другому процессу это делать будет запрещено. Проблема, описанная в предыдущем 
  параграфе, возникла из-за того, что процесс <i>В </i>начал работу с одной из 
  совместно используемых переменных до того, как процесс <i>А </i>ее закончил. 
  Выбор подходящей примитивной операции, реализующей взаимное исключение, является 
  серьезным моментом разработки операционной системы, и мы рассмотрим его подробно 
  в дальнейшем.<BR>
</p>
<p>Проблему исключения состояний состязания можно сформулировать на абстрактном 
  уровне. Некоторый промежуток времени процесс занят внутренними расчетами и другими 
  задачами, не приводящими к состояниям состязания. В другие моменты времени процесс 
  обращается к совместно используемым данным или выполняет какое-то другое действие, 
  которое может привести к состязанию. Часть программы, в которой есть обращение 
  к совместно используемым данным, называется критической областью или критической 
  секцией. Если нам удастся избежать одновременного нахождения двух процессов 
  в критических областях, мы сможем избежать состязаний.<BR>
</p>
<p>Несмотря на то что это требование исключает состязание, его недостаточно для 
  правильной совместной работы параллельных процессов и эффективного использования 
  общих данных. Для этого необходимо выполнение четырех условий:<BR>
  <br>
</p>
<p>1. Два процесса не должны одновременно находиться в критических областях.<BR>
</p>
<p>2. В программе не должно быть предположений о скорости или количестве процессоров.<BR>
</p>
<p>3. Процесс, находящийся вне критической области, не может блокировать другие 
  процессы.<BR>
</p>
<p>4. Невозможна ситуация, в которой процесс вечно ждет попадания в критическую 
  область.<BR>
  <br>
</p>
<p>В абстрактном виде требуемое поведение процессов представлено на рис. 2.15. 
  Процесс <i>А </i>попадает в критическую область в момент времени <i>Т</i><SUB>1</SUB><i>. 
  </i>Чуть позже, в момент времени <i>Т<SUB>2</SUB>, </i>процесс <i>В </i>пытается 
  попасть в критическую область, но ему это не удается, поскольку в критической 
  области уже находится процесс <i>А, а </i>два процесса не должны одновременно 
  находиться в критических областях. Поэтому процесс <i>В </i>временно приостанавливается, 
  до наступления момента времени <i>Т<SUB>3</SUB>, </i>когда процесс <i>А </i>выходит 
  из критической области. В момент времени <i>Т<SUB>4</SUB> </i>процесс <i>В </i>также 
  покидает критическую область, и мы возвращаемся в исходное состояние, когда 
  ни одного процесса в критической области не было.<BR>
  
</p>
<center>
    <br>
    <img src="06/Tanenbaum_2_14.jpg" alt="Взаимное исключение с использованием критических областей"><br>
    <br>
    <font face="Arial"><B>Рис. 2.15.</B> Взаимное исключение с использованием 
    критических областей</font><BR>
  </center>
  <br>
  <br>
<a NAME="03"></a>
  <B><font size="4">Взаимное исключение с активным ожиданием</font></B><BR>
  <br>
  В этом разделе мы рассмотрим различные способы реализации взаимного исключения 
  с целью избежать вмешательства в критическую область одного процесса при нахождении 
  там другого и связанных с этим проблем.<BR>
  <br>
  <br>
  <B>Запрещение прерываний</B><BR>
  <br>
  Самое простое решение состоит в запрещении всех прерываний при входе процесса 
  в критическую область и разрешение прерываний по выходе из области. Если прерывания 
  запрещены, невозможно прерывание по таймеру. Поскольку процессор переключается 
  с одного процесса на другой только по прерыванию, отключение пре-рываний исключает 
  передачу процессора другому процессу. Таким образом, запретив прерывания, процесс 
  может спокойно считывать и сохранять совместно используемые данные, не опасаясь 
  вмешательства другого процесса.<BR>
<p>И все же было бы неразумно давать пользовательскому процессу возможность запрета 
  прерываний. Представьте себе, что процесс отключил все прерывания и в результате 
  какого-либо сбоя не включил их обратно. Операционная система на этом может закончить 
  свое существование. К тому же в многопроцессорной системе запрещение прерываний 
  повлияет только на тот процессор, который выполнит инструкцию disable. Остальные 
  процессоры продолжат работу и сохранят доступ к разделенным данным.<BR>
</p>
<p>С другой стороны, для ядра характерно запрещение прерываний для некоторых 
  команд при работе с переменными или списками. Возникновение прерывания в момент, 
  когда, например, список готовых процессов находится в неопределенном состоянии, 
  могло бы привести к состоянию состязания. Итак, запрет прерываний бывает полезным 
  в самой операционной системе, но это решение неприемлемо в качестве механизма 
  взаимного исключения для пользовательских процессов.<BR>
  <br>
  <br>
  <B>Переменные блокировки</B><BR>
  <br>
  Теперь попробуем найти программное решение. Рассмотрим одну совместно используемую 
  переменную блокировки, изначально равную 0. Если процесс хочет попасть в критическую 
  область, он предварительно считывает значение переменной блокировки. Если переменная 
  равна 0, процесс изменяет ее на 1 и входит в критическую область. Если же переменная 
  равна 1, то процесс ждет, пока ее значение сменится на 0. Таким образом, 0 означает, 
  что ни одного процесса в критической области нет, а 1 означает, что какой-либо 
  процесс находится в критической области.<BR>
</p>
<p>К сожалению, у этого метода те же проблемы, что и в примере с каталогом спулера. 
  Представьте, что один процесс считывает переменную блокировки, обнаруживает, 
  что она равна 0, но прежде, чем он успевает изменить ее на 1, управление получает 
  другой процесс, успешно изменяющий ее на 1. Когда первый процесс снова получит 
  управление, он тоже заменит переменную блокировки на 1 и два процесса одновременно 
  окажутся в критических областях.<BR>
</p>
<p>Можно подумать, что проблема решается повторной проверкой значения переменной, 
  прежде чем заменить ее, но это не так. Второй процесс может получить управление 
  как раз после того, как первый процесс закончил вторую проверку, но еще не заменил 
  значение переменной блокировки.<BR>
  <br>
  <br>
  <B>Строгое чередование</B><BR>
  <br>
  Третий метод реализации взаимного исключения иллюстрирован на рис. 2.16. Этот 
  фрагмент программного кода, как и многие другие в этой книге, написан на С. 
  Язык С был выбран, поскольку практически все существующие операционные системы 
  написаны на С (или C++), а не на Java, Modula 3, Pascal и т. п. Язык С обладает 
  всеми необходимыми свойствами для написания операционных систем: это мощный, 
  эффективный и предсказуемый язык программирования. Язык Java, например, не является 
  предсказуемым, поскольку у программы, написанной на нем, может в критический 
  момент закончиться свободная память и она вызовет &laquo;сборщика мусора&raquo; 
  в исключительно неподходящее время. В случае С это невозможно, поскольку в С 
  процедура &laquo;сбора мусора&raquo; в принципе отсутствует. Сравнительный анализ 
  С, C++, Java и еще четырех языков представлен в [268].<BR>
  
</p>
<center>
    <br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="689" HEIGHT="181">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD width="391" height="179"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="309" HEIGHT="63">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD width="399" height="61"> while(TRUE)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{while(turn!=0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                &nbsp;&nbsp;&nbsp;/*loop*/;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; critical_region();<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; turn=l;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; noncritical_region<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</TD>
            </TR>
          </TABLE>
          <br>
          <br>
          <br>
          <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            <i>а</i></p>
        </TD>
        <TD width="357" height="179"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="355" HEIGHT="99">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD width="390" height="97"> while(TRUE)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{while(turn!=0)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                /*loop*/;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; critical_region ();<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(page_not_in_cache(&amp;page))<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; turn=0;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return_page(&amp;page);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; noncritical_region 
                ();<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} </TD>
            </TR>
          </TABLE>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>б</i> 
        </TD>
      </TR>
    </TABLE>
    <br>
    <font face="Arial"><B>Рис. 2.16. </B>Предлагаемое решение проблемы критической 
    области: процесс 0 (а);<BR>
    процесс 1 (б). В обоих случаях необходимо удостовериться в наличии точки<BR>
    с запятой, ограничивающей цикл while</font><BR>
  </center>
  <br>
<p>На рис. 2.16 целая переменная <i>turn, </i>изначально равная 0, отслеживает, 
  чья очередь входить в критическую область. Вначале процесс 0 проверяет значение 
  <i>turn, </i>считывает 0 и входит в критическую область. Процесс 1 также проверяет 
  значение <i>turn, </i>считывает 0 и после этого входит в цикл, непрерывно проверяя, 
  когда же значение <i>turn </i>будет равно 1. Постоянная проверка значения переменной 
  в ожидании некоторого значения называется активным ожиданием. Подобного способа 
  следует избегать, поскольку он является бесцельной тратой времени процессора. 
  Активное ожидание используется только в случае, когда есть уверенность в небольшом 
  времени ожидания. Блокировка, использующая активное ожидание, называется спин-блокировкой.<BR>
</p>
<p>Когда процесс 0 покидает критическую область, он изменяет значение <i>turn 
  </i>на 1, позволяя процессу 1 попасть в критическую область. Предположим, что 
  процесс 1 быстро покидает свою критическую область, так что оба процесса теперь 
  находятся вне критической области, и значение <i>turn </i>равно 0. Теперь процесс 
  0 выполняет весь цикл быстро, выходит из критической области и устанавливает 
  значение <i>turn </i>равным 1. В этот момент значение <i>turn </i>равно 1, и 
  оба процесса находятся вне критической области.<BR>
</p>
<p>Неожиданно процесс 0 завершает работу вне критической области и возвращается 
  к началу цикла. Но войти в критическую область он не может, поскольку значение 
  <i>turn </i>равно 1 и процесс 1 находится вне критической области. Процесс 0 
  зависнет в своем цикле while, ожидая, пока процесс 1 изменит значение turn на 
  0. Получается, что метод поочередного доступа к критической области не слишком 
  удачен, если один процесс существенно медленнее другого.<BR>
</p>
<p>Эта ситуация нарушает третье из сформулированных нами условий: один процесс 
  блокирован другим, не находящимся в критической области. Возвратимся к примеру 
  с каталогом спулера: если заменить критическую область процедурой считывания 
  и записи в каталог спулера, процесс 0 не сможет послать файл на печать, поскольку 
  процесс 1 занят чем-то другим.<BR>
</p>
<p>Фактически этот метод требует, чтобы два процесса попадали в критические области 
  строго по очереди. Ни один из них не сможет попасть в критическую область (например, 
  послать файл на печать) два раза подряд. Хотя этот алгоритм и исключает состояния 
  состязания, его нельзя рассматривать всерьез, поскольку он нарушает третье условие 
  успешной работы двух параллельных процессов с совместно используемыми данными.<BR>
  <br>
  <br>
  <B>Алгоритм Петерсона</B><BR>
  <br>
  Датский математик Деккер (Т. Dekker) был первым, кто разработал программное 
  решение проблемы взаимного исключения, не требующее строгого чередования. Подробное 
  изложение алгоритма можно найти в [46].<BR>
</p>
<p>В 1981 году Петерсон (G. L. Peterson) разработал существенно более простой 
  алгоритм взаимного исключения. С этого момента алгоритм Деккера стал считаться 
  устаревшим. Алгоритм Петерсона, представленный в листинге 2.1, состоит из двух 
  процедур, написанных на ANSI С, что предполагает необходимость прототипов для 
  всех определяемых и используемых функций. В целях экономии места мы не будем 
  приводить прототипы для этого и последующих примеров.<BR>
  
</p>
<center>
    <br>
    <font face="Arial"><B>Листинг 2.1.</B> Решение Петерсона для взаимного исключения</font><BR>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" width="747">
      <TR> 
        <TD width="743"> #define FALSE 0<br>
          #define TRUE 1<br>
          #define N 2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Количество 
          процессов */<br>
          int turn;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Чья сейчас 
          очередь? */<br>
          int interested[N];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 
          Все переменные изначально равны 0 (FALSE) */<br>
          void enter region(int process)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 
          Процесс 0 или 1 */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{int other: /* Номер 
          второго процесса */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; other = 1 - process;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 
          Противоположный процесс */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; interested[process] 
          = TRUE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Индикатор 
          интереса*/<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; turn = process;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 
          Установка флага*/<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (turn == process 
          &amp;&amp; interested[other] — TRUE)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 
          Пустой оператор */;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
          void leave region(int process)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 
          process; процесс, покидающий критическую область */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{interested[process] 
          = FALSE;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* Индикатор 
          выхода из критической области*/<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} </TD>
      </TR>
    </TABLE>
  </center>
  <br>
<p>Прежде чем обратиться к совместно используемым переменным (то есть перед тем, 
  как войти в критическую область), процесс вызывает процедуру <i>enter_region 
  </i>со своим номером (0 или 1) в качестве параметра. Поэтому процессу при необходимости 
  придется подождать, прежде чем входить в критическую область. После выхода из 
  критической области процесс вызывает процедуру <i>leave_region, </i>чтобы обозначить 
  свой выход и тем самым разрешить другому процессу вход в критическую область.<BR>
</p>
<p>Рассмотрим работу алгоритма более подробно. Исходно оба процесса находятся 
  вне критических областей. Процесс 0 вызывает <i>enter_region, </i>задает элементы 
  массива и устанавливает переменную <i>turn </i>равной 0. Поскольку процесс 1 
  не заинтересован в попадании в критическую область, процедура возвращается. 
  Теперь, если процесс 1 вызовет <i>enter_region, </i>ему придется подождать, 
  пока <i>interested </i>[0] примет значение <i>FALSE, а </i>это произойдет только 
  в тот момент, когда процесс 0 вызовет процедуру <i>leave_region, </i>чтобы покинуть 
  критическую область.<BR>
</p>
<p>Представьте, что оба процесса вызвали <i>enter_region </i>практически одновременно. 
  Оба сохранят свои номера в <i>turn. </i>Сохранится номер того процесса, который 
  был вторым, а предыдущий номер будет утерян. Предположим, что вторым был процесс 
  1, так что значение <i>turn </i>равно 1. Когда оба процесса дойдут до оператора 
  while, процесс 0 войдет в критическую область, а процесс 1 останется в цикле 
  и будет ждать, пока процесс 0 выйдет из критической области.<BR>
  <br>
  <br>
  <B>Команда TSL</B><BR>
  <br>
  Рассмотрим решение, требующее участия аппаратного обеспечения. Многие компьютеры, 
  особенно разработанные с расчетом на несколько процессоров, имеют команду<BR>
  <br>
  <font face="Arial">TSL RX.LOCK</font><BR>
  <br>
  (Test and Set Lock — проверить и заблокировать), которая действует следующим 
  образом. В регистр RX считывается содержимое слова памяти <i>lock, а </i>в ячейке 
  памяти <i>lock </i>сохраняется некоторое ненулевое значение. Гарантируется, 
  что операция считывания слова и сохранения неделима — другой процесс не может 
  обратиться к слову в памяти, пока команда не выполнена. Процессор, выполняющий 
  команду TSL, блокирует шину памяти, чтобы остальные процессоры не могли обратиться 
  к памяти.<BR>
</p>
<p>Воспользуемся командой TSL. Пусть совместно используемая переменная <i>lock 
  </i>управляет доступом к разделенной памяти. Если значение переменной <i>lock 
  </i>равно 0, любой процесс может изменить его на 1 и обратиться к разделенной 
  памяти, и затем изменить его обратно на 0, пользуясь обычной командой move.<BR>
</p>
<p>Как использовать эту команду для взаимного исключения? Решение приведено в 
  листинге 2.2. Здесь представлена подпрограмма из четырех команд, написанная 
  на фиктивном (но типичном) ассемблере. Первая команда копирует старое значение 
  <i>lock в </i>регистр и затем устанавливает значение переменной равное 1. Потом 
  старое значение сравнивается с нулем. Если оно ненулевое, значит, блокировка 
  уже была установлена и проверка начинается сначала. Рано или поздно значение 
  окажется нулевым (это означает, что процесс, находившийся в критической области, 
  вышел из нее), и подпрограмма возвращается, установив блокировку. Программа 
  просто помещает 0 в переменную <i>lock. </i>Специальной команды процессора не 
  требуется.<BR>
  
</p>
<center>
    <br>
    <font face="Arial"><B>Листинг 2.2.</B> Вход и выход из критической области 
    с помощью команды TSL</font><BR>
    <br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" width="775">
      <TR> 
        <TD> enter_region:<br>
          TSL REGISTER,LOCK &nbsp;&nbsp; | значение lock копируется в регистр, 
          значение переменной<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          | устанавливается равным 1<br>
          CMP REGISTER,#0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp; | Старое 
          значение lock сравнивается с нулем JNE enter_region<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          | Если оно ненулевое, значит, блокировка уже была установлена,<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          | поэтому цикл завершается RET<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          | Возврат к вызывающей программе, процесс в критической области<br>
          leave_region;<br>
          MOVE LOCK,#O&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; &nbsp;&nbsp; 
          | Сохранение 0 в переменной lock<br>
          RET </TD>
      </TR>
    </TABLE>
  </center>
  <br>
<p>Одно решение проблемы критических областей теперь очевидно. Прежде чем попасть 
  в критическую область, процесс вызывает процедуру <i>enter_region, </i>которая 
  выполняет активное ожидание вплоть до снятия блокировки, затем она устанавливает 
  блокировку и возвращается. По выходе из критической области процесс вызывает 
  процедуру <i>leave_region, </i>помещающую 0 в переменную <i>lock. </i>Как и 
  во всех остальных решениях проблемы критической области, для корректной работы 
  процесс должен вызывать эти процедуры своевременно, в противном случае взаимное 
  исключение не удастся.<BR>
  <br>
  <br>
<a NAME="04"></a>
  <B><font size="4">Примитивы межпроцессного взаимодействия</font></B><BR>
  <br>
  Оба решения — Петерсона и с использованием команды TSL — корректны, но они обладают 
  одним и тем же недостатком: использованием активного ожидания. В сущности, оба 
  они реализуют следующий алгоритм: перед входом в критическую область процесс 
  проверяет, можно ли это сделать. Если нельзя, процесс входит в тугой цикл, ожидая 
  возможности войти в критическую область.<BR>
</p>
<p>Этот алгоритм не только бесцельно расходует время процессора, но, кроме этого, 
  он может иметь некоторые неожиданные последствия. Рассмотрим два процесса: Я, 
  с высоким приоритетом, и <i>L, с </i>низким приоритетом. Правила планирования 
  в этом случае таковы, что процесс Я запускается немедленно, как только он оказывается 
  в состоянии ожидания. В какой-то момент, когда процесс <i>L </i>находится в 
  критической области, процесс Я оказывается в состоянии ожидания (например, он 
  закончил операцию ввода-вывода). Процесс Я попадает в состояние активного ожидания, 
  но поскольку процессу <i>L</i> во время работающего процесса Я никогда не будет 
  предоставлено процессорное время, у процесса <i>L</i> не будет возможности выйти 
  из критической области, и процесс Я навсегда останется в цикле. Эту ситуацию 
  иногда называют проблемой инверсии приоритета.<BR>
</p>
<p>Теперь рассмотрим некоторые примитивы межпроцессного взаимодействия, применяющиеся 
  вместо циклов ожидания, в которых лишь напрасно расходуется процессорное время. 
  Эти примитивы блокируют процессы в случае запрета на вход в критическую область. 
  Одной из простейших является пара примитивов sleep и wakeup. Примитив sleep 
  — системный запрос, в результате которого вызывающий процесс блокируется, пока 
  его не запустит другой процесс. У запроса wakeup есть один параметр — процесс, 
  который следует запустить. Также возможно наличие одного параметра у обоих запросов 
  — адреса ячейки памяти, используемой для согласования запросов ожидания и запуска.<BR>
  <br>
  <br>
  <B>Проблема производителя и потребителя</B><BR>
  <br>
  В качестве примера использования этих примитивов рассмотрим проблему производителя 
  и потребителя, также известную как проблема ограниченного буфера. Два процесса 
  совместно используют буфер ограниченного размера. Один из них, производитель, 
  помещает данные в этот буфер, а другой, потребитель, считывает их оттуда. (Можно 
  обобщить задачу на случай <i>т </i>производителей и <i>п </i>потребителей, но 
  мы рассмотрим случай с одним производителем и одним потребителем, поскольку 
  это существенно упрощает решение.)<BR>
</p>
<p>Трудности начинаются в тот момент, когда производитель хочет поместить в буфер 
  очередную порцию данных и обнаруживает, что буфер полон. Для производителя решением 
  является ожидание, пока потребитель полностью или частично не очистит буфер. 
  Аналогично, если потребитель хочет забрать данные из буфера, а буфер пуст, потребитель 
  уходит в состояние ожидания и выходит из него, как только производитель положит 
  что-нибудь в буфер и разбудит его.<BR>
</p>
<p>Это решение кажется достаточно простым, но оно приводит к состояниям состязания, 
  как и пример с каталогом спулера. Нам нужна переменная <i>count </i>для отслеживания 
  количества элементов в буфере. Если максимальное число элементов, хранящихся 
  в буфере, равно <i>N, </i>программа производителя должна проверить, не равно 
  ли <i>N</i> значение <i>count </i>прежде, чем поместить в буфер следующую порцию 
  данных. Если значение <i>count </i>равно <i>N, </i>то производитель уходит в 
  состояние ожидания; в противном случае производитель помещает данные в буфер 
  и увеличивает значение <i>count.</i><BR>
</p>
<p>Код программы потребителя прост: сначала проверить, не равно ли значение <i>count 
  </i>нулю. Если равно, то уйти в состояние ожидания; иначе забрать порцию данных 
  из буфера и уменьшить значение <i>count. </i>Каждый из процессов также должен 
  проверять, не следует ли активизировать другой процесс, и в случае необходимости 
  проделывать это. Программы обоих процессов представлены в листинге 2.3.<BR>
  
</p>
<center>
    <br>
    <font face="Arial"><B>Листинг 2.3.</B> Проблема производителя и потребителя 
    с неустранимым состоянием соревнования</font><BR>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" width="752">
      <TR> 
        <TD width="748"> #define N 100 /* Максимальное количество элементов в 
          буфере */<br>
          int count = 0; /* Текущее количество элементов в буфере */<br>
          void producer(void)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {int item;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (TRUE) /* Повторять 
          вечно */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {item = produce_item( ); /* Сформировать следующий элемент */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          if (count = = N) sleep( ); /* Если буфер полон, уйти в состояние ожидания 
          */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          insert_item(item); /* Поместить элемент в буфер */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          count = count + 1; /* Увеличить количество элементов в буфере */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          if (count = = 1) wakeup(consumer); /* Был ли буфер пуст? */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          void consumer(void)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {int item;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (TRUE) /* Повторять 
          вечно */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {if (count == 0) sleep( ); /* Если буфер пуст, уйти в состояние ожидания 
          */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          item = remove_item( ); /* Забрать элемент из буфера */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          count = count - 1; /* Уменьшить счетчик элементов в&nbsp;буфере */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          if (count == N - 1) wakeup(producer); /* Был ли буфер полон? */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          consume_item(item); /* Отправить элемент на печать */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </TD>
      </TR>
    </TABLE>
    <br>
  </center>
<p align="center">Для описания на языке С системных вызовов sleep и wakeup мы представили их 
  в виде вызовов библиотечных процедур. В стандартной библиотеке С их нет, но 
  они будут доступны в любой системе, в которой присутствуют такие системные вызовы. 
  Процедуры <i>insert_item </i>и <i>remove_item </i>помещают элементы в буфер 
  и извлекают их оттуда.<BR>
</p>
<p align="center">Теперь давайте вернемся к состоянию состязания. Его возникновение возможно, 
  поскольку доступ к переменной <i>count </i>не ограничен. Может возникнуть следующая 
  ситуация: буфер пуст, и потребитель только что считал значение переменной <i>count, 
  </i>чтобы проверить, не равно ли оно нулю. В этот момент планировщик передал 
  управление производителю, производитель поместил элемент в буфер и увеличил 
  значение <i>count, </i>проверив, что теперь оно стало равно 1. Зная, что перед 
  этим оно было равно 0 и потребитель находился в состоянии ожидания, производитель 
  активизирует его с помощью вызова <i>wakeup.</i><BR>
</p>
<p align="center">Но потребитель не был в состоянии ожидания, так что сигнал активизации пропал 
  впустую. Когда управление перейдет к потребителю, он вернется к считанному когда-то 
  значению <i>count, </i>обнаружит, что оно равно 0, и уйдет в состояние ожидания. 
  Рано или поздно производитель наполнит буфер и также уйдет в состояние ожидания. 
  Оба процесса так и останутся в этом состоянии.<BR>
</p>
<p align="center">Суть проблемы в данном случае состоит в том, что сигнал активизации, пришедший 
  к процессу, не находящемуся в состоянии ожидания, пропадает. Если бы не это, 
  проблемы бы не было. Быстрым решением может быть добавление бита <B>ожидания 
  активизации. </B>Если сигнал активизации послан процессу, не находящемуся в 
  состоянии ожидания, этот бит устанавливается. Позже, когда процесс пытается 
  уйти в состояние ожидания, бит ожидания активизации сбрасывается, но процесс 
  остается активным. Этот бит исполняет роль копилки сигналов активизации.<BR>
</p>
<p align="center">Несмотря на то что введение бита ожидания запуска спасло положение в этом 
  примере, легко сконструировать ситуацию с несколькими процессами, в которой 
  одного бита будет недостаточно. Мы можем добавить еще один бит, или 8, или 32, 
  но это не решит проблему.<BR>
  <br>
  <br>
<a NAME="05"></a>
  <B><font size="4">Семафоры</font></B><BR>
  <br>
  В 1965 году Дейкстра (Е. W. Dijkstra) предложил использовать целую переменную 
  для подсчета сигналов запуска, сохраненных на будущее [96]. Им был предложен 
  новый тип переменных, так называемые семафоры, значение которых может быть нулем 
  (в случае отсутствия сохраненных сигналов активизации) или некоторым положительным 
  числом, соответствующим количеству отложенных активизирующих сигналов.<BR>
</p>
<p align="left">Дейкстра предложил две операции, down и up (обобщения sleep и wakeup). Операция 
  down сравнивает значение семафора с нулем. Если значение семафора больше нуля, 
  операция down уменьшает его (то есть расходует один из сохраненных сигналов 
  активации) и просто возвращает управление. Если значение семафора равно нулю, 
  процедура down не возвращает управление процессу, а процесс переводится в состояние 
  <i>ожидания. Все операции проверки значения семафора, его изменения </i>и перевода 
  процесса в состояние ожидания выполняются как единое и неделимое <B>элементарное 
  действие. </B>Тем самым гарантируется, что после начала операции ни один процесс 
  не получит доступа к семафору до окончания или блокирования операции. Элементарность 
  операции чрезвычайно важна для разрешения проблемы синхронизации и предотвращения 
  состояния состязания.<BR>
</p>
<p align="left">Операция up увеличивает значение семафора. Если с этим семафором связаны один 
  или несколько ожидающих процессов, которые не могут завершить более раннюю операцию 
  down, один из них выбирается системой (например, случайным образом) и ему разрешается 
  завершить свою операцию down. Таким образом, после операции up, примененной 
  к семафору, связанному с несколькими ожидающими процессами, значение семафора 
  так и останется равным 0, но число ожидающих процессов уменьшится на единицу. 
  Операция увеличения значения семафора и активизации процесса тоже неделима. 
  Ни один процесс не может быть блокирован во время выполнения операции up, как 
  ни один процесс не мог быть блокирован во время выполнения операции wakeup в 
  предыдущей модели.<BR>
</p>
<p align="left">В оригинале Дейкстра использовал вместо down и up обозначения Р и V соответственно. 
  Мы не будем в дальнейшем использовать оригинальные обозначения, поскольку тем, 
  кто не знает датского языка, эти обозначения ничего не говорят (да и тем, кто 
  знает язык, говорят немного). Впервые обозначения down и up появились в языке 
  Algol 68.<BR>
  <br>
  <br>
  <B>Решение проблемы производителя и потребителя с помощью семафоров</B><BR>
  <br>
  Как показано в листинге 2.4, проблему потерянных сигналов запуска можно решить 
  с помощью семафоров. Очень важно, чтобы они были реализованы неделимым образом. 
  Стандартным способом является реализация операций down и up в виде системных 
  запросов, с запретом операционной системой всех прерываний на период проверки 
  семафора, изменения его значения и возможного перевода процесса в состояние 
  ожидания. Поскольку для выполнения всех этих действий требуется всего лишь несколько 
  команд процессора, запрет прерываний не приносит никакого вреда. Если используются 
  несколько процессоров, каждый семафор необходимо защитить переменной блокировки 
  с использованием команды TSL, чтобы гарантировать одновременное обращение к 
  семафору только одного процессора. Необходимо понимать, что использование команды 
  TSL принципиально отличается от активного ожидания, при котором производитель 
  или потребитель ждут наполнения или опустошения буфера. Операция с семафором 
  займет несколько микросекунд, тогда как активное ожидание может затянуться на 
  существенно больший промежуток времени.<BR>
  
</p>
<center>
    <br>
    <font face="Arial"><B>Листинг 2.4.</B> Проблема производителя и потребителя 
    с семафорами</font><BR>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" width="669">
      <TR> 
        <TD width="665"> #define N 100&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          /* количество сегментов в буфере */<br>
          typedef int semaphore; /* семафоры - особый вид целочисленных переменных 
          */<br>
          semaphore mutex = 1;&nbsp; /* контроль доступа в критическую область 
          */<br>
          semaphore empty = N; /* число пустых сегментов буфера */<br>
          semaphore full = 0;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; /* число полных 
          сегментов буфера */<br>
          void producer(void)<br>
          &nbsp;&nbsp;&nbsp;&nbsp; {Int item;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (TRUE)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {/* TRUE - константа, равная 1*/<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          item = produce_item(); /* создать данные, помещаемые в буфер */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          down(&amp; empty); /* уменьшить счетчик пустых сегментов буфера */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          down(&amp; mutex); /* вход в критическую область */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          insert_item(item); /* поместить в буфер новый элемент */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          up(&amp;mutex): /* выход из критической области */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          up(&amp;full); /* увеличить счетчик полных сегментов буфера */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp; }<br>
          void consumer(void)<br>
          &nbsp;&nbsp;&nbsp;&nbsp; {int item;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (TRUE)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          { /* бесконечный цикл */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          down(&amp; full); /* уменьшить числа полных сегментов буфера */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          down(&amp; mutex); /* вход в критическую область */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          item = remove_item(); /* удалить элемент из буфера */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          up(&amp; mutex); /* выход из критической области */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          up(&amp; empty); /* увеличить счетчик пустых сегментов буфера */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          consume_item(item); /* обработка элемента */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp; } </TD>
      </TR>
    </TABLE>
    <br>
  </center>
<p align="left">В представленном решении используются три семафора: один для подсчета заполненных 
  сегментов буфера <i>(full), </i>другой для подсчета пустых сегментов <i>(empty), 
  </i>а третий предназначен для исключения одновременного доступа к буферу производителя 
  и потребителя <i>(mutex). </i>Значение счетчика <i>full </i>исходно равно нулю, 
  счетчик <i>empty </i>равен числу сегментов в буфере, a <i>mutex </i>равен 1. 
  Семафоры, исходное значение которых равно 1, используемые для исключения одновременного 
  нахождения в критической области двух процессов, называются <B>двоичными семафорами. 
  </B>Взаимное исключение обеспечивается, если каждый процесс выполняет операцию 
  down перед входом в критическую область и up после выхода из нее.<BR>
</p>
<p align="left">Теперь, когда у нас есть примитивы межпроцессного взаимодействия, вернемся 
  к последовательности прерываний, показанной в табл. 2.2. В системах, использующих 
  семафоры, естественным способом скрыть прерывание будет связать с каждым устройством 
  ввода-вывода семафор, исходно равный нулю. Сразу после запуска устройства ввода-вывода 
  управляющий процесс выполняет операцию down на соответствующем семафоре, тем 
  самым входя в состояние блокировки. В случае прерывания обработчик прерывания 
  выполняет up на соответствующем семафоре, переводя процесс в состояние готовности. 
  В такой модели пятый шаг в табл. 2.2 заключается в выполнении up на семафоре 
  устройства, чтобы следующим шагом планировщик смог запустить программу, управляющую 
  устройством. Разумеется, если в этот момент несколько процессов находятся в 
  состоянии готовности, планировщик может выбрать другой, более значимый процесс. 
  Мы рассмотрим некоторые алгоритмы планирования позже в этой главе.<BR>
</p>
<p align="left">В примере, представленном в листинге 2.4, семафоры использовались двумя различными 
  способами. Это различие достаточно значимо, чтобы сказать о нем особо. Семафор 
  <i>mutex </i>используется для реализации взаимного исключения, то есть для исключения 
  одновременного обращения к буферу и связанным переменным двух процессов. Мы 
  рассмотрим взаимное исключения и методы его реализации в следующем разделе.<BR>
</p>
<p align="left">Остальные семафоры использовались для <B>синхронизации. </B>Семафоры <i>full 
  </i>и <i>empty </i>необходимы, чтобы гарантировать, что определенные последовательности 
  событий происходят или не происходят. В нашем случае они гарантируют, что производитель 
  прекращает работу, когда буфер полон, а потребитель прекращает работу, когда 
  буфер пуст.<BR>
  <br>
  <br>
<a NAME="06"></a>
  <B><font size="4">Мьютексы</font></B><BR>
  <br>
  Иногда используется упрощенная версия семафора, называемая мьютексом (mutex, 
  сокращение от mutual exclusion — взаимное исключение). Мьютекс не способен считать, 
  он может лишь управлять взаимным исключением доступа к совместно используемым 
  ресурсам или кодам. Реализация мьютекса проста и эффективна, что делает использование 
  мьютексов особенно полезным в случае потоков, действующих только в пространстве 
  пользователя.<BR>
</p>
<p align="left"><B>Мьютекс </B>— переменная, которая может находиться в одном из двух состояний: 
  блокированном или неблокированном. Поэтому для описания мьютекса требуется всего 
  один бит, хотя чаще используется целая переменная, у которой 0 означает неблокированное 
  состояние, а все остальные значения соответствуют блокированному состоянию. 
  Значение мьютекса устанавливается двумя процедурами. Если поток (или процесс) 
  собирается войти в критическую область, он вызывает процедуру <i>mutex_lock. 
  </i>Если мьютекс не заблокирован (то есть вход в критическую область разрешен), 
  запрос выполняется и вызывающий поток может попасть в критическую область.<BR>
</p>
<p align="left">Напротив, если мьютекс заблокирован, вызывающий поток блокируется до тех пор, 
  пока другой поток, находящийся к критической области, не выйдет из нее, вызвав 
  процедуру <i>mutex_unlock. </i>Если мьютекс блокирует несколько потоков, то 
  из них случайным образом выбирается один.<BR>
</p>
<p align="left">Мьютексы легко реализовать в пользовательском пространстве, если доступна 
  команда TSL. Код программы для процедур <i>mutex_lock </i>и <i>mutex_unlock 
  </i>в случае потоков на уровне пользователя представлен в листинге 2.5.<BR>
  
</p>
<center>
    <br>
    <font face="Arial"><B>Листинг 2.5.</B> Реализация mutex_lock и mutex_unlock</font><BR>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" width="735">
      <TR> 
        <TD width="731"> mutex lock:<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; TSL REGISTER,MUTEX&nbsp;&nbsp;&nbsp; 
          | Старое значение мьютекса копируется в регистр;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          | устанавливается новое значение 1<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CMP REGISTER,#0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          | Сравнение старого значения с нулем<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JZE ok&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          | Если старое = 0, мьютекс не был блокирован. Возврат<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; CALL thread_yield&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          | Мьютекс занят, управление передается другому потоку<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; JMP mutex_lock&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          &nbsp; | Повторить попытку позже<br>
          ok: RET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          | Возврат, вход в критическую область<br>
          mutex_unlock:<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MOVE MUTEX,#0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          &nbsp;&nbsp;&nbsp; | Устанавливается значение мьютекса 0<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; RET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          | Возврат </TD>
      </TR>
    </TABLE>
    <br>
  </center>
<p align="left">Процедура <i>mutex_lock </i>похожа на процедуру <i>enter_region </i>в листинге 
  2.2, но с одним существенным отличием. Если процедуре <i>enter_region </i>не 
  удается войти в критическую область, она продолжает в цикле проверять наличие 
  блокировки (активное ожидание). В конце концов время, отведенное этому процессу, 
  кончается и планировщик передает управление другому процессу. Раньше или позже 
  процесс, заблокировавший вход в критическую область, освобождает его.<BR>
</p>
<p align="left">В случае потоков ситуация кардинально меняется, поскольку нет прерываний по 
  таймеру, останавливающих слишком долго работающие потоки. Поток, пытающийся 
  получить доступ к семафору и находящийся в состоянии активного ожидания, зациклится 
  навсегда, поскольку он не позволит предоставить процессор другому потоку, желающему 
  снять блокировку.<BR>
</p>
<p align="left">В этой ситуации <i>mutex_lock ведет себя по-другому. Если </i>войти в критическую 
  область невозможно, <i>mutex_lock </i>вызовет <i>thread_yeld, </i>чтобы предоставить 
  процессор другому потоку. Активного ожидания здесь нет. При следующем запуске 
  поток снова проверит блокировку.<BR>
</p>
<p align="left">Поскольку вызов <i>thread_yeld </i>является всего лишь обращением к планировщику 
  потоков в пространстве пользователя, он выполняется очень быстро. Следовательно, 
  ни <i>mutex_lock, </i>ни <i>mutex_unlock </i>не требуют обращений к ядру. Синхронизация 
  потоков на уровне пользователя происходит полностью в пространстве пользователя, 
  с применением процедур, состоящих всего из нескольких команд процессора.<BR>
</p>
<p align="left">Система мьютексов, которую мы только что рассмотрели, является только скелетом 
  набора запросов. Программное обеспечение часто требует реализации разнообразных 
  возможностей, и примитивы синхронизации не являются исключением. Например, в 
  некоторых реализациях пакета потоков поставляется вызов <i>mutex_trylock, </i>который 
  либо предоставляет доступ к критической области, либо возвращает код ошибки, 
  но в любом случае мгновенно возвращает управление, то есть не заставляет поток 
  ждать. Этот запрос дает потоку возможность выбора в случае наличия альтернативы 
  простому ожиданию.<BR>
</p>
<p align="left">Одну тему мы до сих пор обходили стороной, хотя стоило бы по крайней мере 
  прояснить ее. В случае потоков в пользовательском пространстве нет проблемы 
  доступа потоков к мьютексу, поскольку у всех потоков общее адресное пространство. 
  Тем не менее в большинстве предыдущих моделей, в частности в алгоритме Петерсона 
  и семафорах, молчаливо предполагалось, что несколько процессов имеют доступ 
  к совместно используемому участку памяти, пусть содержащему одно слово. Если 
  адресные пространства процессов несовместны, как мы постоянно утверждали, как 
  они могут совместно использовать переменную <i>turn </i>в алгоритме Петерсона, 
  или семафоры, или общий буфер?<BR>
</p>
<p align="left">На этот вопрос существует два ответа. Во-первых, некоторые из совместно используемых 
  структур данных, скажем, семафоры, могут храниться в ядре с доступом только 
  через системные запросы. Этот подход решает проблему. Во-вторых, большинство 
  современных операционных систем (включая UNIX и Windows) предоставляют возможность 
  совместного использования процессами некоторой части адресного пространства. 
  В этом случае возможно разделение буфера и других структур данных. В крайнем 
  случае, можно совместно использовать файл.<BR>
</p>
<p align="left">Если два или больше процессов разделяют частично или полностью адресные пространства, 
  различие между процессами и потоками частично размывается, но тем не менее все 
  равно остается. Два процесса с общим адресным пространством все равно обладают 
  разными открытыми файлами, аварийными таймерами и прочими характеристиками, 
  присущими процессам, в то время как два потока, разделяющие адресное пространство, 
  разделяют и все остальное. И в любом случае несколько процессов, совместно использующих 
  адресное пространство, никогда не будут столь же эффективны, как потоки на уровне 
  пользователя, поскольку управление потоками всегда происходит через ядро.<BR>
  <br>
  <br>
<a NAME="07"></a>
  <B><font size="4">Мониторы</font></B><BR>
  <br>
  Межпроцессное взаимодействие с применением семафоров выглядит довольно просто, 
  не правда ли? Эта простота кажущаяся. Взгляните внимательнее на порядок выполнения 
  процедур down перед помещением или удалением элементов из буфера в листинге 
  2.4. Представьте себе, что две процедуры down в программе производителя поменялись 
  местами, так что значение <i>mutex </i>было уменьшено раньше, чем <i>empty. 
  </i>Если буфер был заполнен, производитель блокируется, установив <i>mutex </i>на 
  0. Соответственно, в следующий раз, когда потребитель обратится к буферу, он 
  выполнит down с переменной <i>mutex, </i>равной 0, и тоже заблокируется. Оба 
  процесса заблокированы навсегда. Эта неприятная ситуация называется взаимоблокировкой, 
  и мы вернемся к ней в главе 3.<BR>
</p>
<p align="left">Вышеизложенная ситуация показывает, с какой аккуратностью нужно обращаться 
  с семафорами. Одна маленькая ошибка, и все останавливается. Это напоминает программирование 
  на ассемблере, но на самом деле еще сложнее, поскольку такие ошибки приводят 
  к абсолютно невоспроизводимым и непредсказуемым состояниям состязания, взаимоблокировкам 
  и т. п.<BR>
</p>
<p align="left">Чтобы упростить написание программ, в 1974 году Хоар (Ноаге) [155] и Бринч 
  Хансен (Brinch Hansen) [43] предложили примитив синхронизации более высокого 
  уровня, называемый монитором. Их предложения несколько отличались друг от друга, 
  как мы увидим дальше. Монитор — набор процедур, переменных и других структур 
  данных, объединенных в особый модуль или пакет. Процессы могут вызывать процедуры 
  монитора, но у процедур, объявленных вне монитора, нет прямого доступа к внутренним 
  структурам данных монитора. В листинге 2.6 представлен монитор, написанный на 
  воображаемом языке Pidgin Pascal.<BR>
  
</p>
<center>
    <br>
    <font face="Arial"><B>Листинг 2.6.</B> Монитор</font><BR>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" width="264">
      <TR> 
        <TD width="260"> monitor example<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; integer 
          i;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; condition 
          с;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure 
          producer();<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end:<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; procedure 
          consumer();<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; .<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; end;<br>
          end monitor; </TD>
      </TR>
    </TABLE>
    <br>
  </center>
<p align="left">Реализации взаимных исключений способствует важное свойство монитора: при 
  обращении к монитору в любой момент времени активным может быть только один 
  процесс. Мониторы являются структурным компонентом языка программирования, поэтому 
  компилятор знает, что обрабатывать вызовы процедур монитора следует иначе, чем 
  вызовы остальных процедур. Обычно при вызове процедуры монитора первые несколько 
  команд процедуры проверяют, нет ли в мониторе активного процесса. Если активный 
  процесс есть, вызывающему процессу придется подождать, в противном случае запрос 
  удовлетворяется.<BR>
</p>
<p align="left">Реализация взаимного исключения зависит от компилятора, но обычно используется 
  мьютекс или бинарный семафор. Поскольку взаимное исключение обеспечивает компилятор, 
  а не программист, вероятность ошибки гораздо меньше. В любом случае программист, 
  пишущий код монитора, не должен задумываться о том, как компилятор организует 
  взаимное исключение. Достаточно знать, что, обеспечив попадание в критические 
  области через процедуры монитора, можно не бояться попадания в критическую область 
  двух процессов одновременно.<BR>
</p>
<p align="left">Хотя мониторы предоставляют простой способ реализации взаимного исключения, 
  этого недостаточно. Необходим также способ блокировки процессов, которые не 
  могут продолжать свою деятельность. В случае проблемы производителя и потребителя 
  достаточно просто поместить все проверки буфера на заполненность и пустоту в 
  процедуры монитора, но как процесс заблокируется, обнаружив полный буфер?<BR>
</p>
<p align="left">Решение заключается во введении переменных состояния и двух операций, wait 
  и signal. Когда процедура монитора обнаруживает, что она не в состоянии продолжать 
  работу (например, производитель выясняет, что буфер заполнен), она выполняет 
  операцию wait на какой-либо переменной состояния, скажем<i>, full. </i>Это приводит 
  к блокировке вызывающего процесса и позволяет другому процессу войти в монитор.<BR>
</p>
<p align="left">Другой процесс, в нашем примере потребитель может активизировать ожидающего 
  напарника, например, выполнив операцию signal на той переменной состояния, на 
  которой он был заблокирован. Чтобы в мониторе не оказалось двух активных процессов 
  одновременно, нам необходимо правило, определяющее последствия операции signal. 
  Xoap предложил запуск &laquo;разбуженного&raquo; процесса и остановку второго. 
  Бринч Хансен предложил другое решение: процесс, выполнивший signal, должен немедленно 
  покинуть монитор. Иными словами, операция signal выполняется только в самом 
  конце процедуры монитора. Мы будем использовать это решение, поскольку оно в 
  принципе проще и к тому же легче в реализации. Если операция signal выполнена 
  на переменной, с которой связаны несколько заблокированных процессов, планировщик 
  выбирает и &laquo;оживляет&raquo; только один из них.<BR>
</p>
<p align="left">Кроме этого, существует третье решение, не основывающееся на предположениях 
  Хоара и Бринча Хансена: позволить процессу, выполнившему signal, продолжать 
  работу и запустить ждущий процесс только после того, как первый процесс покинет 
  монитор.<BR>
</p>
<p align="left">Переменные состояния не являются счетчиками. В отличие от семафоров они не 
  аккумулируют сигналы, чтобы впоследствии воспользоваться ими. Это означает, 
  что в случае выполнения операции signal на переменной состояния, с которой не 
  связано ни одного блокированного процесса, сигнал будет утерян. Проще говоря, 
  операция wait должна выполняться прежде, чем signal. Это правило существенно 
  упрощает реализацию. На практике это правило не создает проблем, поскольку отслеживать 
  состояния процессов при необходимости не очень трудно. Процесс, который собирается 
  выполнить signal, может оценить необходимость этого действия по значениям переменных.<BR>
</p>
<p align="left">В листинге 2.7 представлена схема решения проблемы производителя и потребителя 
  с применением мониторов, написанная на воображаемом языке Pidgin Pascal. В данной 
  ситуации этот язык удобен своей простотой, а также тем, что он позволяет в точности 
  следовать модели Хоара и Бринча Хансена. В каждый момент времени активна только 
  одна процедура монитора. Буфер состоит из <B>N</B> сегментов.<BR>
  
</p>
<center>
    <br>
    <font face="Arial"><B>Листинг 2.7. </B>Схема решения проблемы производителя 
    и потребителя с применением мониторов</font><BR>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" width="412">
      <TR> 
        <TD width="408"> monitor ProducerConsumer<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          condition full, empty;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          integer count;<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          procedure insert(item: integer);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          begin<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          if count = N then wait(full);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          insert_item(item);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          count := count+1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          if count = 1 then signal(empty)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          end;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          function remove: integer;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          begin<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          if count = 0 then wait(empty);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          remove = remove_item;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          count := count-1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          if count = N-1 then signal(full)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          end;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          count := 0;<br>
          end monitor;<br>
          <br>
          procedure producer;<br>
          begin<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          while true do<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          begin<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          item = produce_item;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          ProducerConsumer.insert(item)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          end<br>
          end;<br>
          <br>
          procedure consumer;<br>
          begin<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          while true do<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          begin<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          item = ProducerConsumer.remove;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          consume_item(item)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          end<br>
          end; </TD>
      </TR>
    </TABLE>
    <br>
  </center>
<p align="left">Можно подумать, что операции wait и signal похожи на sleep и wakeup, которые 
  приводили к неустранимым состояниям соревнования. Они действительно похожи, 
  но с одним существенным отличием: неудачи применения операций sleep и wakeup 
  были связаны с тем, что один процесс пытался уйти в состояние ожидания, в то 
  время как другой процесс пытался активировать его. С мониторами такого произойти 
  не может. Автоматическое взаимное исключение, реализуемое процедурами монитора, 
  гарантирует: если производитель, находящийся в мониторе, обнаружит полный буфер 
  и решит выполнить операцию wait, можно не опасаться, что планировщик передаст 
  управление потребителю раньше, чем операция wait будет завершена. Потребитель 
  даже не сможет попасть в монитор, пока операция wait не будет выполнена и производитель 
  не прекратит работу.<BR>
</p>
<p align="left">Несмотря на то что Pidgin Pascal — воображаемый язык, существует несколько 
  языков программирования, поддерживающих мониторы, хотя и не всегда в соответствии 
  с моделью Хоара и Бринча Хансена. Один из таких языков — Java, объектно-ориентированный 
  язык, поддерживающий потоки на уровне пользователя и позволяющий группировать 
  методы (процедуры) в классы. Добавление в описание метода ключевого слова synchronized 
  гарантирует, что если хотя бы один поток начал выполнение этого метода, ни один 
  другой поток не сможет выполнять другой синхронизированный (определенный как 
  synchronized) метод из этого класса.<BR>
</p>
<p align="left">Решение проблемы производителя и потребителя с использованием мониторов, написанное 
  на Java, представлено в листинге 2.8. Решение состоит из четырех классов. Внешний 
  класс, <i>ProducerConsumer, </i>создает и запускает два потока, <i>p</i> и <i>c</i>. 
  Второй и третий классы, <i>producer и consumer соответственно, </i>содержат 
  программы производителя и потребителя. Класс <i>out_monitor </i>является монитором. 
  Он содержит два синхронизированных потока, используемых для текущего помещения 
  элементов в буфер и извлечения их оттуда. В отличие от предыдущих примеров, 
  здесь приведен полный текст программ <i>insert </i>и <i>remove.</i><BR>
  
</p>
<center>
    <br>
    <font face="Arial"><B>Листинг 2.8. </B>Решение проблемы производителя и потребителя 
    на Java</font><BR>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" width="709">
      <TR> 
        <TD width="705"> public class ProducerConsumer<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {static final int N 
          = 100; // константа, задающая размер буфера<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static producer 
          p = new producer( ); // создать экземпляр потока производителя<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static consumer 
          с = new consumer( ); // создать экземпляр потока потребителя<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static our_monitor 
          mon = new our_monitor( ); // создать экземпляр монитора<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; public static 
          void main(String args[])<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {p.start( ); // запуск потока производителя<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          c.start( ); // запуск потока потребителя<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static class 
          producer extends Thread<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {public void run( ) // метод run содержит программу потока<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {int item;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          while (true) // цикл производителя<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {item = produce_item( );<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          mon.insert(item);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          private int produce_item( ) { ... } // собственно производство<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static class 
          consumer extends Thread<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {public void run( ) // метод run содержит программу потока<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {int item:<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          while (true) // цикл потребителя<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {item = mon.remove( );<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          consume_item (item);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          private void consume_item(int item) { ... } // собственно потребление<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; static class 
          our_monitor // монитор<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {private int buffer[] = new int[N];<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          private int count = 0, lo = 0, his 0; // счетчики и индексы<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          public synchronized void insert(int val)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {if (count == N) go_to_sleep( ); // если буфер полон, уйти в<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;//состояние 
          ожидания<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          buffer [hi] = val; // поместить элемент в буфер<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          hi = (hi+1)%N;&nbsp; // следующий сегмент, в который<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          //&nbsp;будет помещен элемент<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          count = count+1; // теперь в буфере на один элемент больше<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          if (count == 1) notify( ); // если потребитель в состоянии<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
          ожидания, активировать его<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          public synchronized int remove( )<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {int val;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          if (count == 0) go_to_sleep( );<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
          если буфер пуст, уйти в состояние ожидания<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          val - buffer [lo]; // забрать элемент из буфера<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          lо = (1о+1)%N; // следующий сегмент, из которого заберут элемент<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          count = count -1; // теперь в буфере на один элемент меньше<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          if (count == N-1) notify( );<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;// 
          если производитель в состоянии ожидания, активировать его<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          return val;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          private void go_to_sleep( )<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {try{wait( );}catch(InterruptedException exc) {};<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </TD>
      </TR>
    </TABLE>
    <br>
  </center>
<p align="left">Потоки производителя и потребителя функционально идентичны соответствующим 
  частям программы предыдущих примеров. В программе производителя есть бесконечный 
  цикл формирования данных и помещения их в общий буфер. В коде потребителя есть 
  бесконечный цикл с изъятием данных из общего буфера и их обработкой.<BR>
</p>
<p align="left">Интерес для нас представляет класс <i>our_monitor, </i>содержащий буфер, переменные 
  администрирования и два метода синхронизации. Когда производитель активен в 
  процедуре <i>insert, </i>потребитель не может быть активным в процедуре <i>remove, 
  </i>что исключает состояние состязания. Переменная <i>count </i>отслеживает 
  количество элементов в буфере, принимая значения от 0 до <i>N</i> - 1. Переменная 
  <i>lo </i>является индексом следующего сегмента буфера, из которого следует 
  извлечь данные. Переменная <i>hi </i>является индексом следующего сегмента буфера, 
  в который следует поместить данные. Разрешена ситуация, в которой <i>lо</i> 
  = <i>hi, </i>что означает 0 или <i>N </i>элементов в буфере. Различать эти два 
  случая можно по переменной <i>count.</i><BR>
</p>
<p align="left">Синхронизированные методы в языке Java отличаются от стандартных мониторов 
  отсутствием переменных состояния. Взамен предлагаются две процедуры, <i>wait 
  </i>и <i>notify, </i>которые аналогичны sleep и wakeup с той лишь разницей, 
  что они используются в синхронизированных методах, а это исключает состояния 
  состязания. Теоретически процедура может быть прервана, для чего и служит весь 
  окружающий ее набор программ. Java требует, чтобы исключения обрабатывались 
  явно. В нашем случае просто представьте, что <i>go_to_sleep </i>описывает уход 
  в состояние ожидания.<BR>
</p>
<p align="left">Благодаря автоматизации взаимного исключения применение мониторов сделало 
  параллельное программирование значительно менее подверженным ошибкам, чем применение 
  семафоров. Но и у мониторов тоже есть свои недостатки.<BR>
</p>
<p align="left">Недаром два примера мониторов, которые мы рассмотрели, были написаны на Pidgin 
  Pascal и Java, а не на С, как все остальные примеры этой книги. Как мы уже говорили, 
  мониторы являются структурным компонентом языка программирования, и компилятор 
  должен их распознавать и организовывать взаимное исключение. В Pascal, С и многих 
  других языках нет мониторов, поэтому странно было бы ожидать от их компиляторов 
  выполнения правил взаимного исключения. И в самом деле, как может отличить компилятор 
  процедуры монитора от остальных?<BR>
</p>
<p align="left">В этих языках также нет и семафоров, но их легко добавить: нужно всего лишь 
  присоединить к библиотеке две короткие программы, написанные на ассемблере и 
  реализующие системные вызовы up и down. Компиляторы при этом не обязаны знать 
  об их существовании. Разумеется, операционная система должна знать о семафорах, 
  но даже если у вас операционная система с семафорами, вы можете писать программы 
  для нее на С или C++ (или на ассемблере, если вы склонны к мазохизму). Если 
  же у вас операционная система с мониторами, вам необходим язык со встроенными 
  мониторами.<BR>
</p>
<p align="left">Другая проблема, связанная с мониторами и семафорами, состоит в том, что они 
  были разработаны для решения задачи взаимного исключения в системе с одним или 
  несколькими процессорами, имеющими доступ к общей памяти. Помещение семафоров 
  в разделенную память с защитой в виде команд TSL может исключить состояния состязания. 
  Эти примитивы будут неприменимы в распределенной системе, состоящей из нескольких 
  процессоров с собственной памятью у каждого, связанных локальной сетью. Вывод 
  из всего вышесказанного следующий: семафоры являются примитивами слишком низкого 
  уровня, а мониторы могут использоваться только в некоторых языках программирования. 
  Примитивы не подходят и для реализации обмена информацией между компьютерами 
  — нужно что-то другое.<BR>
  <br>
  <br>
<a NAME="08"></a>
  <B><font size="4">Передача сообщений</font></B><BR>
  <br>
  В роли чего-то другого выступает передача сообщений. Этот метод межпроцессного 
  взаимодействия использует два примитива: send и recei ve, которые скорее являются 
  системными вызовами, чем структурными компонентами языка (что отличает их от 
  мониторов и делает похожим на семафоры). Поэтому их легко можно поместить в 
  библиотечные процедуры, например<BR>
  <br>
  <font face="Arial">send(destination, &amp;message);<br>
  receive(source, &amp;message);<br>
  </font><br>
</p>
<p align="left">Первый запрос посылает сообщение заданному адресату, а второй получает сообщение 
  от указанного источника (или от любого источника, если это не имеет значения). 
  Если сообщения нет, второй запрос блокируется до поступления сообщения либо 
  немедленно возвращает код ошибки.<BR>
  <br>
  <br>
  <B>Разработка систем передачи сообщений</B><BR>
  <br>
  С системами передачи сообщений связано большое количество сложных проблем и 
  конструктивных вопросов, которых не возникает в случае семафоров и мониторов. 
  Особенно много сложностей появляется в случае взаимодействия процессов, происходящих 
  на различных компьютерах, соединенных сетью. Так, сообщение может потеряться 
  в сети. Чтобы избежать потери сообщений, отправитель и получатель договариваются, 
  что при получении сообщения получатель посылает обратно подтверждение приема 
  сообщения. Если отправитель не получает подтверждения через некоторое время, 
  он отсылает сообщение еще раз.<BR>
</p>
<p align="left">Теперь представим, что сообщение получено, но подтверждение до отправителя 
  не дошло. Отправитель пошлет сообщение еще раз, и до получателя оно дойдет дважды. 
  Крайне важно, чтобы получатель мог отличить копию предыдущего сообщения от нового. 
  Обычно проблема решается с помощью помещения порядкового номера сообщения в 
  тело самого сообщения. Если к получателю приходит письмо с номером, совпадающим 
  с номером предыдущего письма, письмо классифицируется как копия и игнорируется. 
  Решение проблемы успешного обмена информации в условиях ненадежной передачи 
  сообщений составляет основу изучения компьютерных сетей. Информацию по этой 
  теме можно найти в [323].<BR>
</p>
<p align="left">Для систем обмена сообщениями также важен вопрос названий процессов. Необходимо 
  однозначно определять процесс, указанный в запросе send или receive. Кроме того, 
  встает вопрос аутентификации: каким образом клиент может определить, что он 
  взаимодействует с настоящим файловым сервером, а не с самозванцем?<BR>
</p>
<p align="left">Помимо этого, существуют конструктивные проблемы, существенные при расположении 
  отправителя и получателя на одном компьютере. Одной из таких проблем является 
  производительность. Копирование сообщений из одного процесса в другой происходит 
  гораздо медленнее, чем операция на семафоре или вход в монитор. Было проведено 
  множество исследований с целью увеличения эффективности передачи сообщений. 
  В [65], например, предлагалось ограничивать размер сообщения до размеров регистра 
  и передавать сообщения через регистры.<BR>
  <br>
  <br>
  <B>Решение проблемы производителя и потребителя с передачей сообщений</B><BR>
  <br>
  Теперь рассмотрим решение проблемы производителя и потребителя с передачей сообщений 
  и без использования разделенной памяти. Решение представлено в листинге 2.9. 
  Мы предполагаем, что все сообщения имеют одинаковый размер и сообщения, которые 
  посланы, но еще не получены, автоматически помещаются операционной системой 
  в буфер. В этом решении используются <i>N </i>сообщений, по аналогии с <i>N 
  </i>сегментами в буфере. Потребитель начинает с того, что посылает производителю 
  <i>N </i>пустых сообщений. Как только у производителя оказывается элемент данных, 
  который он может предоставить потребителю, он берет пустое сообщение и отсылает 
  назад полное. Таким образом, общее число сообщений в системе постоянно и их 
  можно хранить в заранее заданном участке памяти.<BR>
</p>
<p align="left">Если производитель работает быстрее, чем потребитель, все сообщения будут 
  ожидать потребителя в заполненном виде. При этом производитель блокируется в 
  ожидании пустого сообщения. Если потребитель работает быстрее, ситуация инвертируется: 
  все сообщения будут пустыми, а потребитель будет блокирован в ожидании полного 
  сообщения.<BR>
  
</p>
<center>
    <br>
    <font face="Arial"><B>Листинг 2.9. </B>Решение проблемы производителя и потребителя 
    с использованием N сообщений</font><BR>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" width="709">
      <TR> 
        <TD width="705"> #define N 100 /* количество сегментов в буфере */<br>
          void producer(void)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {int item;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message m; /* буфер для сообщений 
          */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (TRUE)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {item = produce_item( ); /* сформировать нечто, чтобы заполнить буфер 
          */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          receive(consumer, &amp;m); /* ожидание прибытия пустого сообщения */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          build_message(&amp;m, item); /* сформировать сообщение для отправки */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          send(consumer, &amp;m); /* отослать элемент потребителю */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
          void consumer(void)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {int item, i;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; message m;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for (i = 0; i &lt; N; i++) send(producer, 
          &amp;m); /* отослать N пустых сообщений */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (TRUE)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {receive(producer, &amp;m); /* получить сообщение с элементом */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          item = extract_item(&amp;m); /* извлечь элемент из сообщения */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          send(producer, &amp;m); /* отослать пустое сообщение */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          consume_item(item); /* обработка элемента */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </TD>
      </TR>
    </TABLE>
    <br>
  </center>
<p align="left">Передача сообщений может быть реализована по-разному. Рассмотрим способ адресации 
  сообщений. Можно присвоить каждому из процессов уникальный адрес и адресовать 
  сообщение непосредственно процессам. Другой подход состоит в использовании новой 
  структуры данных, называемой <B>почтовым ящиком</B>. Почтовый ящик — это буфер 
  для определенного количества сообщений, тип которых задается при создании ящика. 
  При использовании почтовых ящиков в качестве параметров адреса send и receive 
  задаются почтовые ящики, а не процессы. Если процесс пытается послать сообщение 
  в полный почтовый ящик, ему приходится подождать, пока хотя бы одно сообщение 
  не будет удалено из ящика.<BR>
</p>
<p align="left">В задаче производителя и потребителя оба они создадут почтовые ящики, достаточно 
  большие, чтобы хранить <i>N</i> сообщений. Производитель будет посылать сообщения 
  с данными в почтовый ящик потребителя, а потребитель будет посылать пустые сообщения 
  в почтовый ящик производителя. С использованием почтовых ящиков метод буферизации 
  очевиден: в почтовом ящике получателя хранятся сообщения, которые были посланы 
  процессу-получателю, но еще не получены.<BR>
</p>
<p align="left">Другим предельным случаем использования почтовых ящиков является принципиальное 
  отсутствие буферизации. При таком подходе, если send выполняется раньше, чем 
  receive, посылающий процесс блокируется до выполнения receive, когда сообщение 
  может быть напрямую скопировано от отправителя к получателю без промежуточной 
  буферизации. Если receive выполняется раньше, чем send, получающий процесс блокируется 
  до выполнения send. Этот метод часто называется рандеву, он легче реализуется, 
  чем схема буферизации сообщений, но менее гибок, поскольку отправитель и получатель 
  должны работать в режиме жесткой синхронизации.<BR>
</p>
<p align="left">Передача сообщений часто используется в системах с параллельным программированием. 
  Характерным примером системы передачи сообщений является <B>MPI </B>(Message-Passing 
  Interface — интерфейс передачи сообщений). Более подробную информацию по этому 
  вопросу можно найти в [139, 308].<BR>
  <br>
  <br>
<a NAME="09"></a>
  <B><font size="4">Барьеры</font></B><BR>
  <br>
  Последний из рассмотренных нами механизмов синхронизации предназначался скорее 
  для групп процессов, нежели для ситуаций с двумя процессами типа производитель—потребитель. 
  Некоторые приложения делятся на фазы, и существует правило, что процесс не может 
  перейти в следующую фазу, пока к этому не готовы все остальные процессы. Этого 
  можно добиться, разместив в конце каждой фазы <B>барьер.</B> Когда процесс доходит 
  до барьера, он блокируется, пока все процессы не дойдут до барьера. Действие 
  барьера представлено на рис. 2.17.<BR>
  
</p>
<center>
    <br>
    <img src="06/Tanenbaum_2_15.jpg" alt="Применение барьеров"><br>
    <br>
    <font face="Arial"><B>Рис. 2.17.</B> Применение барьеров: процессы, приближающиеся 
    к барьеру (а); все процессы,<BR>
    кроме одного, блокированы барьером (б); как только последний процесс достигает 
    барьера,<BR>
    все процессы переходят в следующую фазу (в)</font><BR>
  </center>
  <br>
<p>На рис. 2.17, а представлены четыре процесса, приближающиеся к барьеру. Это 
  означает, что они заняты вычислениями и еще не дошли до конца фазы. Через некоторое 
  время первый процесс завершает вычисления, предусмотренные в этой фазе. Он выполняет 
  примитив barrier, чаще всего вызывая библиотечную процедуру. Затем процесс приостанавливается. 
  Через некоторое время второй и третий процессы заканчивают первую фазу и выполняют 
  примитив barrier (рис. 2.17, <i>б). </i>Наконец, когда последний процесс достигает 
  барьера, все процессы переходят в следующую фазу, как показано на рис. 2.17, 
  <i>в.</i><BR>
</p>
<p>Рассмотрим типичную задачу релаксации в физике или машиностроении в качестве 
  примера ситуации, требующей наличия барьеров. Обычно задача представляется в 
  виде матрицы с некоторыми начальными значениями. Эти значения могут соответствовать 
  температуре в разных точках металлической пластины. Необходимо рассчитать, через 
  какое время установится постоянное распределение температуры в случае нагрева 
  одной стороны пластины.<BR>
</p>
<p>К матрице применяется некоторое преобразование, например соответствующее законам 
  термодинамики, чтобы получить матрицу значений температуры через некоторое время. 
  Преобразование применяется снова и снова, чтобы получить зависимость температуры 
  в каждой точке от времени. Результатом будет серия матриц, соответствующих различным 
  моментам времени.<BR>
</p>
<p>Теперь представим, что матрица очень большая (скажем, миллион на миллион) 
  и для ускорения расчетов необходимы параллельные процессы, возможно, на мультипроцессоре. 
  Различные процессы обрабатывают различные части матрицы, рассчитывая новые элементы 
  на основе старых по законами физики. Очевидно, что ни один процесс не должен 
  начинать итерацию <i>п + </i>1, пока все процессы не закончили свою текущую 
  работу. Этой цели можно достичь, если каждый процесс будет выполнять операцию 
  barrier, закончив свою часть итерации. Когда все процессы закончили работу и 
  новая матрица, являющаяся входными данными для следующей итерации, составлена, 
  все процессы одновременно начнут следующую итерацию.<BR>
</p>
</BODY>
</HTML>
