<HTML>
<HEAD>
<title>Каналы</title>
</HEAD>
<body>
	<h1>Каналы</h1> 
	<ul>
		<li><a href="#create">Создание каналов</a></li>
		<li><a href="#child">Взаимодействие между родительскими и дочерними процессами</a></li>
		<li><a href="#redirect">Переадресовывание стандартного ввода, вывода и потока ошибок</a></li>
		<li><a href="#open">popen и pclose</a></li>
	</ul>
	<p>	Канал - однонаправленное средство взаимодействия. 
		Данные, записанные в канал со "стороны записи" читаются со "стороны чтения." 
		Каналы - последовательные устройства; данные всегда читаются в том же порядке, 
		в котором были записаны. Как правило, канал используется для взаимодействия двух потоков
		в одном процессе или между родительскими и дочерними процессами. В оболочке, символ
		<span class="term"> |</span>  создает канал. Например, эта команда оболочки запускает 
		два дочерних процесса, один <span class="term"> ls</span>  и один <span class="term"> 
		less</span> :
	</p>
<pre>
	% ls | less
</pre>
	<p>	Оболочка создает канал, соединяющий стандартный вывод процесса <span class="term"> ls
		</span> со стандартным вводом процесса <span class="term"> less </span>.
		Имена файлов, перечисленные в команде <span class="term"> ls</span>  посылаются к
		<span class="term"> less </span>  в точно том же порядке, как будто их пересылали 
		непосредственно терминалу. 
	</p>
	<p>	Емкость канала ограничена. Если процесс записи пишет быстрее, чем процесс 
		чтения считывает данные, и если канал не может больше сохранять данных, процесс записи блокируется 
		до тех пор, пока канал не разгрузится. Если считывающий процесс пытается прочитать,
		но данные недоступны, он блокируется до тех пор, пока данные не появятся в канале. Таким образом,
		канал автоматически синхронизирует два процесса. 
	</p>
	
	<a name="create"></a>
	<h2>Создание каналов</h2>
	<p>	Команда <span class="func"> pipe</span>  создает канал. Ей передается целочисленный
		массив размером 2. Вызов <span class="func"> pipe</span>  сохранит первым элементом 
		массива дескриптор читаемого файла, а вторым - дескриптор записываемого. 
		Пример:
	</p>
<pre>
	int pipe_fds[2];
	int read_fd;
	int write_fd;
	pipe (pipe_fds);
	read_fd = pipe_fds[0];
	write_fd = pipe_fds[1];
</pre>
	<p>	Данные, записанные в дескриптор файла <span class="term"> read_fd</span>  могут быть 
		прочитаны из <span class="term"> write_fd</span> . 
	</p>
	<a name="child"></a>
	<h2>Взаимодействие между родительскими и дочерними процессами</h2> 
	<p>	Вызов <span class="func"> pipe </span> создает дескрипторы файлов, которые верны 
		только в пределах этого процесса и его дочерних процессов. Дескрипторы файлов процесса 
		не могут быть переданы несвязанным процессам; однако, когда процесс вызывает 
		<span class="func"> fork</span> , дескрипторы файлов копируются в новый дочерний процесс.
		Таким образом, каналы могут соединить только связанные процессы. 
	</p>
	<p> 	В программе 5.7, с помощью команды <span class="func"> fork </span> порождается дочерний 
		процесс. Дочерний процесс унаследовал дескрипторы файлов канала. Родитель пишет строку в канал, 
		а потомок считывает ее. Типовая программа преобразовывает эти дескрипторы файлов в 
		потоки <span class="term"> FILE*</span>, используя команду <span class="func"> fdopen
		</span> . Поскольку используются потоки, а не дескрипторы файлов, возможно использование
		высокоуровневых функций ввода - вывода стандартной библиотеки <span class="term"> C </span> ,
		таких как <span class="func"> printf </span> и <span class="func"> fgets </span>.
	</p>
	<p>	Листинг 5.7(<a href="pipe.c">pipe.c</a>)
	</p>
<pre>
	#include &lt;stdlib.h&gt;
	#include &lt;stdio.h&gt;
	#include &lt;unistd.h&gt;
	/* Записать COUNT копий сообщений MESSAGE потоку STREAM, делая секундную паузу между каждым. */ 
	void writer (const char* message, int count, FILE* stream)
	{
		for (; count &gt; 0; --count) {
			/* Написать сообщение потоку, и отослать его немедленно. */ 
			fprintf (stream, "%s\n", message);
			fflush (stream);
			/* Задержаться */
			sleep (1);
		}
	}
	/* Читать случайные строки из потока. */
	void reader (FILE* stream)
	{
		char buffer[1024];
		/* Чтение,  пока мы не дойдем до конца потока. fgets считывает данные пока не новая строка или конец файла.  */
		while (!feof (stream)
				&amp;&amp; !ferror (stream)
				&amp;&amp; fgets (buffer, sizeof (buffer), stream) != NULL)
			fputs (buffer, stdout);
	}
	int main ()
	{
		int fds[2];
		pid_t pid;
		/* Создание канала.  Дескрипторы файлов канала помещены  в fds. */
		pipe (fds);
		/* Создать дочерний процесс.  */
		pid = fork ();
		if (pid == (pid_t) 0) {
			FILE* stream;
			/* Это - дочерний процесс. Закрытие копии дескриптора файла записи*/
			close (fds[1]);
			/* Преобразование дескриптора файла чтения к объекту FILE, и чтение из него. */
			stream = fdopen (fds[0], "r");
			reader (stream);
			close (fds[0]);
		}
		else {
			/* Это - родительский процесс.  */
			FILE* stream;
			/* Закрывают нашу  копию конца чтения  дескриптора файла. */
			close (fds[0]);
			/* Преобразование дескриптора файла записи к объекту  FILE, и запись в него. */ 
			stream = fdopen (fds[1], "w");
			writer ("Hello, world.", 5, stream);
			close (fds[1]);
		}
		return 0;
	}
</pre>
	<p>	Перед <span class="term"> main</span> , мы определили <span class="term"> fds</span> 
		как целочисленный массив, размером 2. Команда <span class="func"> pipe</span> создает канал 
		и помещает дескрипторы файлов чтения и записи в этом массиве. Затем создается дочерний процесс.
		После закрытия дескриптора на чтение, родительский процесс начинает записывать строки в канал. 
		После закрытия дескриптора на запись, дочерний процесс считывает строки из канала.
	</p>
	<p>	После записи в функции <span class="term"> writer </span> , родитель записывает все данные 
		из буферов потока в канал, используя команду <span class="func"> fflush</span> . Иначе, 
		строка может быть не передана через канал немедленно. При вызове команд <span class="term"> 
		ls | less</span> , создаются два дочерних процесса : один для <span class="term"> ls</span> 
		и один для <span class="term"> less</span> . Оба эти процесса наследуют дескрипторы файлов 
		канала, так что они могут взаимодействовать, используя канал.
	</p>
	<a name="redirect"></a>
	<h2>Переадресовывание стандартного ввода, вывода и потока ошибок</h2>
	<p>	Часто, появляется необходимость создать дочерний процесс и установить одну сторону канала как 
		стандартный ввод или стандартный вывод процесса. Команда <span class="func"> dup2</span> 
		позволяет приравнять один дескриптор файла к другому. Например, чтобы переадресовать стандартный
		ввод процесса к дескриптору файла <span class="func"> fd</span> , используйте эту строку:
	</p>
<pre>
	dup2 (fd, STDIN_FILENO);
</pre>
	<p>	Константа <span class="term"> STDIN_FILENO</span>  определяет дескриптор файла для 
		стандартного ввода, она имеет значение 0. Вызов закрывает стандартый ввод и затем заново 
		открывает его как дубликат <span class="term"> fd</span> , поэтому они оба могут использоваться
		взаимозаменяемо. Приравненные дескрипторы файлов совместно используют одну и ту же позицию файла
		и тот же набор состояний флагов файла. Таким образом, символы прочитаные из <span class="term"> 
		fd </span> , не пересчитываются из стандартного ввода.
	</p>
	<p>
		В листинге 5.8 приведен пример использования команды <span class="func"> dup2</span> , 
		для передачи вывода из канала команде <span class="term"> sort</span> . Команда 
		<span class="term"> sort</span>  читает строки текста из стандартного
		ввода, сортирует их в алфавитном порядке и пердает на стандартный вывод. После 
		создания канала, программа разветвляется. Родительский процесс печатает некоторые
		строки в канал. Дочерний процесс прикрепляет дескриптор файла чтения канала к его
		стандартному вводу, используя команду <span class="func"> dup2</span> . Затем 
		выполняется программа <span class="term"> sort</span>.
	</p>
	<p>	Listing 5.8 (<a href="dup2.c">dup2.c</a>) Перенаправление вывода из канала 
		с помощью <span class="func"> dup2 </span> 
	</p>
<pre>
	#include &lt;stdio.h&gt;
	#include &lt;sys/types.h&gt;
	#include &lt;sys/wait.h&gt;
	#include &lt;unistd.h&gt;
	int main ()
	{
		int fds[2];
		pid_t pid;
		/* Создается канал. Дескрипторы файлов для двух концов канала помещаются в fds*/
		pipe (fds);
		/*Создание дочернего процесса*/
		pid = fork ();
		if (pid == (pid_t) 0) {
			/*Если это дочерний процесс, закрывается копия дескриптора файла на запись*/
			close (fds[1]);
			/*Подключение конца чтения канала к стандартному вводу*/
			dup2 (fds[0], STDIN_FILENO);
			/*Замена дочернего процесса на программу sort*/
			execlp ("sort", "sort", 0);
		}
		else {
			/*Если это родительский процесс*/
			FILE* stream;
			/*Закрытие копии дескриптора файла стороны чтения */
			close (fds[0]);
			/*Преобразование дескриптора файла записи к объекту FILE, запись в него*/
			stream = fdopen (fds[1], "w");
			fprintf (stream, "This is a test.\n");
			fprintf (stream, "Hello, world.\n");
			fprintf (stream, "My dog has fleas.\n");
			fprintf (stream, "This program is great.\n");
			fprintf (stream, "One fish, two fish.\n");
			fflush (stream);
			close (fds[1]);
			/*Ожидание завершения дочернего процесса*/
			waitpid (pid, NULL, 0);
		}
		return 0;
	}
</pre>
	<a name="open"></a>
	<h2>popen и pclose</h2>
	<p>	Обычно использование каналов означает отправку данных в или получение данных из программы,
		выполняемой в подпроцессе. Функции <span class="func"> popen </span> и <span class="func"> 
		pclose</span>  облегчают это, устраняя потребность вызова команд <span class="func"> pipe, 
		fork, dup2, exec,</span>  и <span class="func"> fdopen</span>.
	</p>
	<p>
		Сравните листинг 5.9, в котором продемострировано использование команд <span class="func"> 
		popen</span>  и <span class="func"> pclose</span> ,с предыдущим примером (Листинг 5.8).
	</p>
	<p>	Листинг 5.9 (<a href="popen.c">popen.c</a>)
	</p>
<pre>
	#include &lt;stdio.h&gt;
	#include &lt;unistd.h&gt;
	int main ()
	{
		FILE* stream = popen ("sort", "w");
		fprintf (stream, "This is a test.\n");
		fprintf (stream, "Hello, world.\n");
		fprintf (stream, "My dog has fleas.\n");
		fprintf (stream, "This program is great.\n");
		fprintf (stream, "One fish, two fish.\n");
		return pclose (stream);
	}
</pre>
	<p>	Команда <span class="func"> popen</span>  создает дочерний процесс, выполняющий 
		команду <span class="term"> sort</span> , заменяюет команды <span class="func"> 
		pipe, fork, dup2, execp</span> . Второй параметр, "w", показывает, что этот 
		дочерний процесс производит запись в дочерний процесс. Возвращаемое значение из 
		<span class="func"> popen</span>  является одним из концов канала;
		другой конец подключен к стандартному вводу дочернего процесса. После окончания записи, 
		<span class="func"> pclose </span> закрывает поток дочернего процесса, 
		ждет окнчания процесса и возвращает свое значение состояния.
	</p>
	<p>	Первый параметр в popen выполняется как команда оболочки в подпроцессе, 
		выполняющем <span class="term"> /bin/sh</span> .
		Оболочка ищет по переменной среды <span class="term"> PATH</span>  выполняемую 
		программу. Если второй параметр - "r",функция возвращает поток стандартного
		вывода дочернего процесса так, чтобы родительский процесс мог читать вывод.
		Если второй параметр - "w", функция возвращает стандартый поток дочернего 
		процесса так, чтобы родитель мог отправить данные. Если произошла ошибка,
		<span class="func"> popen </span> возвращает нулевой указатель. 
	</p>
	<p>
		Команда <span class="func"> pclose</span>  закрывает поток, возвращенный 
		<span class="func"> popen</span> . После закрытия указанного потока, 
		<span class="func"> pclose</span>  ждет завершения дочернего процесса.
	</p>
</body>
