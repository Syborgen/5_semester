<HTML>
<HEAD>
<title>Отображаемая память</title>
</HEAD>
<body>
	<h1>Отображаемая память</h1> 
	<ul>
		<li><a href="#regular">Отображение обычного  файла</a></li>
		<li><a href="#example">Пример программы</a></li>
		<li><a href="#shared_access">Совместный доступ к файлу</a></li>
		<li><a href="#private_map">Частные отображения</a></li>
		<li><a href="#other_use">Другие применения mmap</a></li>
	</ul>       
		<p>      Отображаемая память позволяет различным  процессам общаться через общедоступный  
		файл. Отображаемая память  может использоваться для взаимодействия  процессов или как 
		простой способ для обращения к содержимому файла. 
		Отображаемая память  формирует ассоциацию между файлом  и памятью процесса. <span class="term">
		Linux </span>	разбивает файл на куски размером страницы и затем копирует их в страницы виртуальной  
		памяти так, чтобы они могли быть представлены в адресном пространстве процесса. Таким  
		образом, процесс может читать содержание  файла обычным доступом к памяти. Он  может также 
		изменить  содержимое файла, записывая в  память. Что позволяет быстро взаимодействовать с файлом.
	</p>
	<p>	Существуют иные методы использования отображаемой памяти. Некоторые 
		из них описаны в разделе "Другие методы использования для mmap." 
	</p>
	<a name="regular"></a>
	<h2> Отображение обычного  файла</h2>
	<p>	Чтобы отобразить  обычный файл  в память процесса используйте вызов <span class="func"> 
		mmap</span> (<span class="term">Memory MAPped </span>, произносимое "em-map"). 
		Первый параметр - адрес, начиная с которого Вы хотели бы, чтобы <span class="term"> Linux
		</span> отобразил файл;  значение <span class="term"> NULL </span> заставляет <span class="term">
		Linux </span> выбирать первый доступный  адрес.
		Второй  параметр - длина отображения в байтах. Третий параметр определяет  защиту для
		отображаемого адресного интервала.  Защита состоит из поразрядного "или"  из  <span class="term">
		PROT_READ</span>, <span class="term"> PROT_WRITE</span> , и <span class="term"> PROT_EXEC</span>,
		что соответствует  чтению, записи, и разрешению на выполнение. Четвертый параметр  -
		значение флажка, определяющее дополнительные опции. Пятый параметр  - дескриптор 
		открытого файла, который будет отображен. Последний  параметр - смещение от начала
		файла, с которого начнется отображение. Вы можете отобразить весь или часть файла
		в память, выбирая  начальное смещение и длину.
	</p>
	<p>	Значение флажка - поразрядное  "или" этих  ограничений: 
		<ul>
			<li>	<span class="term"> MAP_FIXED</span>  - отображать только начиная 
				с указаного адреса, если не удастся - вернуть ошибку, а не искать
				подходящий. Этот адрес должен  быть выровнен на границу страницы.
			</li>
			<li>	<span class="term"> MAP_PRIVATE </span> - производить запись изменений
				не в отображенный файл, а в его копию. Никакой другой 	процесс не увидит,
				изменений в файле. Этот  режим  не может использоваться с <span class="term">
				MAP_SHARED</span>.
			</li>
			<li>	<span class="term"> MAP_SHARED</span> - изменения в памяти немедленно 
				отражаются в основном файле вместо буферизации. Используйте этот режим
				для межпроцессового взаиодействия. Не  должно быть использованно вместе
				с <span class="term"> MAP_PRIVATE</span>. 
			</li>
		</ul>
		Успешный вызов возвращает указатель на начало  памяти. При ошибке, возвращает 
		<span class="term"> MAP_FAILED</span> . Когда вы закончили работу с управлением 
		памятью, освободите ее при помощи <span class="func"> munmap</span>.
		Передайте адрес начала и длину области отображаемой памяти. <span class="term"> Linux
		</span> автоматически освобождает отображаемую память при завершении процесса.
	</p>
	<a name="example"></a>
	<h2> Пример программы </h2>
	<p>	Давайте посмотрим на две  программы демонстрирующие использование области отображаемой памяти,
		с целью чтения и записи в файлам. Первая программа,  листинг 5.5, генерирует  случайное  число
		и пишет его в файл. Вторая программа,  листинг 5.6, читает число, печатает его, и удваивает 
		его в файле. Обе программы считывают имена отображаемых файлов из командной строки.
	</p>
	<p>
        	Listing 5.5 (<a href ="mmap-write.c">mmap-write.c</a>) Записывает случайное число 
		в отображаемую память
	</p>
<pre>
        #include &lt;stdlib.h&gt;
        #include &lt;stdio.h&gt;
        #include &lt;fcntl.h&gt;
        #include &lt;sys/mman.h&gt;
        #include &lt;sys/stat.h&gt;
        #include &lt;time.h&gt;
        #include &lt;unistd.h&gt;
	#define FILE_LENGTH 0x100
	/* Возвратить случайное число из диапазона [low, high]. */
	int random_range (unsigned const low, unsigned const high)
	{
		unsigned const range = high - low + 1;
		return low + (int) (((double) range) * rand () / (RAND_MAX + 1.0));
	}
	int main (int argc, char* const argv[])
	{
		int fd;
		void* file_memory;
		/* Инициализируем генератор случайных чисел. */          
		srand (time (NULL));

		/* Открываем(создаем) файл, достаточно  большой, чтобы хранить целое число без знака. */          
		fd = open (argv[1], O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);
		lseek (fd, FILE_LENGTH+1, SEEK_SET);
		write (fd, "", 1);
		lseek (fd, 0, SEEK_SET);

		/* Создаем отображение в памяти. */          
		file_memory = mmap (0, FILE_LENGTH, PROT_WRITE, MAP_SHARED, fd, 0);
		close (fd);

		/* Пишем случайное целое число в отображенную память. */     
		sprintf((char*) file_memory, "%d\n", random_range (-100, 100));

		/* Освобождаем память. */ 
		munmap (file_memory, FILE_LENGTH);

		return 0;
	}
</pre>  

	<p>	Программа <span class="term"> mmap-write</span> открывает файл, создавая  его, 
		если он прежде не существовал. Третий параметр указывает режим доступа для 
		чтения и записи. Поскольку мы не знаем длину файла, мы используем <span class="func"> 
		lseek</span> , чтобы гарантировать, что файл является  достаточно большим, чтобы сохранить 
		целое число . После чего возвращаемся к началу файла.
	</p>
	<p>	Программа отображает файл и затем закрывает дескриптор файла, потому что он больше не нужен.
		Программа пишет случайное целое число в отображаемую память, таким образоми в файл, и освобождает 
		отображаемую память. Вызов <span class="func"> munmap</span>  ненужен, потому что <span class="term">
		Linux</span>  автоматически освободил бы отображаемую память и файл, когда программа завершится.
	</p>
	<p>	Listing 5.6 (<a href="mmap-read.c">mmap-read.c</a>) Читает число из файла отображенного 
		в памяти и удваивает число.
	</p>
<pre>
	#include &lt;stdlib.h&gt;
	#include &lt;stdio.h&gt;
	#include &lt;fcntl.h&gt;
	#include &lt;sys/mman.h&gt;
	#include &lt;sys/stat.h&gt;
	#include &lt;unistd.h&gt;
	#define FILE_LENGTH 0x100
	int main (int argc, char* const argv[])
	{
		int fd;
		void* file_memory;
		int integer;
		/* Открыть файл. */
		fd = open (argv[1], O_RDWR, S_IRUSR | S_IWUSR);
		/* Отобразить файл в память.  */
		file_memory = mmap (0, FILE_LENGTH, PROT_READ | PROT_WRITE,
				MAP_SHARED, fd, 0);
		close (fd);
		/* Чтение целого  числа, распечатка и умножение на 2.  */
		scanf (file_memory, "%d", &amp;nteger);
		printf ("значение: %d\n", integer);
		sprintf ((char*) file_memory, "%d\n", 2 * integer);
		/* Освобождение памяти. */ 
		munmap (file_memory, FILE_LENGTH);
		return 0;
	}
</pre>	
	<p>	Программа <span class="term"> mmap-read</span>  читает число из файла и затем записывает
		его удвоенное значение в файлу. Открывает файл и отображает для того, чтобы читать и 
		писать в него. Поскольку мы можем предположить, что файл  является  достаточно большим,
		чтобы сохранить целое число без знака, мы не должны  использовать <span class="func"> 
		lseek</span> , как в предыдущей  программе. Программа читает и анализирует  значение 
		используя <span class="func"> scanf</span>  и затем форматирует и записывает удвоенное 
		значение, используя <span class="func"> sprintf</span> . Вот пример запуска примеров 
		программ. Здесь отображаем файл <span class="term"> /tmp/integer-file</span>.
	</p>
<pre>
          % ./mmap-write /tmp/integer-file
          % cat /tmp/integer-file
          42
          % ./mmap-read /tmp/integer-file
          value: 42
          % cat /tmp/integer-file
          84
</pre>
	<p>	Заметьте, что текст  42 был записан в файл на диске без вызова <span class="func"> write
		</span> , и читался без вызова <span class="func"> read</span> . Отметьте, что эти 
		программы пишут и читают целое число как строку только в целях демонстрации - нет 
		никакой  необходимости содержанию отображаемого файла быть текстом. Вы можете 
		сохранить и восстановить произвольный набор двоичных данных.
	</p>
	<a name="shared_access"></a>
	<h2> Совместный доступ к файлу</h2> 
	<p>	
		Различные  процессы  могут взаимоедйствовать используя области отображаемой памятью, связанные
		с одним и тем же файлом. Укажите флажок <span class="term"> MAP_SHARED</span> для того, чтобы
		любые операции записи в область памяти немедленно передаются файлу и видимым другим процессам.
		Если Вы не определяете этот флажок, <span class="term"> Linux</span>  может буферизовать
		операции записи перед  передачей их к файлу. 
	</p>
	<p>	С другой стороны вы можете заставить <span class="term"> Linux</span> синхронизировать буфер
		с файлом на диске, вызвав <span class="func"> msync </span>.
		Его первые два  параметра определяют область отображенной памяти, как и для <span class="func">
		munmap</span> . Третий  параметр может содержать следующие значения флажка: 
       		<ul>
			<li>	<span class="term"> MS_ASYNC  </span>  - обновление намечается, но 
				не обязательно выполненныется перед возвращением управления.
			</li>
			<li>	<span class="term"> MS_SYNC </span>  - обновление непосредственно; 
				вызов не возвращет управление пока не завершит синхронизацию. 
				<span class="term"> MS_SYNC </span> и <span class="term"> MS_ASYNC </span> 
				не должны прсутствовать вместе. 
			</li>
			<li>	<span class="term"> MS_INVALIDATE </span>  - все другие отображения файла
				изменены так, что бы они могли видеть модифицированные значения. 
			</li>
		</ul>
		Например, чтобы сбросить на диск буфер общедоступного файл, отображенный в адресе
		<span class="term"> mem_addr</span>  длины <span class="term"> mem_length </span> байт: 
	</p>
<pre>
          msync (mem_addr, mem_length, MS_SYNC | MS_INVALIDATE);
</pre>
	<p>	
		Как и с совместно используемой памятью, пользователи областей отображенной 
		памяти должны следовать протоколу, чтобы избежать условий гонки. Например, 
		семафор может использоваться, чтобы препятствовать доступуболее одного процесса к 
		отображенной памяти. 
	</p>
	<a name="private_map"></a>
	<h2>Частные отображения </h2>
	<p>	Указывая флаг <span class="term"> MAP_PRIVATE</span>  при вызове <span class="func">
		mmap</span>  создается область копирования при записи. Любая операция записи отражается
		только в памяти этого процесса; другие процессы, которые отображают тот же самый файл,
		не будут видеть изменения. Вместо того, чтобы писать непосредственно странице, 
		разделенной всеми процессами, процесс пишет частной копии этой страницы. Все 
		последующие операции читения и записи процессом используют эту же страницу. 
	</p>
	<a name="other_use"></a>
	<h2>Другие применения mmap</h2>
	<p>	Вызов <span class="func"> mmap </span> может использоваться и в целях не связанных 
		с взаимодействием процессов. Одно из применений - замена операций для чтения и записи.
		Например, вместо того, чтобы явно читать содержимое файла в память, программа могла бы
		отобразить файл в память и просмотреть эго используя чтение памяти. Для некоторых 
		программ, это более удобно и может работать быстрее, чем явные операции ввода - вывода. 
	</p>
	<p>	Одна мощная методика, используемая некоторыми программами  - формирование 
		структуры данных в файле отображенной памяти. При следующем запуске, 
		программа отображает тот файл назад в память, и структуры данных восстановлены в 
		их предыдущеее состояние. Обратите внимание, что указатели в этих структурах данных 
		будут недопустимы, если они все не указывают в пределах той отображенной области памяти
		или если файл отображен по тем же адресам, которые занимал первоначально. 
       </p>
</body>
