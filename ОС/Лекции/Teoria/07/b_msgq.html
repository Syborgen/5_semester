<HTML>
<HEAD>
</HEAD>
<body>

   <h1> Сообщения</h1>

	<p>    С сообщениями работают четыре системных функции: msgget, которая 
	возвращает (и в некоторых случаях создает) дескриптор сообщения,
	определяющий очередь  сообщений и используемый другими системными 
	функциями,<span  class=term> msgctl</span>, которая устанавливает и возвращает связанные с 
	дескриптором сообщений параметры  или	удаляет  дескрипторы,  msgsnd, 
	которая посылает сообщение, и msgrcv, которая получает сообщение.
	</p>
	<p>    Синтаксис вызова системной функции msgget:</p>
	
	<span class=term>    msgqid = msgget(key,flag);</span>

	<p> где <span class=term>msgqid</span> - возвращаемый функцией дескриптор,
	а <span class=term> key</span> и <span class=term>flag</span> имеют ту 
	же  семантику, что и в системной функции типа <span class=term> "get"</span>. 
	Ядро хранит сообщения в связном  списке (очереди), определяемом значением
	дескриптора, и использует значение msgqid в качестве указателя на массив заголовков 
	очередей. Кроме вышеуказанных полей, описывающих общие для всего механизма права доступа,  
	заголовок очереди содержит следующие поля:</p>
	<ul>
		<li>Указатели на первое и последнее сообщение в списке;</li>
		<li>Количество сообщений и общий объем информации в списке в байтах;</li>
		<li>Максимальная емкость списка в байтах;</li>
		<li>Идентификаторы процессов, пославших и принявших сообщения последними;</li>
		<li>Поля,  указывающие время последнего выполнения функций<span class=term>msgsnd, 
		msgrcv и msgctl.</span>
	</ul>

	<p>Когда пользователь вызывает функцию <span class=term>msgget</span> 
	для того, чтобы создать новый дескриптор, ядро просматривает массив 
	очередей сообщений в поисках существующей очереди с указанным идентификатором.
	Если такой очереди нет, ядро выделяет новую очередь, инициализирует ее 
	и возвращает идентификатор пользователю. В противном случае ядро проверяет 
	наличие необходимых прав доступа и завершает выполнение функции.</p>
	<p>Для посылки сообщения процесс использует системную функцию <span class=term>msgsnd</span>:</p>

	<span class=term> msgsnd(msgqid,msg,count,flag);</span>

	<p>где <span class=term> msgqid</span> - дескриптор  очереди  сообщений,
	обычно  возвращаемый  функцией <span class=term> msgget,  msg</span> - 
	указатель на структуру, состоящую из типа в виде назначаемого пользователем 
	целого числа и массива символов, count - размер информационного массива,
	<span class=term>  flag</span> - действие, предпринимаемое  ядром  в  случае 
	переполнения внутреннего буферного пространства.</p>
	<p>Ядро  проверяет  (Рисунок 11.4), имеется ли у посылающего сообщение 
	процесса разрешения на запись по указанному дескриптору, не выходит  ли
	размер сообщения  за  установленную  системой  границу,  не содержится 
	ли в очереди слишком большой объем информации, а также является ли тип 
	сообщения  положительным  целым  числом.  Если все условия соблюдены, 
	ядро выделяет сообщению место, используя карту сообщений, и копирует  
	в  это  место данные  из  пространства пользователя. К сообщению присоединяется
	заголовок, после чего оно помещается в конец связного списка  заголовков  
	сообщений.</p> 
<pre>	
    -------------------------------------------------------------¬
    ¦ алгоритм msgsnd       /* послать сообщение */              ¦
    ¦ входная информация:  (1) дескриптор очереди сообщений      ¦
    ¦                      (2) адрес структуры сообщения         ¦
    ¦                      (3) размер сообщения                  ¦
    ¦                      (4) флаги                             ¦
    ¦ выходная информация: количество посланных байт             ¦
    ¦ {                                                          ¦
    ¦    проверить правильность указания дескриптора и наличие   ¦
    ¦     соответствующих прав доступа;                          ¦
    ¦    выполнить пока (для хранения сообщения не будет выделено¦
    ¦     место)                                                 ¦
    ¦    {                                                       ¦
    ¦        если (флаги не разрешают ждать)                     ¦
    ¦              вернуться;                                    ¦
    ¦        приостановиться (до тех пор, пока место не освобо-  ¦
    ¦         дится);                                            ¦
    ¦    }                                                       ¦
    ¦    получить заголовок сообщения;                           ¦
    ¦    считать текст сообщения из пространства задачи в прост- ¦
    ¦     ранство ядра;                                          ¦
    ¦    настроить структуры данных: выстроить очередь заголовков¦
    ¦     сообщений, установить в заголовке указатель на текст   ¦
    ¦     сообщения, заполнить поля, содержащие счетчики, время  ¦
    ¦     последнего выполнения операций и идентификатор процес- ¦
    ¦     са;                                                    ¦
    ¦    вывести из состояния приостанова все процессы, ожидающие¦
    ¦     разрешения считать сообщение из очереди;               ¦
    ¦ }                                                          ¦
    L-------------------------------------------------------------

              Рисунок 11.4. Алгоритм посылки сообщения
    </pre>

<p> 	В заголовке сообщения записывается тип и размер сообщения,  устанавливается  
	указатель на текст сообщения и производится корректировка содержимого различных
	полей заголовка очереди, содержащих статистическую информацию (количество сообщений 
	в очереди и их суммарный объем  в  байтах,  время последнего выполнения операций
	и идентификатор процесса, пославшего сообщение). Затем ядро выводит из состояния
	приостанова  все  процессы, ожидающие  пополнения очереди сообщений. Если размер
	очереди в байтах превышает границу допустимости, процесс приостанавливается до 
	тех пор, пока  другие  сообщения не уйдут из очереди. Однако, если процессу было 
	дано указание не ждать (флаг <span class=term>IPC_NOWAIT</span>), он немедленно возвращает управление с
	уведомлением об ошибке. На Рисунке 11.5 показана очередь сообщений, состоящая из
	заголовков  сообщений,  организованных  в связные списки, с указателями на область 
	текста.
</p>
	    Рассмотрим программу, представленную на Рисунке 11.6.  Процесс  вызывает
	функцию  <span class=term>msgget</span> для того, чтобы получить дескриптор для записи с идентифика-
	тором <span class=term>MSGKEY</span>. Длина сообщения принимается равной 256 
	байт, хотя используется только первое поле целого типа, в область текста сообщения
	копируется  идентификатор  процесса, типу сообщения присваивается значение 1, 
	после чего вызывается функция msgsnd для посылки сообщения. Мы вернемся к  этому  примеру
	позже.
</p>
	
<p>    Процесс  получает сообщения, вызывая функцию <span class=term>msgrcv</span> 
по следующему формату:</p>
	<span class=term>count = msgrcv(id,msg,maxcount,type,flag);</span>

<p> 	где <span class=term>id</span> - дескриптор сообщения, <span class=term>msg</span> 
	- адрес пользовательской структуры, которая будет содержать полученное сообщение,
	<span class=term> maxcount</span> - размер  структуры  <span class=term>msg</span>,
	<span class=term>type</span>  - тип считываемого сообщения, <span class=term>flag</span> - 
	действие, предпринимаемое ядром в том случае, если в очереди сообщений нет. В переменной count пользователю возвращается число  прочитанных
	байт сообщения.
</p>
   <pre>

    Заголовки                                         Область
    очередей                                          текста
    -------¬           Заголовки сообщений        -->-------¬
    ¦      ¦     -------¬    -------¬    -------¬ ¦  ¦      ¦
    ¦    --+---->¦      +--->¦      +--->¦      ¦ ¦  ¦      ¦
    ¦      ¦     L---+---    L---+---    L---+--- ¦  ¦      ¦
    +------+         ¦           ¦           L-----  ¦      ¦
    ¦      ¦         L-----------¦------------------>+------+
    ¦      ¦                     ¦                   ¦      ¦
    ¦      ¦                     ¦                   ¦      ¦
    +------+                     ¦                   ¦      ¦
    ¦      ¦     -------¬        ¦                   ¦      ¦
    ¦    --+---->¦      ¦        ¦                   ¦      ¦
    ¦      ¦     L---+---        ¦                   ¦      ¦
    +------+         ¦           ¦                   ¦      ¦
    ¦   •  ¦         ¦           ¦                   +------+
    ¦   •  ¦         L-----------¦------------------>+------+
    ¦   •  ¦                     ¦                   ¦      ¦
    ¦   •  ¦                     ¦                   ¦      ¦
    ¦   •  ¦                     L------------------>+------+
    ¦   •  ¦                                         ¦      ¦
    ¦   •  ¦                                         +------+
    ¦   •  ¦                                         ¦   •  ¦
    ¦   •  ¦                                         ¦   •  ¦
    ¦   •  ¦                                         ¦   •  ¦
    L-------                                         L-------

    Рисунок 11.5. Структуры данных, используемые в организации сообщений

    </pre>
<p>    Ядро  проверяет  (Рисунок 11.7), имеет ли пользователь необходимые права
доступа к очереди сообщений. Если тип считываемого сообщения  имеет  нулевое
значение,  ядро  ищет  первое  по счету сообщение в связном списке. Если его
размер меньше или равен размеру,  указанному  пользователем,  ядро  копирует
текст сообщения в пользовательскую структуру и соответствующим образом настраивает  
свои  внутренние структуры: уменьшает счетчик сообщений в очереди и
суммарный объем информации в байтах, запоминает время получения сообщения  и
идентификатор процесса-получателя, перестраивает связный список и освобождает
место  в  системном пространстве, где хранился текст сообщения. Если какие-либо 
процессы, ожидавшие получения  сообщения,  находились  в  состоянии
приостанова  из-за  отсутствия свободного места в списке, ядро выводит их из
этого состояния. Если размер сообщения превышает значение maxcount,  указанное
  пользователем,  ядро посылает системной функции уведомление об ошибке и
оставляет сообщение в очереди. Если, тем не менее, процесс игнорирует  ограничения
  на  размер  (в поле <span class=term>flag</span> установлен бит <span class=term>MSG_NOERROR)</span>, ядро обрезает
сообщение, возвращает запрошенное количество байт  и  удаляет  сообщение  из
списка целиком.
</p>
<pre>
    -------------------------------------------------------------¬
    ¦ #include &lt;sys/types.h&gt;                                     ¦
    ¦ #include &lt;sys/ipc.h&gt;                                       ¦
    ¦ #include &lt;sys/msg.h&gt;                                       ¦
    ¦                                                            ¦
    ¦ #define MSGKEY     75                                      ¦
    ¦                                                            ¦
    ¦ struct msgform {                                           ¦
    ¦        long     mtype;                                     ¦
    ¦        char     mtext[256];                                ¦
    ¦ };                                                         ¦
    ¦                                                            ¦
    ¦ main()                                                     ¦
    ¦ {                                                          ¦
    ¦        struct msgform msg;                                 ¦
    ¦        int msgid,pid,*pint;                                ¦
    ¦                                                            ¦
    ¦        msgid = msgget(MSGKEY,0777);                        ¦
    ¦                                                            ¦
    ¦        pid = getpid();                                     ¦
    ¦        pint = (int *) msg.mtext;                           ¦
    ¦        *pint = pid;         /* копирование идентификатора  ¦
    ¦                              * процесса в область текста   ¦
    ¦                              * сообщения */                ¦
    ¦        msg.mtype = 1;                                      ¦
    ¦                                                            ¦
    ¦        msgsnd(msgid,&msg,sizeof(int),0);                   ¦
    ¦        msgrcv(msgid,&msg,256,pid,0);   /* идентификатор    ¦
    ¦                               * процесса используется в    ¦
    ¦                               * качестве типа сообщения */ ¦
    ¦        printf("клиент: получил от процесса с pid %d\n",    ¦
    ¦               *pint);                                      ¦
    ¦ }                                                          ¦
    L-------------------------------------------------------------

              Рисунок 11.6. Пользовательский процесс
 </pre>

<p>    Процесс может получать сообщения определенного типа, если присвоит параметру  
type  соответствующее  значение.  Если это положительное целое число,
функция возвращает первое значение данного типа,  если  отрицательное,  ядро
определяет минимальное значение типа сообщений в очереди, и если оно не превышает  
абсолютное значение параметра <span class=term> type </span>, возвращает процессу первое сообщение этого 
типа. Например, если очередь состоит из трех сообщений,  имеющих
тип  3,  1 и 2, соответственно, а пользователь запрашивает сообщение с типом
-2, ядро возвращает ему сообщение типа 1. Во  всех  случаях,  если  условиям
запроса не удовлетворяет ни одно из сообщений в очереди, ядро переводит процесс
 в состояние приостанова, разумеется если только в параметре flag не установлен 
бит <span class=term>IPC_NOWAIT</span> (иначе процесс немедленно выходит из функции).
</p>
<p>    Рассмотрим  программы, представленные на Рисунках 11.6 и 11.8. Программа
на Рисунке 11.8 осуществляет общее  обслуживание  запросов  пользовательских
процессов  (клиентов).  Запросы, например, могут касаться информации, хранящейся 
в базе данных; обслуживающий процесс  (сервер)  выступает  необходимым
посредником при обращении к базе данных, такой порядок облегчает поддержание
целостности  данных и организацию их защиты от несанкционированного доступа.
</p>
<pre>
    -------------------------------------------------------------¬
    ¦ алгоритм msgrcv     /* получение сообщения */              ¦
    ¦ входная информация:  (1) дескриптор сообщения              ¦
    ¦                      (2) адрес массива, в который заносится¦
    ¦                          сообщение                         ¦
    ¦                      (3) размер массива                    ¦
    ¦                      (4) тип сообщения в запросе           ¦
    ¦                      (5) флаги                             ¦
    ¦ выходная информация: количество байт в полученном сообщении¦
    ¦ {                                                          ¦
    ¦      проверить права доступа;                              ¦
    ¦   loop:                                                    ¦
    ¦      проверить правильность дескриптора сообщения;         ¦
    ¦      /* найти сообщение, нужное пользователю */            ¦
    ¦      если (тип сообщения в запросе == 0)                   ¦
    ¦           рассмотреть первое сообщение в очереди;          ¦
    ¦      в противном случае если (тип сообщения в запросе > 0) ¦
    ¦           рассмотреть первое сообщение в очереди, имеющее  ¦
    ¦            данный тип;                                     ¦
    ¦      в противном случае   /* тип сообщения в запросе < 0 */¦
    ¦           рассмотреть первое из сообщений в очереди с наи- ¦
    ¦            меньшим значением типа при условии, что его тип ¦
    ¦            не превышает абсолютное значение типа, указанно-¦
    ¦            го в запросе;                                   ¦
    ¦      если (сообщение найдено)                              ¦
    ¦      {                                                     ¦
    ¦           переустановить размер сообщения или вернуть ошиб-¦
    ¦            ку, если размер, указанный пользователем слишком¦
    ¦            мал;                                            ¦
    ¦           скопировать тип сообщения и его текст из прост-  ¦
    ¦            ранства ядра в пространство задачи;             ¦
    ¦           разорвать связь сообщения с очередью;            ¦
    ¦           вернуть управление;                              ¦
    ¦      }                                                     ¦
    ¦      /* сообщений нет */                                   ¦
    ¦      если (флаги не разрешают приостанавливать работу)     ¦
    ¦           вернуть управление с ошибкой;                    ¦
    ¦      приостановиться (пока сообщение не появится в очере-  ¦
    ¦       ди);                                                 ¦
    ¦      перейти на loop;                                      ¦
    ¦ }                                                          ¦
    L-------------------------------------------------------------
             Рисунок 11.7. Алгоритм получения сообщения

</pre>
<p>Обслуживающий процесс создает сообщение путем установки флага<span class= term> IPC _CREAT </span>
при выполнении функции msgget и получает все сообщения типа 1 - запросы от процессов-клиентов. 
Он  читает  текст  сообщения,  находит
идентификатор процесса-клиента и приравнивает возвращаемое значение типа сообщения  значению  этого идентификатора. В данном примере обслуживающий про-
цесс возвращает в тексте сообщения  процессу-клиенту  его  идентификатор,  и
клиент  получает сообщения с типом, равным идентификатору клиента. Таким образом, обслуживающий процесс получает сообщения только от клиентов, а клиент
- только от обслуживающего процесса. Работа  процессов  реализуется  в  виде
многоканального  взаимодействия, строящегося на основе одной очереди сообщений.
</p>
<pre>
    -------------------------------------------------------------¬
    ¦ #include &lt;sys/types.h&gt;                                     ¦
    ¦ #include &lt;sys/ipc.h&gt;                                       ¦
    ¦ #include &lt;sys/msg.h&gt;                                       ¦
    ¦                                                            ¦
    ¦ #define MSGKEY     75                                      ¦
    ¦ struct msgform                                             ¦
    ¦ {                                                          ¦
    ¦        long     mtype;                                     ¦
    ¦        char     mtext[256];                                ¦
    ¦ }msg;                                                      ¦
    ¦ int msgid;                                                 ¦
    ¦                                                            ¦
    ¦ main()                                                     ¦
    ¦ {                                                          ¦
    ¦       int i,pid,*pint;                                     ¦
    ¦       extern cleanup();                                    ¦
    ¦                                                            ¦
    ¦       for (i = 0; i < 20; i++)                             ¦
    ¦            signal(i,cleanup);                              ¦
    ¦       msgid = msgget(MSGKEY,0777¦IPC_CREAT);               ¦
    ¦                                                            ¦
    ¦       for (;;)                                             ¦
    ¦       {                                                    ¦
    ¦            msgrcv(msgid,&msg,256,1,0);                     ¦
    ¦            pint = (int *) msg.mtext;                       ¦
    ¦            pid = *pint;                                    ¦
    ¦            printf("сервер: получил от процесса с pid %d\n",¦
    ¦                   pid);                                    ¦
    ¦            msg.mtype = pid;                                ¦
    ¦            *pint = getpid();                               ¦
    ¦            msgsnd(msgid,&msg,sizeof(int),0);               ¦
    ¦       }                                                    ¦
    ¦ }                                                          ¦
    ¦                                                            ¦
    ¦ cleanup()                                                  ¦
    ¦ {                                                          ¦
    ¦       msgctl(msgid,IPC_RMID,0);                            ¦
    ¦       exit();                                              ¦
    ¦ }                                                          ¦
    L-------------------------------------------------------------

            Рисунок 11.8. Обслуживающий процесс (сервер)
</pre>


<p>    Сообщения имеют форму "тип - текст", где текст представляет собой  поток
байтов.  Указание  типа дает процессам возможность выбирать сообщения только
определенного рода, что в файловой системе не так легко сделать. Таким образом, 
процессы могут выбирать из очереди сообщения определенного типа  в  порядке  их  
поступления, причем эта очередность гарантируется ядром. Несмотря
на то, что обмен сообщениями может быть реализован на пользовательском уровне 
средствами файловой  системы,  представленный  вашему  вниманию  механизм
обеспечивает более эффективную организацию передачи данных между процессами.
</p>
<p>    С  помощью системной функции <span class=term>msgctl</span> процесс может запросить информацию о
статусе дескриптора сообщения, установить этот статус или удалить дескриптор
сообщения из системы. Синтаксис вызова функции:
</p>

 <span class=term>   msgctl(id,cmd,mstatbuf)</span>

где <span class=term>id</span> - дескриптор сообщения, <span class=term>cmd</span> - тип команды,<span class=term>mstatbuf</span> - адрес пользова-
тельской структуры, в которой будут храниться управляющие параметры или  ре-
зультаты обработки запроса. Более подробно об аргументах функции пойдет речь
в Приложении.
 <p>   Вернемся  к примеру, представленному на Рисунке 11.8. Обслуживающий про-
цесс принимает сигналы и с помощью функции cleanup удаляет очередь сообщений
из системы. Если же им не было поймано ни одного  сигнала  или  был  получен
сигнал <span class=term> SIGKILL</span>,  очередь  сообщений остается в системе, даже если на нее не
ссылается ни один из процессов. Дальнейшие  попытки  исключительно  создания
новой очереди сообщений с данным ключом (идентификатором) не будут иметь ус-
пех до тех пор, пока старая очередь не будет удалена из системы.
</p>
</body>
</html>
 