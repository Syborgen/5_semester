<HTML>
<HEAD>  
<title>Семафоры</title>
</HEAD>              
<body>
<h1> СЕМАФОРЫ</h1>
<p> Поддержка системы <span class=temp>UNIX </span>в многопроцессорной конфигурации может включать в
себя разбиение ядра системы на критические участки, параллельное  выполнение
которых на нескольких процессорах не допускается. Такие системы предназнача-
лись  для работы на машинах AT&T 3B20A и IBM 370, для разбиения ядра исполь-
зовались семафоры. Нижеследующие рассуждения помогают понять суть данной 
особенности. При ближайшем рассмотрении сразу же  возникают  два вопроса: 
как использовать семафоры и где определить критические участки.</p>
<p>    Как  уже  говорилось, если при выполнении критического участка
программы процесс приостанавливается, для защиты участка от посягательств со
стороны других процессов алгоритмы работы ядра однопроцессорной системы UNIX
механизм снятия блокировки:</p>
<ul>
  <li> снять блокировку;</li>
   <li> вывести из состояния приостанова все процессы,  приостановленные  в  ре-
    зультате блокировки;   
</ul>
<pre>
 Процесс A/Процессор A              Процесс B/Процессор B
    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД
    і              ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДї
    і              і Блокировка НЕ установлена і
    і          щ   АДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ  щ
    і          щ                                  щ
    і          щ                                  щ
    і Проверяет, установлена             Проверяет, установлена
    і    ли блокировка              а
    і        (нет)                              (нет)
t - Е - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
    і    Устанавливает                      Устанавливает
    і     блокировку                         блокировку
    і
    і  Использует ресурс                  Использует ресурс
    v         ^                                     ^
  Время       і                                     і
              АДДДДДДї                       ЪДДДДДДЩ
                  Опасность нарушения целостности
</pre>

<p> Блокировки  такого  рода охватывают некоторые критические участки, но не
работают в многопроцессорных системах, что видно из Рисунка 12.5.  Предполо-
менно пытаются проверить ее наличие и установить ее. В момент t они  обнару-
живаютснятие  блокировки,  устанавливают  ее вновь, вступают в критический
участок и создают опасность нарушения целостности структур  данных  ядра.  В
условии  одновременности имеется отклонение: механизм не сработает, если пе-
ред тем, как процесс выполняет операцию проверки, ни один другой процесс  не
выполнил операцию установления блокировки. Если, например, после обнаружения
снятия  блокировки  процессор A обрабатывает прерывание и в этот момент про-
цессор B выполняет проверку и устанавливает блокировку, по выходе из  преры-
вания процессор A так же установит блокировку. Чтобы предотвратить возникно-
вение подобной ситуации, нужно сделать так, чтобы процедура блокирования бы-
ла  неделимой: проверку наличия блокировки и ее установку следует объединить
в одну операцию, чтобы в каждый момент времени с блокир-
ко один процесс.
</p>


<h2>    Определение семафоров</h2>

<p>    Семафор представляет собой обрабатываемый  ядром  целочисленный  объект,
для которого определены следующие элементарные (неделимые) операции:
<ul>
<li> Инициализация семафора, в результате которой семафору присваивается неотрицательное значение;</li>
<li>  Операция типа P, уменьшающая значение семафора. Если  значение  семафора
    опускается  ниже  нулевой отметки, выполняющий операцию процесс приоста-
    навливает свою работу;</li>
<li>Условная операция типа P, сокращенно  CP  (conditional  P),  уменьшающая
    значение семафора и возвращающая логическое значение "истина" в том слу-
    чае,  когда  значение семафора остается положительным. Если в результате
    операции значение семафора должно стать отрицательным или нулевым, ника-
    ких действий над ним не производится и  операция  возвращает  логическое
    значение "ложь"</li>
</ul>
<p>    Определенные  таким образом семафоры, безусловно, никак не связаны с се-
мафорами пользовательского уровня.                      </p>


   <h2> Реализация семафоров</h2>

<p>  Дийкстра [Dijkstra 65] показал, что семафоры можно реализовать  без  ис-
пользования  специальных  машинных  инструкций. На Рисунке 12.6 представлены
реализующие семафоры функции, написанные на языке Си. Функция Pprim блокирует
семафор по результатам проверки значений,  содержащихся  в  массиве  val;
каждый  процессор  в  системе  управляет  значением одного элемента массива.
Прежде чем заблокировать семафор, процессор проверяет,  не  заблокирован  ли
уже  семафор другими процессорами (соответствующие им элементы в массиве val
тогда имеют значения, равные 2), а также не  предпринимаются  ли  попытки  в
данный  момент  заблокировать  семафор со стороны процессоров с более низким
кодом идентификации (соответствующие им элементы имеют значения, равные  1).
Если любое из условий выполняется, процессор переустанавливает значение сво-
его  элемента в 1 и повторяет попытку. Когда функция Pprim открывает внешний
сом (в качестве доказательства сошлемся на [Dijkstra 65]  и  [Coffman  73]).
Функция Vprim освобождает семафор и открывает для других процессоров возмож-
ность получения исключительного доступа к ресурсу путем очистки соответству-
ющего  текущему  процессору  элемента в массиве val и перенастройки значения
lastid. Чтобы защитить ресурс, следует выполнить следующий набор команд:</p>
<pre>
    Pprim(семафор); 
    команды использования ресурса;                          
    Vprim(семафор);      
</pre>
<p>    В большинстве машин имеется набор элементарных  (неделимых)  инструкций,
реализующих операцию блокирования более дешевыми средствами, ибо циклы, вхо-
дящие в функцию Pprim, работают медленно и снижают производительность систе-
мы. Так, например, в машинах серии IBM 370 поддерживается инструкция compare
and  swap (сравнить и переставить), в машине AT&T 3B20 - инструкция read and
clear (прочитать и очистить). При выполнении инструкции read and clear  про-
цессор  считывает содержимое ячейки памяти, очищает ее (сбрасывает в 0) и по
результатам сравнения первоначального содержимого с 0 устанавливает код  за-
вершения  инструкции.  Если  ту же инструкцию над той же ячейкой параллельно
выполняет еще один процессор, один из двух  процессоров  прочитает  первона-
чальное  содержимое,  а другой - 0: неделимость операции гарантируется аппа-
ратным путем. Таким образом, за счет использования данной инструкции функцию
Pprim можно было бы реализовать менее сложными  средствами  (Рисунок  12.7).
Процесс  повторяет инструкцию read and clear в цикле до тех пор, пока не бу-
дет считано значение, отличное от нуля. Начальное значение компоненты  сема-
фора, связанной с блокировкой, должно быть равно 1.</p>
<p>   Как  таковую, данную семафорную конструкцию нельзя реализовать в составе
ядра операционной системы, поскольку работающий с ней процесс не выходит  из
цикла, пока не достигнет своей цели. 
<pre>   
    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
    і struct semaphore                                           і
    і {                                                          і
    і    int val[NUMPROCS];  /* замок---1 элемент на каждый про- і
    і                        /* цессор */                        і
    і    int lastid;         /* идентификатор процессора, полу-  і
    і                        /* чившего семафор последним */     і
    і };                                                         і
    і int lastid;            /* идентификатор процессора, полу-  і
    і                        /* чившего семафор последним */     і
    і                                                            і
    і INIT(semaphore)                                            і
    і    struct semaphore semaphore;                             і
    і {                                                          і
    і    int i;                                                  і
    і    for (i = 0; i < NUMPROCS; i++)                          і
    і         semaphore.val[i] = 0;                              і
    і }                                                          і
    і Pprim(semaphore)                                           і
    і    struct semaphore semaphore;                             і
    і {                                                          і
    і    int i,first;                                            і
    і                                                            і
    і  loop:                                                     і
    і    first = lastid;                                         і
    і    semaphore.val[procid] = 1;                              і
    і    /* продолжение на следующей странице */                 і
    АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ

       Рисунок 12.6. Реализация семафорной блокировки на Си
    </pre>
<p>Если семафор заблокированным, приостанавливает свое выполнение, чтобы ядро  имело
возможность  переключиться  на  контекст другого процесса и выполнить другую
полезную работу. С помощью функций Pprim и  Vprim  можно  реализовать  более
сложный набор семафорных операций.     </p>
<p>    Для  начала  дадим определение семафора как структуры, состоящей из поля
блокировки (управляющего доступом к семафору), значения семафора  и  очереди
процессов,  приостановленных  по семафору. Поле блокировки содержит информа-
цию, открывающую во время выполнения операций типа P и V доступ к другим по-
лям структуры только одному процессу. По завершении операции  значение  поля
сбрасывается.  Это значение определяет, разрешен ли процессу доступ к крити-
ческому участку, защищаемому семафором. В начале выполнения алгоритма опера-
ции P (Рисунок 12.8) ядро с помощью  функции  Pprim  предоставляет  процессу
право исключительного доступа к семафору и уменьшает значение семафора. Если
семафор  имеет  неотрицательное  значение, текущий процесс получает доступ к
критическому участку. По завершении работы процесс сбрасывает блокировку се-
мафора (с помощью функции Vprim), открывая доступ к семафору для других про-
цессов, и возвращает признак успешного  завершения.  Если  же  в  результате
уменьшения значение семафора становится отрицательным, ядро приостанавливает
выполнение процесса, используя алгоритм, </p>
<pre>
    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
    і  forloop:                                                  і
    і    for (i = first; i < NUMPROCS; i++)                      і
    і    {                                                       і
    і         if (i == procid)                                   і
    і         {                                                  і
    і             semaphore.val[i] = 2;                          і
    і             for (i = 1; i < NUMPROCS; i++)                 і
    і                  if (i != procid && semaphore.val[i] == 2) і
    і                      goto loop;                            і
    і             lastid = procid;                               і
    і             return;     /* успешное завершение, ресурс     і
    і                         /* можно использовать              і
    і                          */                                і
    і         }                                                  і
    і         else if (semaphore.val[i])                         і
    і             goto loop;                                     і
    і    }                                                       і
    і    first = 1;                                              і
    і    goto forloop;                                           і
    і }                                                          і
    і Vprim(semaphore)                                           і
    і    struct semaphore semaphore;                             і
    і {                                                          і
    і    lastid = (procid + 1) % NUMPROCS;  /* на следующий      і
    і                                       /* процессор */      і
    і    semaphore.val[procid] = 0;                              і
 </pre>
подобный алгоритму sleep (глава 6): основываясь на значении приоритета, ядро
проверяет поступившие сигналы, включает текущий процесс в список приостанов-
ленных  процессов, в котором последние представлены в порядке поступления, и
выполняет переключение контекста. Операция V (Рисунок 12.9) получает  исклю-
чительный доступ к семафору через функцию Pprim и увеличивает значение сема-
фора.  Если очередь приостановленных по семафору процессов непуста, ядро вы-
бирает из нее первый процесс и переводит его в состояние "готовности  к  за-
пуску".   
<p>    Операции  P  и  V  по  своему действию похожи на функции sleep и wakeup.
Главное различие между ними состоит в том, что семафор  является  структурой
данных,  тогда  как используемый функциями sleep и wakeup адрес представляет
собой всего лишь число. Если начальное значение семафора - нулевое, при  вы-
полнении операции P над семафором процесс всегда приостанавливается, поэтому
операция  P  может заменять функцию sleep. Операция V, тем не менее, выводит
из состояния приостанова только один  процесс,  тогда  как  однопроцессорная
функция  wakeup  возобновляет все процессы, приостановленные по адресу, свя-                     
занному с событием.                                                                                                    
дальше пребывать в этом состоянии, если буфер больше не используется, поэто-
му они возобновляются ядром. Еще один пример: если несколько процессов выводят
данные на терминал с помощью функции write, терминальный драйвер может перевести
их  в
<pre>
    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
    і struct semaphore {                                    і                                             
    і        int lock;                                      і
    і };                                                    і
    і                                                       і
    і Init(semaphore)                                       і
    і        struct semaphore semaphore;                    і
    і {                                                     і
    і        semaphore.lock = 1;                            і
    і }                                                     і
    і                                                       і
    і Pprim(semaphore)                                      і
    і        struct semaphore semaphore;                    і                      
    і {                                                     і                                                   
    і        while (read_and_clear(semaphore.lock))         і
    і              ;                                        і
    і }                                                     і
    і                                                       і
    і Vprim(semaphore)                                      і
    і        struct semaphore semaphore;                    і
    і {                                                     і                                                      
    і        semaphore.lock = 1;                            і
    і }                                                     і
    АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ

    Рисунок 12.7. Операции над семафором, использующие инструкцию
                  read and clear
  </pre>

<p>состояние приостанова в связи с невозможностью обработки больших объемов ин-
формации. Позже, когда драйвер будет готов к приему следующей порции данных,
он возобновит все приостановленные им процессы. Использование операций P и V
в  тех  случаях, когда устанавливающие блокировку процессы получают доступ к
ресурсу поочередно, а все остальные процессы - в порядке поступления  запро-
сов,  является более предпочтительным. В сравнении с однопроцессорной проце-
дурой блокирования (sleep-lock) данная схема обычно выигрывает, так как если
при наступлении события все процессы возобновляются, большинство из них  мо-
жет  вновь наткнуться на блокировку и снова перейти в состояние приостанова.
С другой стороны, в тех случаях, когда требуется вывести из состояния приос-
танова все процессы одновременно, использование операций P и V  представляет
известную сложность.  </p>
<p>    Если  операция возвращает значение семафора, является ли она эквивалент-
ной функции wakeup ?
<pre>
    while (value(semaphore) < 0)
          V(semaphore);
</pre>
<p>    Если вмешательства со стороны других процессов нет, ядро повторяет  цикл
до тех пор, пока значение семафора не станет больше или равно 0, ибо это оз-
начает, что в состоянии приостанова по семафору нет больше ни одного процес-
са. Тем не менее, нельзя исключить и такую возможность, что сразу после того, 
как процесс A при тестировании  семафора на одноименном процессоре обнаружил 
нулевое значение семафора, процесс B на своем процессоре выполняет операцию P,
уменьшая значение  семафора  до -1 (Рисунок 12.10). Процесс A продолжит свое 
выполнение, думая, что им возобновлены все приостановленные по семафору 
процессы.  Таким  образом, цикл  выполнения операции не дает гарантии 
возобновления всех приостановленных процессов, поскольку он не является 
элементарным.</p>

<pre>
    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
    і алгоритм P     /* операция над семафором типа P */         і
    і входная информация:  (1) семафор                           і
    і                      (2) приоритет                         і
    і выходная информация: 0 - в случае нормального завершения   і
    і                      -1 - в случае аварийного выхода из    і
    і                      состояния приостанова по сигналу, при-і
    і                      нятому в режиме ядра                  і
    і {                                                          і
    і    Pprim(semaphore.lock);                                  і
    і    уменьшить (semaphore.value);                            і
    і    если (semaphore.value >= 0)                             і
    і    {                                                       і
    і        Vprim(semaphore.lock);                              і
    і        вернуть (0);                                        і
    і    }                                                       і
    і    /* следует перейти в состояние приостанова */           і
    і    если (проверяются сигналы)                              і
    і    {                                                       і
    і        если (имеется сигнал, прерывающий нахождение в сос- і
    і         тоянии приостанова)                                і
    і        {                                                   і
    і            увеличить (semaphore.value);                    і
    і            если (сигнал принят в режиме ядра)              і
    і            {                                               і
    і               Vprim(semaphore.lock);                       і
    і               вернуть (-1);                                і
    і            }                                               і
    і            в противном случае                              і
    і            {                                               і
    і               Vprim(semaphore.lock);                       і
    і               longjmp;                                     і
    і            }                                               і
    і        }                                                   і
    і    }                                                       і
    і    поставить процесс в конец списка приостановленных по се-і
    і     мафору;                                                і
    і    Vprim(semaphore.lock);                                  і
    і    выполнить переключение контекста;                       і
    і    проверить сигналы (см. выше);                           і
    і    вернуть (0);                                            і
    і }                                                          і
    АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ

            Рисунок 12.8. Алгоритм выполнения операции P
</pre>

<p>    Рассмотрим еще один феномен, связанный с использованием семафоров в  од-
нопроцессорной системе. Предположим, что два процесса, A и B, конкурируют за
семафор. Процесс A обнаруживает, что семафор свободен и что процесс B приос-
тановлен;  значение  семафора равно -1. Когда с помощью операции V процесс A
освобождает семафор, он выводит тем самым процесс B из состояния приостанова
и вновь делает значение семафора нулевым. Теперь предположим, что процесс A,
по-прежнему выполняясь в режиме ядра, пытается снова заблокировать  семафор.
Производя  операцию P, процесс приостановится, поскольку семафор имеет нуле-
вое значение, несмотря на то, что ресурс  пока  свободен.  Системе  придется
"раскошелиться"  на дополнительное переключение контекста. С другой стороны,
если  бы  блокировка  была  реализована  на  основе  однопроцессорной  схемы</p>
  
<pre>
    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
    і алгоритм V     /* операция над семафором типа V */         і
    і входная информация:  адрес семафора                        і
    і выходная информация: отсутствует                           і
    і {                                                          і
    і    Pprim(semaphore.lock);                                  і
    і    увеличить (semaphore.value);                            і
    і    если (semaphore.value <= 0)                             і
    і    {                                                       і
    і        удалить из списка процессов, приостановленных по се-і
    і         мафору, первый по счету процесс;                   і
    і        перевести его в состояние готовности к запуску;     і
    і    }                                                       і
    і    Vprim(semaphore.lock);                                  і
    і }                                                          і
    АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ

            Рисунок 12.9. Алгоритм выполнения операции V

</pre>
<p>(sleep-lock), процесс A получил бы право на повторное использование ресурса,
поскольку  за  это  время ни один из процессов не смог бы заблокировать его.
Для этого случая схема sleep-lock более подходит, чем схема с использованием
семафоров.</p>
<p>    Когда блокируются сразу несколько  семафоров,  очередность  блокирования
должна  исключать возникновение тупиковых ситуаций. В качестве примера расс-
мотрим два семафора, A и B, и два алгоритма, требующих одновременной  блоки-
ровки  семафоров.  Если  бы алгоритмы устанавливали блокировку на семафоры в
обратном порядке, как следует из Рисунка 12.11, последовало бы возникновение
тупиковой ситуации; процесс A на одноименном процессоре захватывает  семафор
SA,  в  то  время  как процесс B на своем процессоре захватывает семафор SB.
Процесс A пытается захватить и семафор SB, но в результате операции P  пере-
ходит  в  состояние приостанова, поскольку значение семафора SB не превышает
0. То же самое происходит с процессом B, когда последний пытается  захватить
семафор SA. Ни тот, ни другой процессы продолжаться уже не могут.</p>
<p>    Для предотвращения возникновения подобных ситуаций используются соответ-
ствующие  алгоритмы обнаружения опасности взаимной блокировки, устанавливаю-
щие наличие опасной ситуации и ликвидирующие ее. Тем не менее, использование
таких алгоритмов "утяжеляет" ядро. Поскольку число ситуаций, в которых  про-
цесс должен одновременно захватывать несколько семафоров, довольно ограниче-
но, легче было бы реализовать алгоритмы, предупреждающие возникновение тупи-
ковых  ситуаций еще до того, как они будут иметь место. Если, к примеру, ка-
кой-то набор семафоров всегда блокируется в одном и том же порядке,  тупико-
вая  ситуация никогда не возникнет. Но в том случае, когда захвата семафоров
в обратном порядке избежать не удается, операция CP предотвратит возникновение
тупиковой ситуации (см.  Рисунок  12.12):  если  операция завершится неудачно,
процесс B освободит свои ресурсы, дабы избежать взаимной блокировки, и позже 
запустит алгоритм на выполнение повторно, скорее всего тогда, когда процесс A 
завершит работу с ресурсом.</p>
<p>    Чтобы предупредить одновременное обращение процессов к ресурсу, програм-
ма обработки прерываний, казалось бы, могла  воспользоваться  семафором,  но
из-за того, что она не может приостанавливать свою работу (см. главу 6), ис-
пользовать  операцию P в этой программе нельзя. Вместо этого можно использо-
вать "циклическую блокировку" (spin lock) и не переходить в состояние приос-
танова, как в следующем примере:
  <pre>
    while (! CP(semaphore));

     Процесс A/Процессор A              Процесс B/Процессор B
    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД
    і          щ    ЪДДДДДДДДДДДДДДДДДДДДДДДДї    щ
    і          щ    і Значение семафора = -1 і    щ
    і          щ    АДДДДДДДДДДДДДДДДДДДДДДДДЩ    щ
    і проверяет(значение сема-                    щ
    і      фора < 0) ?                            щ
    і         (да)                                щ
    і       V(семафор)                            щ
    і          щ                                  щ
    і          щ    ЪДДДДДДДДДДДДДДДДДДДДДДДДї    щ
    і          щ    і Значение семафора =  0 і    щ
    і          щ    АДДДДДДДДДДДДДДДДДДДДДДДДЩ    щ
    і проверяет(значение сема-                    щ
    і      фора < 0) ?                            щ
    і          щ                                  щ
    і          щ                              P(семафор)
    і          щ                         Значение семафора = -1
    і          щ
    і         (нет)
    і       НЕВЕРНО !!
    v
  Время

    Рисунок 12.10.  Неудачное имитация функции wakeup при исполь-
                    зовании операции V

           </pre>
<p>Операция повторяется в цикле до тех пор, пока значение семафора не  превысит
0;  программа  обработки прерываний не приостанавливается и цикл завершается
только тогда, когда значение семафора станет положительным, после  чего  это
значение будет уменьшено операцией CP.</p>
<p>    Чтобы  предотвратить  ситуацию взаимной блокировки, ядру нужно запретить
все прерывания, выполняющие "циклическую блокировку". Иначе выполнение  про-
цесса, захватившего семафор, будет прервано еще до того, как он сможет осво-
бодить  семафор;  если  программа  обработки прерываний попытается захватить
этот семафор, используя "циклическую блокировку", ядро заблокирует само  се-
бя.  В  качестве  примера  обратимся к Рисунку 12.13. В момент возникновения
  <pre>
     Процесс A/Процессор A              Процесс B/Процессор B
    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД
    і    P(семафор SA);                           щ
    і          щ                                  щ
    і          щ                                  щ
    і          щ                                  щ
    і          щ                            P(семафор SB);
    і          щ                                  щ
    і          щ                                  щ
    і          щ                                  щ
    і          щ                            P(семафор SA);
    і          щ                          приостанавливается
    і          щ
    і    P(семафор SB);
    і  приостанавливается
    і
    v                  Взаимная блокировка !!
  Время
                      Рисунок 12.11.   Возникновение тупиковой ситуации 
                                   из-за смены очередности блокирования

     </pre>
<p>прерывания значение семафора не превышает 0, поэтому результатом выполнения  
операции CP всегда будет "ложь". Проблема решается путем запрещения всех 
прерываний на то время, пока семафор захвачен процессом.</p>


<h2>     Примеры алгоритмов</h2>

<p>    В  данном  разделе  мы рассмотрим четыре алгоритма ядра, реализованных с
использованием семафоров. Алгоритм  выделения  буфера  иллюстрирует  сложную
схему  блокирования, на примере алгоритма wait показана синхронизация выпол-
нения процессов, схема блокирования драйверов реализует изящный подход к ре-
шению данной проблемы, и наконец, метод  решения  проблемы  холостой  работы
процессора  показывает,  что нужно сделать, чтобы избежать конкуренции между
процессами.</p>


<h2>     Выделение буфера</h2>

   </p> Обратимся еще раз к алгоритму getblk, рассмотренному нами в главе 3. Ал-
горитм работает с тремя структурами данных: заголовком буфера,  хеш-очередью
буферов и списком свободных буферов. Ядро связывает семафор со всеми экземп-
лярами каждой структуры. Другими словами, если у ядра имеются в распоряжении
200  буферов, заголовок каждого из них включает в себя семафор, используемый
для захвата буфера; когда процесс выполняет над семафором операцию P, другие
процессы, тоже пожелавшие захватить буфер, приостанавливаются  до  тех  пор,
пока  первый  процесс  не  исполнит операцию V. У каждой хеш-очереди буферов
также имеется семафор, блокирующий доступ к очереди. 
<pre>
     Процесс A/Процессор A              Процесс B/Процессор B
    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДД
    і    P(семафор SA);                           щ
    і          щ                                  щ
    і          щ                            P(семафор SB);
    і          щ                                  щ
    і          щ                                  щ
    і          щ                        если (! CP(семафор SA))
    і          щ                        {
    і          щ                            V(семафор SB);
    і          щ                            перезапустить алго-
    і          щ                             ритм
    і          щ                        }
    і    P(семафор SB);
    і  приостанавливается
    v
  Время

    Рисунок 12.12.   Использование  операции P условного типа для
                     предотвращения взаимной блокировки
   </pre>

<p>В однопроцессорной системе блокировка хеш-очереди не нужна, ибо процесс никогда не переходит в состояние приостанова, ос-
тавляя очередь в несогласованном (неупорядоченном) виде. В многопроцессорной
системе, тем не менее, возможны ситуации, когда с одной и  той  же  хеш-оче-
редью  работают два процесса; в каждый момент времени семафор открывает дос-
туп к очереди только для одного процесса. По тем же причинам и  список  сво-
бодных буферов нуждается в семафоре для защиты содержащейся в нем информации
от искажения.</p>
<p>    На Рисунке 12.14 показана первая часть алгоритма getblk, реализованная в
многопроцессорной  системе с использованием семафоров. Просматривая буферный
кеш в поисках указанного блока, ядро с помощью операции P захватывает  сема-
фор,  принадлежащий  хеш-очереди.  Если над семафором уже кем-то произведена
операция данного типа, текущий процесс приостанавливается до тех  пор,  пока
процесс,  захвативший  семафор, не освободит его, выполнив операцию V. Когда
текущий процесс получает право исключительного контроля над хеш-очередью, он
приступает к поиску подходящего буфера. Предположим, что буфер  находится  в
хеш-очереди.  Ядро (процесс A) пытается захватить буфер, но если оно исполь-
зует операцию P и если буфер уже захвачен, ядру придется приостановить  свою
работу,  оставив хеш-очередь заблокированной и не допуская таким образом об-
ращений к ней со стороны других процессов, даже если последние  ведут  поиск
незахваченных  буферов.  Пусть вместо этого процесс A захватывает буфер, ис-
пользуя операцию CP; если операция завершается успешно, буфер становится от-
крытым для процесса. Процесс A  захватывает  семафор,  принадлежащий  списку
свободных  буферов, выполняя операцию CP, поскольку семафор захватывается на
непродолжительное время и, следовательно, приостанавливать свою работу,  вы-
полняя  операцию  P, процесс просто не имеет возможности. Ядро убирает буфер
из списка свободных буферов, снимает блокировку со списка и с хеш-очереди  и
возвращает захваченный буфер.</p>
<pre>

    і
    і                      P(семафор);
    і            (Значение семафора теперь равно 0)
    і
    і                       Прерывание
    і
    і           CP(семафор) завершается неудачно ---
    і                    семафор захвачен
    і
    і     Семафор не освобождается до выхода из прерывания.
    і
    і     Выход из прерывания без его обработки невозможен.
    і
    і          Тупиковая ситуация (взаимная блокировка)
    v
  Время

    Рисунок 12.13.   Взаимная блокировка при выполнении программы
                     обработки прерывания

  </pre>
<p>    Предположим,  что операция CP над буфером завершилась неудачно из-за то-
го, что семафор, принадлежащий буферу, оказался захваченным. Процесс A осво-
бождает семафор, связанный с хеш-очередью, и приостанавливается, пытаясь вы-
полнить операцию P над семафором буфера. Операция P над семафором будет  вы-
полняться,  несмотря на то, что операция CP уже потерпела неудачу. По завер-
шении выполнения операции процесс A получает власть над буфером. Так  как  в
оставшейся  части алгоритма предполагается, что буфер и хеш-очередь захваче-
ны, процесс A теперь пытается захватить хеш-очередь .  Поскольку  очеред-
ность  захвата здесь (сначала семафор буфера, потом семафор очереди) обратна
вышеуказанной очередности, над семафором выполняется операция CP.  Если  по-
пытка захвата заканчивается неудачей, имеет место обычная обработка, требую-
щаяся  по  ходу задачи. Но если захват удается, ядро не может быть уверено в
<pre>
    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
    і алгоритм getblk           /* многопроцессорная версия */   і
    і входная информация:  номер файловой системы                і
    і                      номер блока                           і
    і выходная информация: захваченный буфер, предназначенный дляі
    і                      обработки содержимого блока           і
    і {                                                          і
    і    выполнять (пока буфер не будет обнаружен)               і
    і    {                                                       і
    і       P(семафор хеш-очереди);                              і
    і       если (блок находится в хеш-очереди)                  і
    і       {                                                    і
    і          если (операция CP(семафор буфера) завершается не- і
    і           удачно)       /* буфер занят */                  і
    і          {                                                 і
    і             V(семафор хеш-очереди);                        і
    і             P(семафор буфера);      /* приостанов до момен-і
    і                                      * та освобождения     і
    і                                      */                    і
    і             если (операция CP(семафор хеш-очереди) заверша-і
    і              ется неудачно)                                і
    і             {                                              і
    і                V(семафор буфера);                          і
    і                продолжить;     /* выход в цикл "выполнять" і
    і                                 */                         і
    і             }                                              і
    і             в противном случае если (номер устройства или  і
    і              номер блока изменились)                       і
    і             {                                              і
    і                V(семафор буфера);                          і
    і                V(семафор хеш-очереди);                     і
    і             }                                              і
    і          }                                                 і
    і          выполнять (пока операция CP(семафор списка свобод-і
    і           ных буферов) не завершится успешно)              і
    і             ;    /* "кольцевой цикл" */                    і
    і          пометить буфер занятым;                           і
    і          убрать буфер из списка свободных буферов;         і
    і          V(семафор списка свободных буферов);              і
    і          V(семафор хеш-очереди);                           і
    і          вернуть буфер;                                    і
    і       }                                                    і
    і       в противном случае   /* буфер отсутствует в хеш-     і
    і                             * очереди                      і
    і                             */                             і
    і       /* здесь начинается выполнение оставшейся части алго-і
    і        * ритма                                             і
    і        */                                                  і
    і    }                                                       і
    і }                                                          і
    АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ

      Рисунок 12.14. Выделение буфера с использованием семафоров
  </pre>
<p>том, что захвачен корректный буфер, поскольку содержимое буфера  могло  быть
ранее изменено другим процессом, обнаружившим буфер в списке свободных буфе-
ров и захватившим на время его семафор. Процесс A, ожидая освобождения сема-
фора,  не  имеет  ни малейшего представления о том, является ли интересующий
его буфер тем буфером, который ему нужен, и поэтому прежде всего  он  должен
убедиться  в правильности содержимого буфера; если проверка дает отрицатель-
ный результат, алгоритм запускается сначала. Если содержимое буфера коррект-
но, процесс A завершает выполнение алгоритма.                 </p>
<pre>
    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
    і многопроцессорная версия алгоритма wait                    і
    і {                                                          і
    і     для (;;)       /* цикл */                              і
    і     {                                                      і
    і         перебор всех процессов-потомков:                   і
    і         если (потомок находится в состоянии "прекращения   і
    і          существования")                                   і
    і              вернуть управление;                           і
    і         P(zombie_semaphore);   /* начальное значение - 0 */і
    і     }                                                      і
    і }                                                          і
    АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ

       Рисунок 12.15. Многопроцессорная версия алгоритма wait

 </pre>
    Оставшуюся часть алгоритма можно рассмотреть в качестве упражнения.


    <h2> Wait</h2>

 <p>   Мы знаем о том, что во время выполнения системной функции
wait процесс приостанавливает свою работу до момента  завершения  выполнения
своего потомка. В многопроцессорной системе перед процессом встает задача не
упустить  при выполнении алгоритма wait потомка, прекратившего существование
с помощью функции exit; если, например, в то время, пока на одном процессоре
процесс-родитель запускает функцию wait, на другом  процессоре  его  потомок
завершил  свою  работу, родителю нет необходимости приостанавливать свое вы-
полнение в ожидании завершения второго потомка. В каждой записи таблицы про-
цессов имеется семафор, именуемый zombie_semaphore и имеющий в начале  нуле-
вое  значение.  Этот  семафор  используется  при  организации взаимодействия
wait/exit (Рисунок 12.15). Когда потомок завершает работу, он выполняет  над
семафором  своего родителя операцию V, выводя родителя из состояния приоста-
нова, если тот перешел в него во время исполнения функции wait. Если потомок
завершился раньше, чем родитель запустил функцию wait, этот факт будет обна-
ружен родителем, который тут же выйдет из состояния ожидания. Если оба  про-
цесса  исполняют функции exit и wait параллельно, но потомок исполняет функ-
цию exit уже после того, как родитель проверил его статус, операция  V,  вы-
полненная потомком, воспрепятствует переходу родителя в состояние приостано-
ва. В худшем случае процесс-родитель просто повторяет цикл лишний раз.
          </p>

<h2> Драйверы</h2>

</p>    В  многопроцессорной реализации вычислительной системы на базе компьюте-
ров AT&T 3B20 семафоры в структуру загрузочного кода драйверов не  включают-
ся,  а  операции типа P и V выполняются в точках входа в каждый драйвер. В главе 10 мы говорили о том, что интерфейс, реализуемый драйве-
рами устройств, характеризуется очень небольшим числом точек входа (на прак-
тике их около 20). Защита драйверов осуществляется на уровне точек  входа  в
них:
<pre>
    P(семафор драйвера);
    открыть (драйвер);
    V(семафор драйвера);
</pre>
<p>    Если  для всех точек входа в драйвер использовать один и тот же семафор,
но при этом для разных драйверов  -  разные  семафоры,  критический  участок
программы  драйвера  будет  исполняться процессом монопольно. Семафоры могут
назначаться как отдельному устройству, так и классам устройств. Так,  напри-
мер, отдельный семафор может быть связан и с отдельным физическим терминалом
и  со  всеми терминалами сразу. В первом случае быстродействие системы выше,
ибо процессы, обращающиеся к терминалу, не захватывают семафор, имеющий  от-
ношение  к  другим терминалам, как во втором случае. Драйверы некоторых уст-
ройств, однако, поддерживают внутреннюю связь с другими драйверами; в  таких
случаях использование одного семафора для класса устройств облегчает понима-
ние  задачи.  В качестве альтернативы в вычислительной системе 3B20A предос-
тавлена возможность такого конфигурирования отдельных устройств, при котором
программы драйвера запускаются на точно указанных процессорах.</p>
<p>    Проблемы возникают тогда, когда драйвер прерывает работу системы  и  его
семафор  захвачен: программа обработки прерываний не может быть вызвана, так
как иначе возникла бы угроза разрушения данных. С другой  стороны,  ядро  не
может оставить прерывание необработанным. Система 3B20A выстраивает прерыва-
ния  в  очередь  и ждет момента освобождения семафора, когда вызов программы
обработки прерываний не будет иметь опасные последствия.</p>


<h2>    Фиктивные процессы</h2>

<p>    Когда ядро выполняет переключение контекста в однопроцессорной  системе,
оно  функционирует  в  контексте процесса, уступающего управление. Если в системе нет процессов, готовых к запуску, ядро переходит в состо-
яние простоя в контексте процесса, выполнявшегося последним. Получив  преры-
вание  от  таймера или других периферийных устройств, оно обрабатывает его в
контексте того же процесса.</p>
<p>    В многопроцессорной системе ядро не может простаивать в  контексте  про-
цесса,  выполнявшегося  последним. Посмотрим, что произойдет после того, как
процесс, приостановивший свою работу на процессоре A,  выйдет  из  состояния
приостанова.  Процесс в целом готов к запуску, но он запускается не сразу же
по выходе из состояния приостанова, даже несмотря на то,  что  его  контекст
уже  находится в распоряжении процессора A. Если этот процесс выбирается для
запуска процессором B, последний переключается на его контекст и возобновля-
ет его выполнение. Когда в результате прерывания процессор A выйдет из прос-
тоя, он будет продолжать свою работу в контексте процесса A до тех пор, пока
не произведет переключение контекста. Таким  образом,  в  течение  короткого
промежутка  времени с одним и тем же адресным пространством (в частности, со
стеком ядра) будут вести работу (и, что весьма вероятно, производить запись)
сразу два процессора.</p>
<p>    Решение этой проблемы состоит в создании некоторого фиктивного процесса;
когда процессор находится в состоянии простоя, ядро  переключается  на  кон-
текст  фиктивного  процесса, делая этот контекст текущим для бездействующего
процессора. Контекст фиктивного процесса состоит только из стека ядра;  этот
процесс не является выполнимым и не выбирается для запуска. Поскольку каждый
процессор  простаивает  в контексте своего собственного фиктивного процесса,
навредить друг другу процессоры уже не могут.</p>
</body>
</html>
