<HTML>
<HEAD>
<title>ќтображаема€ пам€ть</title>
</HEAD>
<body>
       <h1>  јЌјЋџ</h1>

<p>     аналы позвол€ют передавать данные между процессами в пор€дке  поступлени€  ("первым  пришел  - первым вышел"), а также синхронизировать выполнение
процессов. »х использование  дает  процессам  возможность  взаимодействовать
между собой, пусть даже не известно, какие процессы наход€тс€ на другом конце
  канала.  “радиционна€ реализаци€ каналов использует файловую систему дл€
хранени€ данных. –азличают два вида каналов: поименованные каналы и, за  отсутствием
  лучшего  термина, непоименованные каналы, которые идентичны между
собой во всем, кроме способа первоначального обращени€ к ним процессов.  ƒл€
поименованных  каналов процессы используют системную функцию open, а системную
 функцию<span class=term> pipe </span>- дл€ создани€ непоименованного канала.  ¬последствии,  при
работе с каналами процессы пользуютс€ обычными системными функци€ми дл€ файлов,
  такими как <span class=term>read, write и close</span>. “олько св€занные между собой процессы,
€вл€ющиес€ потомками того процесса, который вызвал функцию<span clas=term> pipe</span>, могут  раздел€ть
  доступ  к непоименованным каналам. Ќапример (см. –исунок 5.15), если
процесс B создает канал и порождает процессы D и E, эти три процесса 
 раздел€ют  между собой доступ к каналу, в отличие от процессов A и C. ќднако, все
процессы могут обращатьс€ к поименованному каналу независимо от  взаимоотношений
 между ними, при условии наличи€ обычных прав доступа к файлу. ѕоскольку непоименованные каналы встречаютс€ чаще, они будут рассмотрены первыми.
</p>
<h2>   —истемна€ функци€ pipe</h2>

    —интаксис вызова функции создани€ канала:

<span class=term>    pipe(fdptr)</span>;

<p>где <span class=term> fdptr</span>  -  указатель на массив из двух целых переменных, в котором будут
хранитьс€ два дескриптора файла дл€ чтени€ из канала и дл€ записи  в  канал.
ѕоскольку €дро реализует каналы внутри файловой системы и поскольку канал не
существует до того, как его будут использовать, €дро должно при создании 
канала назначить ему индекс. ќно также назначает дл€ канала пару пользовательских дескрипторов и соответствующие им записи в таблице файлов: один из дескрипторов  дл€ чтени€ из канала, а другой дл€ записи в канал. ѕоскольку €дро
пользуетс€ таблицей файлов, интерфейс дл€ вызова функций<span class=term> read, write </span> и  др.
согласуетс€ с интерфейсом дл€ обычных файлов. ¬ результате процессам нет надобности знать, ведут ли они чтение или запись в обычный файл или в канал.</p>
<pre>
    Џƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒњ
    ≥ алгоритм pipe                                              ≥
    ≥ входна€ информаци€:  отсутствует                           ≥
    ≥ выходна€ информаци€: дескриптор файла дл€ чтени€           ≥
    ≥                      дескриптор файла дл€ записи           ≥
    ≥ {                                                          ≥
    ≥    назначить новый индекс из устройства канала (алгоритм   ≥
    ≥     ialloc);                                               ≥
    ≥    выделить одну запись в таблице файлов дл€ чтени€, одну -≥
    ≥     дл€ переписи;                                          ≥
    ≥    инициализировать записи в таблице файлов таким образом, ≥
    ≥     чтобы они указывали на новый индекс;                   ≥
    ≥    выделить один пользовательский дескриптор файла дл€ чте-≥
    ≥     ни€, один - дл€ записи, проинициализировать их таким   ≥
    ≥     образом, чтобы они указывали на соответствующие точки  ≥
    ≥     входа в таблице файлов;                                ≥
    ≥    установить значение счетчика ссылок в индексе равным 2; ≥
    ≥    установить значение счетчика числа процессов, производ€-≥
    ≥     щих чтение, и процессов, производ€щих запись, равным 1;≥
    ≥ }                                                          ≥
    јƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒў

       –исунок 5.16. јлгоритм создани€ каналов (непоименованных)
 </pre>

<p>    Ќа  –исунке 5.16 показан алгоритм создани€ непоименованных каналов. ядро
назначает индекс дл€ канала из файловой системы, обозначенной как "устройст-
во канала", использу€ алгоритм <span class=term>ialloc</span>. ”стройство канала  -  это  именно  та
файлова€ система, из которой €дро может назначать каналам индексы и выдел€ть
блоки  дл€  данных.  јдминистраторы  системы указывают устройство канала при
конфигурировании системы и эти устройства могут совпадать у разных  файловых
систем.  ѕока канал активен, €дро не может переназначить индекс канала и ин-
формационные блоки канала другому файлу.                    </p>
<p>    «атем €дро выдел€ет в таблице файлов две записи,  соответствующие  деск-
рипторам  дл€ чтени€ и записи в канал, и корректирует "бухгалтерскую" инфор-
мацию в копии индекса в пам€ти. ¬ каждой из  выделенных  записей  в  таблице
файлов  хранитс€  информаци€  о  том, сколько экземпл€ров канала открыто дл€
чтени€ или записи (первоначально 1), а счетчик ссылок в  индексе  указывает,
сколько раз канал был "открыт" (первоначально 2 - по одному дл€ каждой запи-
си таблицы файлов). Ќаконец, в индексе записываютс€ смещени€ в байтах внутри
канала  до места, где будет начинатьс€ следующа€ операци€ записи или чтени€.
Ѕлагодар€ сохранению этих смещений в индексе имеетс€ возможность производить
доступ к данным в канале в пор€дке их поступлени€ в канал ("первым пришел  -
первым  вышел");  этот  момент  €вл€етс€ особенностью каналов, поскольку дл€
обычных файлов смещени€ хран€тс€ в таблице файлов. ѕроцессы не могут  мен€ть
эти смещени€ с помощью системной функции lseek и поэтому произвольный доступ
к данным канала невозможен.</p>

<h2> ќткрытие поименованного канала</h2>

<p>    ѕоименованный  канал - это файл, имеющий почти такую же семантику, как и
непоименованный канал, за исключением того, что  этому  файлу  соответствует
запись  в каталоге и обращение к нему производитс€ по имени. ѕроцессы откры-
вают поименованные каналы так же, как и обычные файлы, и,  следовательно,  с
помощью  поименованных каналов могут взаимодействовать между собой даже про-
цессы, не имеющие друг к другу близкого отношени€. ѕоименованные каналы пос-
то€нно присутствуют в иерархии файловой системы (из которой они удал€ютс€  с
помощью системной функции unlink), а непоименованные каналы €вл€ютс€ времен-
ными:  когда  все процессы заканчивают работу с каналом, €дро отбирает назад
его индекс.</p>
<p>    јлгоритм открыти€ поименованного  канала  идентичен  алгоритму  открыти€
обычного  файла.  ќднако, перед выходом из функции €дро увеличивает значени€
тех счетчиков в индексе, которые показывают количество процессов,  открывших
поименованный  канал дл€ чтени€ или записи. ѕроцесс, открывающий поименован-
ный канал дл€ чтени€, приостановит свое выполнение до тех пор,  пока  другой
процесс  не  откроет  поименованный  канал  дл€ записи, и наоборот. Ќе имеет
смысла открывать канал дл€ чтени€, если процесс не надеетс€ получить данные;
то же самое касаетс€ записи. ¬ зависимости от того, открывает ли процесс по-
именованный канал дл€ записи или дл€ чтени€,  €дро  возобновл€ет  выполнение
тех процессов, которые были приостановлены в ожидании процесса, записывающе-
го в поименованный канал или считывающего данные из канала (соответственно).</p>
<p>    ≈сли  процесс  открывает поименованный канал дл€ чтени€, причем процесс,
записывающий в канал, существует, открытие завершаетс€. »ли если процесс от-
крывает поименованный файл с параметром "no delay", функци€ open  возвращает
управление  немедленно,  даже когда нет ни одного записывающего процесса. ¬о
всех остальных случа€х процесс приостанавливаетс€ до тех пор, пока записыва-
ющий процесс не откроет канал. јналогичные правила действуют  дл€  процесса,
открывающего канал дл€ записи.</p>


<h2>„тение из каналов и запись в каналы</h2>

<p>     анал  следует  рассматривать под таким углом зрени€, что процессы ведут
запись на одном конце канала, а считывают данные на другом  конце.   ак  уже
говорилось  выше, процессы обращаютс€ к данным в канале в пор€дке их поступ-
лени€ в канал; это означает, что очередность, в которой данные  записываютс€
в канал, совпадает с очередностью их выборки из канала. —овпадение количест-
ва процессов, считывающих данные из канала, с количеством процессов, ведущих
запись в канал, совсем не об€зательно; если одно число отличаетс€ от другого
более, чем на 1, процессы должны координировать свои действи€ по использова-
нию  канала  с  помощью других механизмов. ядро обращаетс€ к данным в канале
точно так же, как и к данным в обычном файле: оно сохран€ет данные  на  уст-
ройстве  канала  и  назначает каналу столько блоков, сколько нужно, во врем€
выполнени€ функции write. –азличие в выделении пам€ти дл€ канала и дл€</p>

<pre>
           Џƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ¬ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒњ
           ≥  ”казатель чтени€  ≥  ”казатель записи  ≥
           јƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒЅƒƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒў
                      ≥   Џƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒў
                      јƒƒ ≥ ƒƒƒƒƒƒƒƒƒƒƒƒƒƒњ
                          v               v
            Џƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒ¬ƒƒƒњ
            ≥ 0 ≥ 1 ≥ 2 ≥ 3 ≥ 4 ≥ 5 ≥ 6 ≥ 7 ≥ 8 ≥ 9 ≥
            јƒƒƒЅƒƒƒЅƒƒƒЅƒƒƒЅƒƒƒЅƒƒƒЅƒƒƒЅƒƒƒЅƒƒƒЅƒƒƒў
             Ѕлоки пр€мой адресации в индексе

      –исунок 5.17. Ћогическа€ схема чтени€ и записи в канал
</pre>
     
<p>обычного файла состоит в том, что канал использует в  индексе  только  блоки
пр€мой адресации в цел€х повышени€ эффективности работы, хот€ это и наклады-
вает  определенные  ограничени€ на объем данных, одновременно помещающихс€ в
канале. ядро работает с блоками пр€мой адресации индекса как  с  циклической
очередью,  поддержива€ в своей структуре указатели чтени€ и записи дл€ обес-
печени€ очередности обслуживани€ "первым пришел  -  первым  вышел"  (–исунок
5.17).</p>
<p>    –ассмотрим  четыре примера ввода-вывода в канал: запись в канал, в кото-
ром есть место дл€ записи данных; чтение из  канала,  в  котором  достаточно
данных  дл€  удовлетворени€  запроса  на чтение; чтение из канала, в котором
данных недостаточно; и запись в канал, где нет места дл€ записи.</p>
<p>    –ассмотрим первый случай, в котором процесс ведет запись в канал,  имею-
щий  место  дл€  ввода  данных:  сумма количества записываемых байт с числом
байт, уже наход€щихс€ в канале, меньше или равна емкости канала. ядро следу-
ет алгоритму записи данных в обычный файл, за исключением того, что оно уве-
личивает размер канала автоматически после каждого выполнени€ функции write,
поскольку по определению объем данных в канале растет с каждой операцией за-
писи. »наче происходит увеличение размера обычного файла: процесс увеличива-
ет размер файла только тогда, когда он при записи данных переступает границу
конца файла. ≈сли следующее смещение в канале  требует  использовани€  блока
косвенной  адресации,  €дро  устанавливает  значение смещени€ в пространстве
процесса таким образом, чтобы оно указывало на  начало  канала  (смещение  в
байтах, равное 0). ядро никогда не затирает данные в канале; оно может сбро-
сить  значение смещени€ в 0, поскольку оно уже установило, что данные не бу-
дут переполн€ть емкость канала.  огда процесс запишет в канал все свои  дан-
ные,  €дро откорректирует значение указател€ записи (в индексе) канала таким
образом, что следующий процесс продолжит запись в канал с  того  места,  где
остановилась  предыдуща€  операци€  write.  «атем €дро возобновит выполнение
всех других процессов, приостановленных в ожидании считывани€ данных из  ка-
нала.</p>
<p>     огда  процесс  запускает функцию чтени€ из канала, он провер€ет, пустой
ли канал или нет. ≈сли в канале есть данные, €дро  считывает  их  из  канала
так,  как  если  бы канал был обычным файлом, выполн€€ соответствующий алго-
ритм. ќднако, начальным смещением будет значение указател€ чтени€,  хран€ще-
гос€ в индексе и показывающего прот€женность прочитанных ранее данных. ѕосле
считывани€ каждого блока €дро уменьшает размер канала в соответствии с коли-
чеством  считанных  данных  и устанавливает значение смещени€ в пространстве
процесса так, чтобы при достижении конца канала оно указывало на его начало.
 огда выполнение системной функции read завершаетс€, €дро  возобновл€ет  вы-
полнение  всех приостановленных процессов записи и запоминает текущее значе-
ние указател€ чтени€ в индексе (а не в записи таблицы файлов).</p>
<p>    ≈сли процесс пытаетс€ считать больше информации, чем фактически  есть  в
канале, функци€ read завершитс€ успешно, возвратив все данные, наход€щиес€ в
данный  момент в канале, пусть даже не полностью выполнив запрос пользовате-
л€. ≈сли канал пуст, процесс обычно приостанавливаетс€ до тех пор, пока  ка-
кой-нибудь другой процесс не запишет данные в канал, после чего все приоста-
новленные  процессы,  ожидающие  ввода  данных, возобнов€т свое выполнение и
начнут конкурировать за чтение из канала. ≈сли,  однако,  процесс  открывает
поименованный  канал  с  параметром  "no delay" (без задержки), функци€ read
возвратит управление немедленно, если в канале отсутствуют данные.  ќперации
чтени€  и  записи  в канал имеют ту же семантику, что и аналогичные операции
дл€ терминальных устройств (глава 10), она позвол€ет процессам  игнорировать
тип тех файлов, с которыми эти программы имеют дело.             </p>
<p>    ≈сли  процесс ведет запись в канал и в канале нет места дл€ всех данных,
€дро помечает индекс и приостанавливает выполнение процесса до тех пор, пока
канал не начнет очищатьс€ от данных.  огда впоследствии другой процесс будет
считывать данные из канала, €дро заметит существование  процессов,  приоста-
новленных  в ожидании очистки канала, и возобновит их выполнение подобно то-
му, как это было объ€снено выше. »сключением из этого  утверждени€  €вл€етс€
ситуаци€,  когда  процесс записывает в канал данные, объем которых превышает
емкость канала (то есть, объем данных, которые могут хранитьс€ в блоках пр€-
мой адресации); в этом случае €дро записывает в канал столько данных, сколь-
ко он может вместить в себ€, и приостанавливает процесс до тех пор, пока  не
освободитс€ дополнительное место. “аким образом, возможно положение, при ко-
тором записываемые данные не будут занимать непрерывное место в канале, если
другие  процессы  ведут запись в канал в то врем€, на которое первый процесс
прервал свою работу.</p>
<p>    јнализиру€ реализацию каналов, можно заметить, что  интерфейс  процессов
согласуетс€  с интерфейсом обычных файлов, но его воплощение отличаетс€, так
как €дро запоминает смещени€ дл€ чтени€ и записи в индексе вместо того, что-
бы делать это в таблице файлов. ядро вынуждено хранить значени€ смещений дл€
поименованных каналов в индексе дл€ того, чтобы процессы могли совместно ис-
пользовать эти значени€: они не могли бы  совместно  использовать  значени€,
хран€щиес€ в таблице файлов, так как процесс получает новую запись в таблице
файлов  по каждому вызову функции open. “ем не менее, совместное использова-
ние смещений чтени€ и записи в индексе наблюдалось и до реализации  поимено-
ванных  каналов. ѕроцессы, обращающиес€ к непоименованным каналам, раздел€ют
доступ к каналу через общие точки входа в таблицу файлов, поэтому они  могли
бы  по  умолчанию хранить смещени€ записи и чтени€ в таблице файлов, как это
прин€то дл€ обычных файлов. Ёто не было сделано, так как  процедуры  низкого
уровн€,  работающие в €дре, больше не имеют доступа к запис€м в таблице фай-
лов: программа упростилась за счет того, что процессы  совместно  используют
значени€ смещений, хран€щиес€ в индексе.</p>
<h2>«акрытие каналов</h2>

<p>  ѕри  закрытии  канала процесс выполн€ет ту же самую процедуру, что и при
закрытии обычного файла, за исключением того, что €дро, прежде  чем  освобо-
дить индекс канала, выполн€ет специальную обработку. ќно уменьшает количест-
во  процессов чтени€ из канала или записи в канал в зависимости от типа фай-
лового дескриптора. ≈сли значение счетчика числа записывающих в  канал  про-
цессов  становитс€  равным 0 и имеютс€ процессы, приостановленные в ожидании
чтени€ данных из канала, €дро возобновл€ет выполнение последних и они завер-
шают свои операции чтени€ без возврата каких-либо  данных.  ≈сли  становитс€
равным  0  значение счетчика числа считывающих из канала процессов и имеютс€
процессы, приостановленные в ожидании возможности записи данных в канал, €д-
ро возобновл€ет выполнение последних и посылает им сигнал (глава 7) об ошиб-
ке. ¬ обоих случа€х не имеет смысла продолжать держать процессы  приостанов-
ленными,  если нет надежды на то, что состо€ние канала когда-нибудь изменит-
с€. Ќапример, если процесс ожидает возможности производить чтение из  непои-
менованного канала и в системе больше нет процессов, записывающих в этот ка-
нал,  значит,  записывающий процесс никогда не по€витс€. Ќесмотр€ на то, что
если канал поименованный, в принципе возможно по€вление нового  считывающего
или  записывающего  процесса, €дро трактует эту ситуацию точно так же, как и
дл€ непоименованных каналов. ≈сли к каналу не обращаетс€ ни один  записываю-
щий или считывающий процесс, €дро освобождает все информационные блоки кана-
ла  и  переустанавливает  индекс таким образом, чтобы он указывал на то, что
канал пуст.  огда €дро освобождает индекс обычного канала,  оно  освобождает
дл€ переназначени€ и дисковую копию этого индекса.</p>

<h2>ѕримеры</h2>

<p>    ѕрограмма на –исунке 5.18 иллюстрирует искусственное использование кана-
лов.  ѕроцесс  создает  канал и входит в бесконечный цикл, записыва€ в канал
<pre>
               Џƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒњ
               ≥ char string[] = "hello";        ≥
               ≥ main()                          ≥
               ≥ {                               ≥
               ≥    char buf[1024];              ≥
               ≥    char *cp1,*cp2;              ≥
               ≥    int fds[2];                  ≥
               ≥                                 ≥
               ≥    cp1 = string;                ≥
               ≥    cp2 = buf;                   ≥
               ≥    while(*cp1)                  ≥
               ≥          *cp2++ = *cp1++;       ≥
               ≥    pipe(fds);                   ≥
               ≥    for (;;)                     ≥
               ≥    {                            ≥
               ≥        write(fds[1],buf,6);     ≥
               ≥        read(fds[0],buf,6);      ≥
               ≥    }                            ≥
               ≥ }                               ≥
               јƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒў

         –исунок 5.18. „тение из канала и запись в канал
</pre>
<p>строку символов "hello" и считыва€ ее из канала. ядру не нужно  ни  знать  о
том,  что процесс, ведущий запись в канал, €вл€етс€ и процессом, считывающим
из канала, ни про€вл€ть по этому поводу какое-либо беспокойство.</p>
<p>    ѕроцесс, выполн€ющий программу, котора€ приведена на –исунке 5.19,  соз-
дает поименованный канал с именем "fifo". ≈сли этот процесс запущен с указа-
нием второго (формального) аргумента, он пос-</p>
<pre>
    Џƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒњ
    ≥ #include &lt;fcntl.h&gt;                                         ≥
    ≥ char string[] = "hello";                                   ≥
    ≥ main(argc,argv)                                            ≥
    ≥     int argc;                                              ≥
    ≥     char *argv[];                                          ≥
    ≥ {                                                          ≥
    ≥     int fd;                                                ≥
    ≥     char buf[256];                                         ≥
    ≥                                                            ≥
    ≥ /* создание поименованного канала с разрешением чтени€ и   ≥
    ≥    записи дл€ всех пользователей */                        ≥
    ≥     mknod("fifo",010777,0);                                ≥
    ≥     if(argc == 2)                                          ≥
    ≥          fd = open("fifo",O_WRONLY);                       ≥
    ≥     else                                                   ≥
    ≥          fd = open("fifo",O_RDONLY);                       ≥
    ≥     for (;;)                                               ≥
    ≥          if(argc == 2)                                     ≥
    ≥               write(fd,string,6);                          ≥
    ≥          else                                              ≥
    ≥               read(fd,buf,6);                              ≥
    ≥ }                                                          ≥
    јƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒў

         –исунок 5.19. „тение и запись в поименованный канал
</pre>
<p>то€нно записывает в канал строку символов "hello"; будучи запущен без второ-
го  аргумента, он ведет чтение из поименованного канала. ƒва процесса запус-
каютс€ по одной и той же программе,  тайно  договорившись  взаимодействовать
между  собой  через поименованный канал "fifo", но им нет необходимости быть
родственными процессами. ƒругие пользователи  могут  выполн€ть  программу  и
участвовать в диалоге (или мешать ему).</p>

</body>
