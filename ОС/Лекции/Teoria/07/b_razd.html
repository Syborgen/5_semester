<HTML>
<HEAD>
<title>Общая память</title>
</HEAD>
<body>

<h1> Разделение памяти</h1>

<p>    Процессы  могут  взаимодействовать  друг  с другом непосредственно путем
разделения (совместного использования) участков виртуального адресного прос-
транства и обмена данными через разделяемую память.  Системные  функции  для
работы с разделяемой памятью имеют много сходного с системными функциями для
работы с сообщениями. Функция shmget создает новую область разделяемой памя-
ти  или  возвращает  адрес уже существующей области, функция shmat логически
присоединяет область к виртуальному адресному пространству процесса, функция
shmdt отсоединяет ее, а функция<span class=term> shmctl </span>имеет дело с различными  параметрами,
связанными  с  разделяемой  памятью. Процессы ведут чтение и запись данных в
области разделяемой памяти, используя для этого те же самые машинные  коман-
ды,  что  и при работе с обычной памятью. После присоединения к виртуальному
адресному пространству процесса область разделяемой памяти  становится  дос-
тупна так же, как любой участок виртуальной памяти; для доступа к находящим-
ся в ней данным не нужны обращения к каким-то дополнительным системным функ-
циям.
<p>    Синтаксис вызова системной функции shmget:
<pre>
<span class=term>    shmid = shmget(key,size,flag);</span>
</pre>
<p> где <span class=term> size</span> - объем области в байтах. Ядро использует
<span class=term>key</span> для ведения поиска в
таблице разделяемой памяти: если подходящая запись обнаружена и если  разре-
шение  на  доступ  имеется, ядро возвращает вызывающему процессу указанный в
записи дескриптор. Если запись не найдена и если пользователь установил флаг
<span class=term>IPC_CREAT</span>, указывающий на необходимость создания новой области, ядро  прове-
ряет нахождение размера области в установленных системой пределах и выделяет
область по алгоритму<span class=term> allocreg</span>. Ядро записывает установки прав
доступа, размер области и указатель на соответствующую запись таблицы облас-
тей в таблицу разделяемой памяти (Рисунок 11.9) и устанавливает флаг, свиде-
тельствующий  о том, что с областью не связана отдельная память. Области вы-
деляется память (таблицы страниц и т.п.) только тогда, когда процесс присое-
диняет область к своему адресному  пространству.  Ядро  устанавливает  также
флаг,  говорящий  о  том, что по завершении последнего связанного с областью
процесса область не должна освобождаться. Таким образом, данные в  разделяе-
мой памяти остаются в сохранности, даже если она не принадлежит ни одному из
процессов (как часть виртуального адресного пространства последнего). 
<pre>
    Таблица раз-                             Таблица процессов -
    деляемой па-       Таблица областей      частная таблица об-
       мяти                                    ластей процесса
    ЪДДДДДДДДДДї       ЪДДДДДДДДДДДДДДї          ЪДДДДДДДДДї
    і      ДДДДЕДДДДї  і              і     ЪДДДДЕДДДД     і
    ГДДДДДДДДДДґ   ЪіД>ГДДДДДДДДДДДДДДґ<ДДДДЩ    ГДДДДДДДДДґ
    і      ДДДДЕДДДЩі  і              і      ЪДДДЕДДДД     і
    ГДДДДДДДДДДґ    і  ГДДДДДДДДДДДДДДґ<ДДДДїі   ГДДДДДДДДДґ
    і      ДДДДЕДДї і  і              і     АіДДДЕДДДД     і
    ГДДДДДДДДДДґ  і і  ГДДДДДДДДДДДДДДґ      і   ГДДДДДДДДДґ
    і     щ    і  і і  і              і      і   і         і
    і     щ    і  і АД>ГДДДДДДДДДДДДДДґ      і   ГДДДДДДДДДґ
    і     щ    і  і    і              і      і   і         і
    і     щ    і  АДДД>ГДДДДДДДДДДДДДДґ<ДДДДДЩ   ГДДДДДДДДДґ
    і     щ    і       і              і  (после  і         і
    і     щ    і       ГДДДДДДДДДДДДДДґ   shmat) ГДДДДДДДДДґ
    і     щ    і       і      щ       і          і         і
    і     щ    і       і      щ       і          ГДДДДДДДДДґ
    і     щ    і       АДДДДДДДДДДДДДДЩ          і    щ    і
    і     щ    і                                 і    щ    і
    АДДДДДДДДДДЩ                                 АДДДДДДДДДЩ

    Рисунок 11.9. Структуры данных, используемые при разделении памяти

</pre>
<p>    Процесс  присоединяет  область  разделяемой памяти к своему виртуальному
адресному пространству с помощью системной функции shmat:
<pre>
  <span class=term>  virtaddr = shmat(id,addr,flags)</span>;
</pre>
<p>Значение <span class=term>id</span>, возвращаемое функцией <span class=term>shmget</span>, идентифицирует область  разделяе-
мой  памяти,<span class=term> addr</span> является виртуальным адресом, по которому пользователь хо-
чет подключить область, а с помощью флагов<span class=term> (flags)</span> можно указать, предназна-
чена ли область только для чтения и нужно ли ядру округлять значение указан-
ного пользователем адреса. Возвращаемое функцией значение, virtaddr,  предс-
тавляет  собой виртуальный адрес, по которому ядро произвело подключение об-
ласти и который не всегда совпадает с адресом, указанным пользователем.   </p>
<p>    В начале выполнения системной функции shmat  ядро  проверяет  наличие  у
процесса  необходимых  прав доступа к области (Рисунок 11.10). Оно исследует
указанный пользователем адрес; если он равен 0,  ядро  выбирает  виртуальный
адрес по своему усмотрению.</p>
<p>    Область разделяемой памяти не должна пересекаться в виртуальном адресном
пространстве  процесса  с  другими областями; следовательно, ее выбор должен
производиться разумно и осторожно. Так, например,  процесс  может  увеличить
размер  принадлежащей  ему области данных с помощью системной функции brk, и
новая область данных будет содержать адреса, смежные с прежней областью; по-
этому, ядру не следует присоединять область разделяемой памяти слишком близ-
ко к области данных процесса. Так же не следует размещать область  разделяе-
мой  памяти вблизи от вершины стека, чтобы стек при своем последующем увели-
чении не залезал за ее пределы. Если, например, стек  растет  в  направлении
увеличения адресов, лучше всего разместить область разделяемой памяти непос-
редственно перед началом области стека.</p>
<pre>

    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
    і алгоритм shmat     /* подключить разделяемую память */     і
    і входная информация:  (1) дескриптор области разделяемой    і
    і                          памяти                            і
    і                      (2) виртуальный адрес для подключения і
    і                          области                           і
    і                      (3) флаги                             і
    і выходная информация: виртуальный адрес, по которому областьі
    і                      подключена фактически                 і
    і {                                                          і
    і     проверить правильность указания дескриптора, права до- і
    і      ступа к области;                                      і
    і     если (пользователь указал виртуальный адрес)           і
    і     {                                                      і
    і          округлить виртуальный адрес в соответствии с фла- і
    і           гами;                                            і
    і          проверить существование полученного адреса, размері
    і           области;                                         і
    і     }                                                      і
    і     в противном случае   /* пользователь хочет, чтобы ядро і
    і                           * само нашло подходящий адрес */ і
    і          ядро выбирает адрес: в случае неудачи выдается    і
    і           ошибка;                                          і
    і     присоединить область к адресному пространству процесса і
    і      (алгоритм attachreg);                                 і
    і     если (область присоединяется впервые)                  і
    і          выделить таблицы страниц и отвести память под нее і
    і           (алгоритм growreg);                              і
    і     вернуть (виртуальный адрес фактического присоединения  і
    і      области);                                             і
    і }                                                          і
    АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ

       Рисунок 11.10. Алгоритм присоединения разделяемой памяти
</pre>
<p>    Ядро  проверяет  возможность размещения области разделяемой памяти в ад-
ресном  пространстве  процесса  и  присоединяет  ее  с   помощью   алгоритма
attachreg. Если вызывающий процесс является первым процессом, который присо-
единяет  область, ядро выделяет для области все необходимые таблицы, исполь-
зуя алгоритм growreg, записывает время присоединения в соответствующее  поле
таблицы разделяемой памяти и возвращает процессу виртуальный адрес, по кото-
рому область была им подключена фактически.    </p>
<p>    Отсоединение области разделяемой памяти от виртуального адресного прост-
ранства процесса выполняет функция</p>

  <span class=term>  shmdt(addr)</span>

<p>где <span class=term> addr </span> - виртуальный адрес, возвращенный функцией <span class=term>shmat</span>. Несмотря на то,
что более логичной представляется передача идентификатора, процесс использу-
ет виртуальный адрес разделяемой памяти, поскольку одна и та же область раз-
деляемой памяти может быть подключена к адресному пространству процесса нес-
колько раз, к тому же ее идентификатор может быть удален  из  системы.  Ядро
производит  поиск области по указанному адресу и отсоединяет ее от адресного
пространства процесса, используя алгоритм <span class=term>detachreg</span>. Посколь-
ку в таблицах областей отсутствуют обратные указатели на таблицу разделяемой
памяти, ядру приходится просматривать таблицу разделяемой памяти  в  поисках
записи,  указывающей  на данную область, и записывать в соответствующее поле
время последнего отключения области.  </p>
<p>    Рассмотрим программу, представленную на Рисунке 11.11. В ней описывается
процесс, создающий область разделяемой памяти размером 128  Кбайт  и  дважды
присоединяющий  ее к своему адресному пространству по разным виртуальным ад-
ресам. В "первую" область он записывает данные, а читает их из "второй"  об-
ласти. На Рисунке 11.12 показан другой процесс, присоединяющий ту же область
(он получает только 64 Кбайта, таким образом, каждый процесс может использо-
вать разный объем области разделяемой памяти); он ждет момента, когда первый
процесс  запишет в первое принадлежащее области слово любое отличное от нуля
значение, и затем принимается считывать данные из  области.  Первый  процесс
делает  "паузу" <span class=term> (pause)</span>, предоставляя второму процессу возможность выполне-
ния; когда первый процесс принимает сигнал, он удаляет  область  разделяемой
памяти из системы.                             </p>
<p>    Процесс  запрашивает информацию о состоянии области разделяемой памяти и
производит установку параметров для нее с помощью системной функции <span class=term>shmctl</span>:</p>

<span class=term>    shmctl(id,cmd,shmstatbuf)</span>;

<p>Значение <span class=term>id </span>идентифицирует запись таблицы разделяемой памяти,<span class=term> cmd</span> определяет
тип операции, а<span class=term> shmstatbuf</span> является адресом  пользовательской  структуры,  в
которую  помещается информация о состоянии области. Ядро трактует тип опера-
ции точно так же, как и при управлении сообщениями. Удаляя область разделяе-
мой памяти, ядро освобождает соответствующую ей запись в таблице разделяемой
памяти и просматривает таблицу областей: если область не  была  присоединена
ни  к  одному из процессов, ядро освобождает запись таблицы и все выделенные
области ресурсы, используя для этого алгоритм freereg.  Если
же  область  по-прежнему  подключена к каким-то процессам (значение счетчика
ссылок на нее больше 0), ядро только сбрасывает флаг, говорящий о  том,  что
по  завершении  последнего связанного с нею процесса область не должна осво-
бождаться. Процессы, уже использующие область разделяемой памяти, продолжают
работать с ней, новые же процессы не могут присоединить ее. Когда  все  про-
цессы  отключат область, ядро освободит ее. Это похоже на то, как в файловой
системе после разрыва связи с файлом процесс может вновь открыть его и  про-
должать с ним работу.                                </p>
</body>
</html>
