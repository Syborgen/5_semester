<HTML>
<HEAD>
<title>Очереди сообщений</title>
</HEAD>
<body>
	<h1>Очереди сообщений</h1>
	<ul>
		<li><a href="#base">Базовые принципы</a></li>
		<li><a href="#struct">Внутренние и пользовательские структуры данных</a></li>
		<li><a href="#get">Системный вызов msgget()</a></li>
		<li><a href="#snd">Системный вызов msgsnd()</a></li>
		<li><a href="#rcv">Системный вызов msgrcv()</a></li>
		<li><a href="#ctl">Системный вызов msgctl()</a></li>
		<li><a href="#tool">msgtool: интерактивный обработчик очередей сообщений</a></li>
	</ul>
	<a name="base"></a>
	<h2>Базовые принципы</h2>
	<p>	Очереди сообщений представляют собой связный список в адресном
		пространстве ядра. Сообщения могут посылаться в очередь по порядку и
		доставаться из очереди несколькими разными путями. Каждая очередь
		сообщений однозначно определена идентификатором <span class="term">
		IPC</span>.
	<a name="struct"></a>
	<h2>Внутренние и пользовательские структуры данных</h2>
	<p>	Ключом к полному осознанию такой сложной системы, как <span class="term">
		System V IPC</span> , является более тесное знакомство с различными 
		структурами данных, которые лежат внутри самого ядра. Даже для большинства примитивных
		операций необходим прямой доступ к некоторым из этих структур, хотя
		другие используются только на гораздо более низком уровне.
	<h3>Буфер сообщения</h3>
	<p>	Первой структурой, которую мы рассмотрим, будет <span class="term"> 
		msgbuf</span> . Его можно понимать как шаблон для данных сообщения. 
		Поскольку данные в сообщении программист определяет сам, он обязан понимать,
		что на самом деле они являются структурой <span class="term"> msgbuf</span>.
		Его описание находится в &lt;linux/msg.h&gt;:
<pre>
	/* буфер сообщения для вызовов msgsnd и msgrcv*/
	struct msgbuf {
	    long mtype;          /* тип сообщения */
	    char mtext[1];       /* текст сообщения */
	};
</pre>
	<ul>
		<li>	<span class="term"> type </span> -	
			Тип сообщения, представленный натуральным числом. Он обязан быть
			натуральным!
		<li>	<span class="term"> mtext</span> - Собственно сообщение.
	</ul>
	<p>	Возможность приписывать тип конкретному сообщению позволяет
		держать в одной очереди разнородные сообщения. Это может понадобиться,
		например, когда сообщения процесса-клиента помечаются одним магическим
		числом, а сообщения сообщения процесса-сервера - другим; или
		приложение ставит в очередь сообщения об ошибках с типом 1,
		сообщения-запросы - с типом 2 и т.д. Ваши возможности просто
		безграничны.
	<p>	С другой стороны, старайтесь дать наглядное имя элементу данных
		сообщения (в примере был <span class="term"> mtext</span>). В это поле
		можно записывать не только
		массивы литер, но и вообще любые данные в любой форме. Поле
		действительно полностью произвольно, поэтому вся структура может быть
		переопределена программистом, например, так:
<pre>
	struct my_msgbuf {
	   long   mtype;         /* тип сообщения */
	   long   request_id;    /* идентификатор запроса */
	   struct client info;   /* информация о клиенте */
	}
</pre>
	<p>	Здесь мы также видим структуру сообщения, но второй элемент
		заменился на два, причем один из них - другая структура! В этом
		прелесть очередей сообщений, ядро не разбирает данные, какими бы они
		ни были.
	<p>	Существует, однако, ограничение на максимальный размер сообщения.
		В <span class="term"> LINUX</span>  он определен в &lt;linux/msg.h&gt;:
<pre>
	#define MSGMAX 4056 /* &lt;= 4056 */ /* максимальный размер 
				сообщения, в байтах*/
</pre>
	<p>	Сообщения не могут быть больше, чем 4056 байт, сюда входит и
		элемент <span class="term"> mtype</span> , который занимает 4 байта (long).
	<h3>Структура msg ядра</h3>
	<p>	Ядро хранит сообщение в очереди структуры <span class="term"> msg</span>.
		Она определена в &lt;linux/msg.h&gt; следующим образом:
<pre>
	struct msg {
	   struct msg *msg_next;   /* следующее сообщение в очереди */
	   long   msg_type;
	   char  *msg_spot;        /* адрес текста сообщения */
	   short  msg_ts;          /* размер текста */
	};
</pre>
	<ul>
		<li>	<span class="term"> msg_next </span> -
			Указатель на следующее сообщение в очереди. Сообщения объединены
			в односвязный список и находятся в адресном пространстве ядра.
		<li>	<span class="term"> msg_type </span> -
			 Тип сообщения, каким он был объявлен в <span class="term"> msgbuf</span> .
		<li>	<span class="term"> msg_spot </span> -
			Указатель на начало тела сообщения.
		<li>	<span class="term"> msg_ts </span> -
			Длина текста (или тела) сообщения.
			
	</ul>
	<h3>Структура msqid_ds ядра</h3>	
	<p>	Каждый из трех типов <span class="term"> IPC</span>-объектов имеет
		внутреннее представление,
		которое поддерживается ядром. Для очередей сообщений это структура
		<span class="term"> msqid_ds</span> .
		Ядро создает, хранит и сопровождает образец такой структуры
		для каждой очереди сообщений в системе. Она определена в &lt;linux/msg.h&gt; 
		следующим образом:
<pre>
	/* структура msqid для каждой очереди в системе */
	struct msqid_ds {
	   struct ipc_perm msg_perm;
	   struct msg *msg_first;     /* первое сообщение в очереди */
	   struct msg *msg_last;      /* последнее сообщение в очереди */
	   time_t msg_stime;          /* время последнего вызова msgsnd */
	   time_t msg_rtime;          /* время последнего вызова msgrcv */
	   time_t msg_ctime;          /* время последнего изменения */
	   struct wait_queue *wwait;
	   struct wait_queue *rwait;
	   ushort msg_cbytes;
	   ushort msg_qnum;
	   ushort msg_qbytes;         /* максимальное число байтов на очередь */
	   ushort msg_lspid;          /* pid последнего испустившего msgsnd */
	   ushort msg_lrpid;          /* последний полученный pid */
	};
</pre>
	<p>	Хотя большинство элементов этой структуры вас будет мало
		волновать, для какой-то законченности мы вкратце поясним каждый.
	<ul>
		<li>	<span class="term">   msg_perm	</span> -
			Экземпляр структуры <span class="term"> ipc_perm</span> ,
			определенной в &lt;linux/ipc.h&gt;. Она
			содержит информацию о доступе для очереди сообщений, включая права
			доступа и информацию о создателе сообщения (<span class="term"> uid</span> и т.п.).
		<li>	<span class="term"> msg_first </span> - 
			Ссылка на первое сообщение в очереди (голова списка).
		<li>	<span class="term"> msg_last </span> - 
			Ссылка на последний элемент списка (хвост списка).
		<li>	<span class="term"> msg_stime </span> -
			Момент времени посылки последнего сообщения из очереди.
		<li>	<span class="term"> msg_rtime </span> -
			Момент времени последнего изъятия элемента из очереди.
		<li>	<span class="term"> msg_ctime </span> -
			Момент времени последнего изменения, проделанного в очереди
			(подробнее об этом позже).
		<li>	<span class="term"> wwait </span> и <span class="term"> rwait </span> - 
			Указатели в очередь ожидания ядра. Они используются, когда
			операция над очередью сообщений переводит процесс в состояние спячки
			(то есть очередь переполнена, и процесс ждет открытия).
		<li>	<span class="term"> msg_cbytes </span> -
			Число байт, стоящих в очереди (суммарный размер всех сообщений).
		<li>	<span class="term"> msg_qnum </span> -
			Количество сообщений в очереди на настоящий момент.
		<li>	<span class="term"> msg_qbytes </span> -
			     Максимальный размер очереди.
		<li>	<span class="term"> msg_lspid </span> - 
			<span class="term"> PID </span> процесса, пославшего последнее в очереди сообщение.
		<li>	<span class="term"> msg_lrpid </span> -
			<span class="term"> PID </span> последнего процесса, взявшего из очереди сообщение.
	</ul>
	<h3>Структура ipc_perm ядра</h3>
	<p>	Информацию о доступе к IPC-объектам ядро хранит в структуре
		<span class="term"> ipc_perm</span> . 
		Например, описанная выше структура очереди сообщений
		содержит одну структуру типа <span class="term"> ipc_perm</span> 
		в качестве элемента. Следующее
		ее определение дано в &lt;linux/ipc.h&gt;.
<pre>
	struct ipc_perm {
	   key_t  key;
	   ushort uid;    /* euid и egid владельца */
	   ushort gid;   ushort cuid;   /* euid и egid создателя */
	   ushort cgid;
	   ushort mode;   /* режим доступа, см. режимные флаги ниже */
	   ushort seq;    /* порядковый номер использования гнезда */
	};
</pre>
	<p>	Все приведенное выше говорит само за себя. Сохраняемая отдельно
		вместе с ключом IPC-объекта информация содержит данные о владельце и
		создателе этого объекта (они могут различаться). Режимы восьмеричного
		доступа также хранятся здесь, как unsigned short. Наконец, сохраняется
		порядковый номер использования гнезда. Каждый раз когда IPC объект
		закрывается через системный вызов (уничтожается), этот номер
		уменьшается на максимальное число объектов IPC, которые могут
		находиться в системе. Касается вас это значение? Нет.


	<a name="get"></a>
	<h2>Системный вызов msgget()</h2>
	<p>	Системный вызов <span class="func"> msgget()</span>  нужен для того, чтобы создать очередь
		сообщений или подключиться к существующей.
	<p>	PROTOTYPE: int msgget( key_t key, int msgflg );
	<p>	RETURNS: идентификатор очереди сообщений в случае успеха; -1 в случае ошибки.
	<p>	Первый аргумент <span class="func"> msgget()</span>  значение ключа (мы его получаем при
		помощи <span class="func"> ftok()</span>). Этот ключ сравнивается с ключами уже существующих в
		ядре очередей. При этом операция открытия или доступа к очереди
		зависит от содержимого аргумента <span class="term"> msgflg</span> :
	<ul>
		<li>	<span class="term"> IPC_CREAT </span> -
			    Создает очередь, если она не была создана ранее.
		<li>	<span class="term"> IPC_EXCL </span> - 
			При использовании совместно с <span class="term"> IPC_CREAT</span> , 
			приводит к неудаче если
			очередь уже существует.
	</ul>
	<p>	Вызов <span class="func"> msgget()</span>  с <span class="term"> IPC_CREAT</span> ,
		но без <span class="term"> IPC_EXCL</span>  всегда выдает
		идентификатор (существующей с таким ключом или созданной) очереди.
		Использование <span class="term"> IPC_EXCL </span> вместе с <span class="term"> 
		IPC_CREAT </span>  либо создает новую очередь,
		либо, если очередь уже существует, заканчивается неудачей.
		Самостоятельно <span class="term"> IPC_EXCL </span>  бесполезен, но вместе c
		<span class="term"> IPC_CREAT </span> он дает
		гарантию, что ни одна из существующих очередей не открывается для
		доступа.
	<p>	Восьмеричный режим может быть OR-нут в маску доступа. Каждый
		IPC-объект имеет права доступа, аналогичные правам доступа к файлу в
		файловой системе UNIX-а.
	<p>
		Напишем оберточную функцию для открытия или создания очереди	сообщений.
<pre>
int open_queue( key_t keyval )
{
	int qid;

	if ((qid = msgget ( keyval, IPC_CREAT | 0660 )) == -1)
	{
		return (-1);
	}
	return (qid);
}
</pre>

	<p>     Отметьте использование точного ограничителя доступа 0660. Эта
		небольшая функция возвращает идентификатор очереди (int) или -1 в
		случае ошибки. Единственный требуемый аргумент - ключевое значение.

	<a name="snd"></a>
	<h2> Системный вызов msgsnd() </h2>
	<p>	Получив идентификатор очереди, мы можем выполнять над ней
		различные действия. Чтобы поставить сообщение в очередь, используйте
		системный вызов <span class="func"> msgsnd()</span> :
	<p>	PROTOTYPE: int msgsnd( int msqid, struct msgbuf *msgp, int msgsz, int msgflg );
	<p> 	RETURNS: 0 в случае успеха, -1 в случае ошибки:
     	<p>	Первый аргумент <span class="func"> msgsnd </span> - идентификатор нашей очереди,
		возвращенный предварительным вызовом <span class="func"> msgget</span> . 
		Второй аргумент, <span class="term"> msgp </span>  -
		это указатель на редекларированный и загруженный буфер сообщения.
		Аргумент <span class="term"> msgsz</span>  содержит длину сообщения в байтах, 
		не учитывая тип сообщения (long 4 байта).
		Аргумент <span class="term"> msgflg</span> может быть нулем или:
	<ul>
		<li>	<span class="term"> IPC_NOWAIT </span> -
			Если очередь переполнена, то сообщение не записывается в очередь,
			и управление передается вызывающему процессу. Если эта ситуация не
			обрабатывается вызывающим процессом, то он приостанавливается
			(блокируется), пока сообщение не будет прочитано.
	</ul>
	<p>	Напишем незатейливую оберточную функцию для посылки сообщения:
<pre>
int send_message( int qid, struct mymsgbuf *qbuf )
{
	int  result, length;

	/* Длина есть в точности размер структуры минус sizeof(mtype) */
	length = sizeof(struct mymsgbuf) - sizeof(long);

	if((result = msgsnd( qid, qbuf, length, 0)) == -1)
	{
		return(-1);
	}

	return(result);
}
</pre>
     	<p>	Эта функция пытается послать сообщение, лежащее по указанному
		адресу (<span class="term">qbuf</span>), в очередь сообщений, идентифицированную
		<span class="term"> qid</span> . Напишем небольшую утилиту с нашими 
		двумя оберточными функциями:
<pre>
	#include &lt;stdio.h&gt;
	#include &lt;stdlib.h&gt;
	#include &lt;linux/ipc.h&gt;
	#include &lt;linux/msg.h&gt; 

	main()
	{
		int qid;
		key_t msgkey;

		struct mymsgbuf {
			long   mtype;     /* тип сообщения */
			int    request;   /* рабочий номер запроса */
			double salary;    /* зарплата */
		} msg;

		/* Генерируем IPC-ключ */
		msgkey = ftok(".", 'm');

		/* Открываем/создаем очередь */
		if (( qid = open_queue( msgkey)) == -1) {
			perror("open_queue");
			exit(1);
		}

		/* Заполняем сообщение произвольными тестовыми данными */
		msg.type    = 1;  /* тип сообщения должен быть положительным! */
		msg.request = 1;  /* элемент данных 1 */
		msg.salary  = 1000.00; /* элемент данных 2
					  (моя годовая зарплата! - авт.) */

		/* Бомбим! */
		if((send_message( qid, &amp;msg )) == -1) {
			perror("send_message");
			exit(1);
		}
	}
</pre>
	<p>	После создания/открытия нашей очереди принимаемся за загрузку
		буфера сообщения с тестовыми данными (заметьте отсутствие текстовых
		данных для иллюстрации нашего положения о посылке двоичной
		информации). Вызов нашего <span class="func"> send_message</span> 
		ловко доставит сообщение в очередь.
	<p>     Теперь, когда мы имеем сообщение в очереди, попытайтесь при
		помощи <span class="term"> ipcs</span>  посмотреть на статус нашей очереди.
		Обсудим, как забрать
		из очереди сообщение. Для этого используется системный вызов<span class="func"> 
		msgrcv() </span> 
	
	<a name="rcv"></a>
	<h2> Системный вызов msgrcv()</h2>
	<p>	PROTOTYPE: int msgrcv( int msqid, struct msgbuf *msgp, int msgsz,
                       long mtype, $$)
	<p>	RETURNS: число байт, скопированных в буфер сообщения, -1 в случае ошибки.
	<p>	Конечно, первый аргумент определяет очередь, из которой будет
		взято сообщение (должен быть возвращен сделанным предварительно
		вызовом <span class="func"> msgget</span>) . Второй аргумент (<span class="term">
		msgp</span>) представляет собой адрес буфера, куда будет положено изъятое сообщение.
		Третий аргумент, <span class="term"> msgsz </span> ,
		ограничивает размер структуры-буфера без учета длины элемента <span class="term">mtype</span> .
		Еще раз повторимся, это может быть легко вычислено:
<pre>
	msgsz = sizeof(struct mymsgbuf) - sizeof(long);
</pre>
    	<p>	Четвертый аргумент, <span class="term"> mtype</span>  - это тип сообщения, изымаемого из
		очереди. Ядро будет искать в очереди наиболее старое сообщение такого
		типа и вернет его копию по адресу, указанному аргументом <span class="term"> msgp</span> .
		Существует один особый случай: если <span class="term"> mtype</span>  = 0, то будет возвращено
		наиболее старое сообщение, независимо от типа.
	<p>	Если <span class="term"> IPC_NOWAIT</span>  был послан флагом, и нет ни одного
		удовлетворительного сообщения, <span class="func"> msgrcv </span> вернет вызывающему процессу
		ENOMSG. В противном случае вызывающий процесс блокируется, пока в
		очередь не прибудет сообщение, соответствующее параметрам <span class="func"> msgrcv(). </span>
	<p>	Если, пока клиент ждет сообщения, очередь удаляется, то ему
		возвращается EIDRM. EINTR возвращается, если сигнал поступил, пока
		процесс находился на промежуточной стадии между ожиданием и
		блокировкой.
	<p>	Давайте рассмотрим функцию-переходник для изъятия сообщения из нашей очереди.
<pre>
int read_message( int qid, long type, struct mymsgbuf *qbuf )
{
	int   result, length;

	/* Длина есть в точности размер структуры минус sizeof(mtype) */
	length = sizeof(struct mymsgbuf) - sizeof(long);

	if((result = msgrcv( qid, qbuf, length, type, 0 )) == -1)
	{
		return(-1);
	}

	return(result);
}
</pre>
	<p>     После успешного изъятия сообщения удаляется из очереди и его ярлык.
	<p>	Бит <span class="term"> MSG_NOERROR</span>  в <span class="term"> msgflg</span> 
		предоставляет некоторые дополнительные возможности. 
		Если физическая длина сообщения больше, чем<span class="term"> msgsz</span> , и
		<span class="term"> MSG_NOERROR </span> установлен, то сообщение обрезается и возвращается только
		<span class="term"> msgsz </span> байт. Нормальный же <span class="func"> msgrcv() </span> 
		возвращает -1 (E2BIG), и сообщение остается в очереди до последующих запросов. 
		Такое поведение можно
		использовать для создания другой оберточной функции, которая позволит
		нам "подглядывать" внутрь очереди, чтобы узнать, пришло ли сообщение,
		удовлетворяющее нашему запросу.
<pre>
int peek_message( int qid, long type )
{
	int   result, length;

	if((result = msgrcv( qid, NULL, 0, type, IPC_NOWAIT )) == -1)
	{      if(errno == E2BIG)
		return(TRUE);
	}
	return(FALSE);
}
</pre>
	<p>     Выше вы заметили отсутствие адреса буфера и длины. В этом
		конкретном случае мы хотели, чтобы вызов прошел неудачно. Однако мы
		проверили возвращение E2BIG, которое должно показать, существует ли
		сообщение затребованного типа. Оберточная функция возвращает TRUE в
		случае успеха, и FALSE - в противном случае. Отметьте также
		установленный флаг <span class="term"> IPC_NOWAIT </span> , который 
		помешает блокировке, о которой мы говорили раньше.
	
	<a name="ctl"></a>
	<h2>Системный вызов msgctl()</h2>
	<p>	Благодаря использованию функций-переходников вы имеете некий
		элегантный подход к созданию и использованию очередей сообщений в
		ваших приложениях. Теперь коснемся непосредственно манипулирования
		внутренними структурами, связанными с данной очередью сообщений.
	<p>	Для осуществления контроля над очередью предназначен системный
		вызов <span class="func"> msgсtl</span> .
	<p>	PROTOTYPE: int msgctl ( int msgqid, int cmd, struct msqid_ds *buf );
	<p> 	RETURNS: 0 в случае успеха,-1 в случае неудачи
	<p>	Теперь из общих соображений ясно, что прямые манипуляции с
		внутреностями ядра могут привести к очень занимательным последствиям.
		К сожалению, по-настоящему весело будет только тому, кто любит
		вдребезги и с наслаждением крушить подсистему <span class="term"> IPC
		</span> . Однако при использовании <span class="func"> msgctl()</span> 
		с некоторыми командами вероятность огорчительных результатов не очень 
		велика. Вот их и рассмотрим.
	<ul>
		<li>	<span class="term"> IPC_STAT </span> -
			Сохраняет по адресу <span class="term"> buf</span>  структуру
			<span class="term"> msqid_ds</span> для очереди сообщений.
		<li> 	<span class="term"> IPC_SET </span> -
			Устанавливает значение элемента <span class="term"> ipc_perm
			</span> структуры <span class="term"> msqid</span> .
			Значения выбирает из буфера.
		<li>	<span class="term"> IPC_RMID </span>  -
			Удаляет очередь из ядра.
	</ul>
	<p>	Вернемся к нашему разговору о внутреннем представлении очереди
		сообщений: <span class="term"> msqid_ds</span> .
		Ядро держит экземпляр этой структуры для каждой
		очереди, существующей в системе. <span class="term"> IPC_STAT</span> 
		дает возможность заиметь
		копию такой структуры для испытаний. Посмотрим на оберточную функцию,
		которая берет эту структуру и размещает копию по указанному адресу.
<pre>
int get_queue_ds( int qid, struct msgqid_ds *qbuf )
{
	if( msgctl( qid, IPC_STAT, qbuf) == -1 )
	{
		return(-1);
	}

	return(0);
}
</pre>
	<p>	Если копирование во внутренний буфер невозможно, то вызывающей
		функции возвращается -1. Если же все прошло нормально, то возвращается
		0, и посланный буфер должен содержать копию внутренней структуры
		данных для очереди с идентификатором <span class="term"> qid</span>.
	<p>	Что же мы можем делать с полученной копией структуры?
		Единственное, что можно поменять, это элемент <span class="term"> ipc_perm</span>. 
		Это права доступа очереди, информация о создателе и владельце очереди. Однако и
		отсюда менять позволено только <span class="term">  mode, uid</span>  и
		<span class="term"> gid</span> .
	<p>	Давайте напишем оберточную функцию, изменяющую режим доступа
		очереди. Режим должен быть передан как массив литер (например, "660").
<pre>	
int change_queue_mode( int qid, char *mode )
{
	struct msqid_ds tmpbuf;

	/* Берем текущую копию внутренней структуры */
	get_queue_ds( qid, &amp;tmpbuf );

	/* Применяем уже известный прикол для изменения прав доступа */
	sscanf(mode, "%ho", &amp;tmpbuf.msg_perm.mode);   /* Модернизируем внутреннюю структуру */
	if( msgctl( qid, IPC_SET, &amp;tmpbuf ) == -1 )
	{
		return(-1);
	}

	return(0);
}
</pre>
	<p>	Мы взяли текущую копию внутренней структуры данных посредством
		вызова нашей <span class="term"> get_queue_ds</span> ; затем <span class="func"> 
		sscanf()</span>  меняет элемент <span class="term"> mode </span> 
		структуры <span class="term"> msg_perm</span> . Однако ничего не произойдет,
		пока <span class="func"> msgctl</span>  c <span class="term"> IPC_SET </span> 
		не обновил внутреннюю версию.
	<p>	ОСТОРОЖНО! Изменяя права доступа, можно случайно лишить прав себя
		самого! Помните, что IPC-объекты не исчезают, пока они не уничтожены
		должным образом или не перезагружена система. Поэтому то, что вы не
		видите очереди ipcs-ом, не означает, что ее нет на самом деле.
	<p>	После того, как сообщение взято из очереди, оно удаляется.
		Однако, как отмечалось ранее, IPC-объекты остаются в системе до
		персонального удаления или перезапуска всей системы. Поэтому наша
		очередь сообщений все еще существует в ядре и пригодна к употреблению
		в любое время, несмотря на то, что последнее его соообщение уже давно
		на небесах. Чтобы и душа нашей очереди с миром отошла к богам, нужен
		вызов <span class="func"> msgctl()</span> , использующий команду 
		<span class="term"> IPC_RMID</span> :
<pre>
int remove_queue( int qid )
{
	if( msgctl( qid, IPC_RMID, 0) == -1)
	{
		return(-1)
	}

	return(0);
}
</pre>
	<p>	Эта функция-переходник возвращает 0, если очередь удалена без
		инцедентов, в противном случае ввыдается -1. Удаление очереди неделимо
		и попытка любого обращения к ней будет безуспешной.
	<a name="tool"></a>
     <h2>msgtool: интерактивный обработчик очередей сообщений</h2>
	<p>	Мало кто станет отрицать непосредственную выгоду от возможности в
		любой момент получить точную техническую информацию. Подобные
		материалы представляют собой мощный механизм для обучения и
		исследования новых областей. Однако, неплохо было бы добавить к
		технической информации и реальные примеры. Это непременно ускорит и
		укрепит процесс обучения.
	<p>	До сей поры все то хорошее, что мы сделали - это оберточные
		функции для манипуляций с очередями сообщений. Хотя они чрезвычайно
		полезны, ими неудобно пользоваться для дальнейшего обучения и
		экспериментов. Существует средство, позволяющее работать с
		IPC-очередями из командной строки - <span class="func"> msgtool()</span> .
		Хотя <span class="func"> msgtool()</span>  будет
		использован в целях обучения, он пригодится и реально при написании
		скриптов.
	<h3>Описание</h3>
	<p>	Поведение <span class="term"> msgtool()</span>-а зависит от аргументов командной строки, что
		удобно для вызова из скрипта <span class="term"> shell</span> . Позволяет делать все что угодно,
		от создания, посылки и получения сообщений до редактирования прав
		доступа и удаления очереди. Изначально данными сообщений могут быть
		только литерные массивы. Упражнение - измените это так, чтобы можно
		было посылать и другие данные.
	<h3>Синтаксис командной строки</h3>
	<p>	Посылка сообщений - <span class="code"> msgtool s (type) "text" </span> 
	<p>	Изъятие сообщений - <span class="code"> msgtool r (type) </span> 
	<p>	Изменение прав доступа - <span class="code"> msgtool m (mode) </span> 
	<p>	Уничтожение очереди - <span class="code"> msgtool d </span> 
	<p>     Примеры
<pre>
   msgtool  s  1 test
   msgtool  s  5 test
   msgtool  s  1 "This is test"
   msgtool  r  1
   msgtool  d
   msgtool  m  660
</pre>
     	<h3>Код</h3>
	<p>	Следующее, что мы рассмотрим, это исходный текст <span class="term"> msgtool</span> 
		. Его следует компилировать в версии системы, которая поддерживает System V
		IPC. Убедитесь в наличии System V IPC в ядре, когда будете
		пересобирать программу!
	<p>	На полях отметим, что наша утилита будет всегда создавать
		очередь, если ее не было.
	<p>	Замечание. Поскольку <span class="term"> msgtool </span> использует <span class="func"> 
		ftok()</span>  для генерации
		ключей IPC, вы можете нарваться на конфликты, связанные с
		директориями. Если вы где-то в скрипте меняете директории, то все это
		наверняка не сработает. Это обходится путем более явного указания пути
		в msgtool, вроде "/tmp/msgtool", или даже запроса пути из командной
		строки вместе с остальными аргументами.
<pre>
/****************************************************************************
  Excerpt from "Linux Programmer's Guide - Chapter 6"
  (C)opyright 1994-1995, Scott Burkett
 ****************************************************************************
 MODULE: msgtool.c
 ****************************************************************************
 Средство командной строки для работы со очередями сообщений в стиле SysV
 ****************************************************************************/

#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;ctype.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/ipc.h&gt;
#include &lt;sys/msg.h&gt;
#define MAX_SEND_SIZE 80

struct mymsgbuf {
	long mtype;
	char mtext[MAX_SEND_SIZE];
};

void send_message(int qid, struct mymsgbuf *qbuf, long type, char *text);
void read_message(int qid, struct mymsgbuf *qbuf, long type);
void remove_queue(int qid);
void change_queue_mode(int qid, char *mode);
void usage(void);

int main(int argc, char *argv[])
{
	key_t key;
	int msgqueue_id;
	struct mymsgbuf qbuf;

	if(argc == 1)
		usage();

	/* Создаем уникальный ключ через вызов ftok() */
	key = ftok(".",'m');

	/* Открываем очередь - при необходимости создаем */
	if((msgqueue_id = msgget(key, IPC_CREAT|0660)) == -1) {
		perror("msgget");
		exit(1);
	}

	switch(tolower(argv[1][0]))
	{
		case 's': send_message(msgqueue_id, (struct mymsg buf *)&amp;qbuf,
					  atol(argv[2]), argv[3]);
			  break;
		case 'r': read_message(msgqueue_id, &amp;qbuf, atol(argv[2]));
			  break;
		case 'd': remove_queue(msgqueue_id);
			  break;
		case 'm': change_queue_mode(msgqueue_id, argv[2]);
			  break;
		default:  usage();
	}   return(0);
}

void send_message(int qid, struct mymsgbuf *qbuf, long type, char *text)
{
	/* Посылаем сообщение в очередь */
	printf("Sending a message ...\n");
	qbuf-&gt;mtype = type;
	strcopy(qbuf-&gt;mtext, text);

	if((msgsnd(qid, (struct msgbuf *)qbuf,
					strlen(qbuf-&gt;mtext)+1, 0)) == -1)
	{
		perror("msgsnd");
		exit(1);
	}
}

void read_message(int qid, struct mymsgbuf *qbuf, long type)
{
	/* Вычитываем сообщение из очереди */
	printf("Reading a message ...\");
	qbuf-&gt;mtype = type;
	msgrcv(qid, (struct msgbuf *)qbuf, MAX_SEND_SIZE, type, 0);

	printf("Type: %ld Text: %s\n", qbuf-&gt;mtype, qbuf-&gt;mtext);
}

void remove_queue(int qid)
{
	/* Удаляем очередь */
	msgctl(qid, IPC_RMID, 0);
}

void change_queue_mode(int qid, char *mode)
{
	struct msqid_ds myqueue_ds;

	/* Получаем текущее состояние */
	msgctl(qid, IPC_STAT, &amp;myqueue_ds);

		/* Меняем состояние в копии внутренней структуры данных */
		sscanf(mode, "%ho", &amp;myqueue_ds.msg_perm.mode)

		/* Обновляем состояние в самой внутренней структуре данных */
		msgctl(qid, IPC_SET, &amp;myqueue_ds);
}

void usage(void)
{
	fprintf(stderr, "msgtool - A utility for tinkering with msg queues\n");
	fprintf(stderr, "\nUSAGE: msgtool (s)end <TYPE> <MESSAGETEXT>\n");
	fprintf(stderr, "                 (r)ecv <TYPE>\n");
	fprintf(stderr, "                 (d)elete\n");
	fprintf(stderr, "                 (m)ode <OCTAL mode>\n");
	exit(1);
}

</pre>
</body>
