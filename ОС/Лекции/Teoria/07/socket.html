<HTML>
<HEAD>
<title>Сокеты</title>
</HEAD>
<body>
	<h1>Сокеты</h1>
	<ul>
		<li><a href="#basic">Основы сокетов</a></li>
		<li><a href="#server">Серверы</a></li>
		<li><a href="#local">Локальные сокеты</a></li>
		<li><a href="#local_example">Пример использования локальных сокетов</a></li>
		<li><a href="#inet">Internet-Domain сокеты</a></li>
		<li><a href="#pair">Пары сокетов</a></li>
	</ul>
	
	<p>	Сокет - устройство двунаправленной связи, которое может использоваться для взаимодействия с 
		другим процессом на одной и той же машине или с процессом, запущенным на других машинах. 
		Программы Интернета такие как <span class="term"> Telnet, rlogin, FTP, talk</span> , 
		и <span class="term"> World Wide Web</span> используют сокеты.
	<p>	Например, можно получить WWW-страницу от сервера Web, используя программу 
		<span class="term"> Telnet</span> , так как они обе используют сокеты  для
		сетевого взаимодействия. Для открытия подключения с сервером WWW на www.codesourcery.com,
		необходимо использовать <span class="term"> telnet www.codesourcery.com 80</span>. 
		Константа 80 определяет подключение к Web серверу. Если после того, как подключение будет 
		установлено, передать команду get /, то Web серверу через сокеты будет отправлено сообщение,
		на которое он ответит, передав исходный текст домашней HTML страницы и затем закроет подключение.
	<p>	Пример:
<pre>
	% telnet www.codesourcery.com 80
	Trying 206.168.99.1...
	Connected to merlin.codesourcery.com (206.168.99.1).
	Escape character is '^]'.
	GET /
	&lt;html&gt;
	&lt;head&gt;
	&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
	...
</pre>

	<a name="basic"></a>	
	<h2>Основы сокетов</h2> 
	<p>	При создании сокета, необходимо определить три параметра: стиль взаимодействия, 
		пространство имен, и пртокол. Стиль взаимодействия контролирует, как сокет 
		обрабатывает передаваемые данные, и определяет количество партнеров взаимодействия.
		Через сокеты данные передаются блоками (пакетами). Стиль взаимодействия определяет,
		как эти пакеты будут обработаны и как они передаются от отправителя к получателю.
	<ul>
		<li>	Стили соединения гарантируют доставку всех пакетов в том порядке, в каком они были 
			отправлены. Если во время передачи  пакеты были потеряны или доставлены в 
			неправильном порядке, получатель автоматически отправляет запрос на их
			повторную передачу. Стиль соединения напоминает телефонный звонок: адреса
			отправителя и получателя фиксируются в начале соединения, при установке подключения.
		</li>
		<li>	Стили датаграм не гарантирует доставки и правильного порядка прибытия. Пакеты могут быть
			потеряны или переупорядочены в пути из-за сетевых ошибок. Каждый пакет должен быть помечен
			его адресатом, и нет гарантии, что он будет доставлен. Система гарантирует только
			"максимальные усилия", поэтому пакеты могут исчезнуть или прибыть в различном 
			порядке. Сокет стиля датаграмы ведет себя сходно с почтой. Отправитель определяет
			адрес получателя для каждого индивидуального сообщения.
		</li>
	</ul>
	<p>	Пространство имен определяет, как записаны адреса сокета (<span class="term"> socket 
		addresses</span> ). Адрес сокета идентифицирует один конец подключения сокета. Например,
		адреса сокета в локальном пространстве имен являются обычными именами файлов. В 
		пространстве имен Интернет адрес сокета состоит из Интернет адреса (<span class="term"> 
		IP </span>  адрес) главного компьютера, присоединенного к сети и номера порта, который
		идентифицирует сокет среди множества сокетов на том же главном компьютере. 
	<p>	Протокол определяет, как передаются данные. Существуют следующие виды протоколов:
		<span class="term"> TCP/IP </span> , первичные сетевые протоколы, используемые 
		Интернетом; сетевой протокол <span class="term"> AppleTalk</span> ; локальный 
		<span class="term"> UNIX </span> протокол взаимодействия. Не все комбинации стилей, 
		пространств имен и протоколов поддерживаются.
	<h3>Системные вызовы</h3>
	<p>Виды системных вызовов:
	<ul>
		<li>	<span class="func"> socket</span>  - создать сокет
		<li>	<span class="func"> closes</span>  - уничтожить сокет
		<li> 	<span class="func"> connect</span>  - создать соединение между двумя сокетами
		<li>	<span class="func"> bind</span>  - привязать сокет к порту сервера
		<li> 	<span class="func"> listen</span>  - настройка сокета для принятия подключений
		<li>	<span class="func"> accept</span>  - принять запрос на соединение и создать сокет 
			для процесса взаимодействия
	</ul>
	<p>	Сокеты представляются дескрипторами файлов.
	<h3>Создание и уничтожение сокетов</h3>
	<p>	С помощью функций <span class="func"> socket</span>  и <span class="func"> close</span> 
		создаются и уничтожаются сокеты. При создании сокета, необходимо определить три параметра
		сокета: пространство имен, стиль взаимодействия и протокол.
	<p>	Для указания пространства имен
		используются константы, начинающиеся с <span class="term"> PF_ </span> (сокращение "семейство
		протокола"). Например, <span class="term"> PF_LOCAL </span> или <span class="term"> PF_UNIX 
		</span> определяют локальное пространство имен, и <span class="term"> PF_INET </span> 
		определяет Интернет пространство имен. 
	<p>	Второй параметр, стиль взаимодействия, представляет
		собой константу, начинающиюся с <span class="term"> SOCK_</span> .<span class="term"> 
		SOCK_STREAM</span>  опеределяет стиль взаимодейтсвия соединение, <span class="term"> SOCK_DGRAM
		</span> - стиль датаграмы.
	<p>	Третий параметр, протокол, определяет механизм нижнего уровня для передачи и получения данных.
		Для каждой комбинации пространство имен - стиль взаимоделйствия существует свой протокол. 
	<p>	Для каждой пары существует лучший протокол, поэтому можно указать 0, что соответсвует этому 
		протоколу. Если команда <span class="func"> socket</span>  выполнена успешно, в качестве
		результата возвращается дескриптор файла для сокета. С помощью команд <span class="func"> 
		read </span> и <span class="func"> write</span> , можно читать и записывать данные в сокет. 
	<h3>Вызов connect</h3>
	<p>	Для создания соединение между двумя сокетами, клиент вызывает <span class="func"> connect
		</span> , передавая адрес сокета сервера для подключения. Клиент - процесс, инициализирующий 
		соединение, а сервер - процесс, ожидающий разрешения соединения. Клиент посылает запрос 
		<span class="func"> connect</span> , чтобы инициализировать соединение между локальным
		сокетом и сокетом сервера, переданным в качестве второго параметра. В качестве третьего
		параметра передается длина, в байтах, адресной структуры, на которую указывает второй параметр. 

	<h3>Отправка данных</h3>
	<p>	Любая техника записи в дескриптор файла, может использоваться при записи в сокет. 
		Функция <span class="func"> send</span> , определенная для дескрипторов файлов сокета, 
		аналогична функции <span class="func"> write </span> с несколькими дополнительными 
		параметрами.
		
	<a name="server"></a>
	<h2>Серверы</h2> 
	<p>	Цикл жизни сервера состоит из создания сокета, привязки сокета к адресу, вызова 
		<span class="func"> listen</span> , разрешающего соединение с сокетом, вызова 
		<span class="func"> accept</span> , принимающего входящие соединения, и затем закрытия 
		сокета. Данные не читаются и не записываются непосредственно через 
		сокет сервера; вместо этого, каждый раз когда программа принимает новое соединение, 
		<span class="term"> Linux </span> создает отдельный сокет, используется при передаче
		данных по этому соединению. В этом разделе рассматриваются вызовы <span class="func"> 
		bind, listen </span> и <span class="func"> accept</span> .
	<p>	С помощью команды <span class="func"> bind </span> адрес сервера должен быть привязан 
		к сокету. Первый параметр команды - дескриптор файла сокета. Второй параметр - указатель
		на структуру адреса сервера; формат которого зависит от семейства адреса. Третий параметр
		- длина структуры адреса, в байтах. 
	<p>	Когда адрес связан с сокетом стиля соединение, необходимо вызвать <span class="func"> 
		listen</span> , чтобы указать, что это - сервер. 
		Первый параметр команды - дескриптор файла сокета. Второй параметр определяет, длину 
		очереди ожидающих соединений. Если очередь заполнена, дополнительные соединения будут
		отвергнуты. Это не ограничивает общее количество соединений, которые сервер может 
		обработать; это ограничивает только число клиентов, пытающихся соединиться и не 
		получивших подтверждение.
	<p>	С помощью команды <span class="func"> accept </span> сервер принимает запрос на соединение
		от клиента. Первый параметр вызова - дескриптор файла сокета. Второй параметр указывает на
		структуру адреса сокета, в которой хранится адрес клиентского сокета. 
		Третий параметр - длина, в байтах, структуры адреса сокета. 
		Сервер может использовать адрес клиента, чтобы определить, требуется ли действительно 
		взаимодействовать с клиентом.
	<p> 	Вызов <span class="func"> accept </span> создает новый сокет для взаимодействия с 
		клиентом и возвращает соответствующий дескриптор файла. Оригинальный сокет сервера 
		продолжает принимать новые клиентские соединения. 
	<p>	Для чтения данных из сокета, без 
		удаления их из входной очереди, используется команда <span class="func"> recv</span> .
		В качестве параметров передаются теже аргументы, что и в команде<span class="func"> 
		read</span> , плюс дополнительный параметр <span class="term"> FLAGS</span> . Флаг
		<span class="term"> MSG_PEEK</span>  указывает, что данные должны быть прочитаны,
		но не удалены из входной очереди.
		
	<a name="local"></a>
	<h2>Локальные сокеты</h2>
	<p>	Сокеты, подключающие процессы на одном компьютере могут использовать локальное пространство имен,
		представляющий собой синоним для <span class="term"> PF_LOCAL</span>  и <span class="term"> 
		PF_UNIX</span> . Они называются локальными сокетами или сокетами UNIX-домена. Адреса этих
		сокетов, определяемые именами файлов, используются только при создании соединения.
	<p>	Имя сокета указывается в структуре <span class="term"> sockaddr_un</span> . Если в 
		<span class="term"> AF_LOCAL</span>  установлено поле <span class="term"> sun_family</span> ,
		это указывает на то, что адрс в докальном пространстве имен. Поле <span class="term"> 
		Sun_path </span> указывает, что используется имя файла; максимальная длина поля - 108 байт. 
		Для вычисления длины <span class="term"> struct sockaddr_un</span>  используется макрокоманда
		<span class="term"> SUN_LEN</span> . Может использоваться любое имя файла,
		но для процесса должно быть установлено право на запись в каталог. Чтоб соединениться с сокетом,
		процесса должен иметь право на чтения файла. Хотя различные компьютеры могут совместно
		использовать одну файловую систему, только процессы, запущенные на этом компьютере, 
		могут взаимодействовать используя сокеты локального пространства имен.
	<p>	Единственный допустимый протокол для локального пространства имен - 0. 
		Поскольку он находится в файловой системе, локальный сокет представлен как файл.
	<p>	Например, обратите внимание на начальную s:
<pre>
	% ls -l /tmp/socket
	srwxrwx--x 1 user group 0 Nov 13 19:18 /tmp/socket
</pre>
	<p>	Вызов <span class="func"> unlink</span>  удаляет локальный сокет, при завершении работы с ним.
	
	<a name="local_example"></a>
	<h2>Пример использования локальных сокетов</h2>
	<p>	В листинге 5.10 представлена программа сервера, в которой создается локальный сокет 
		и слушает запросы на соединения с сервером. При получении запроса на соединение,  
		сервер читает текстовые сообщения, передаваемые через соединение и печатает их. 
		Если одно из этих сообщений - "выход", программа сервера удаляет сокет и завершается.
		Программа socket-server предполагает, что путь к сокету передается через параметр 
		командной строки.
	<p>	Листинг 5.10 (<a href="socket-server.c">socket-server.c</a>)
<pre>
	#include &lt;stdio.h&gt;
	#include &lt;stdlib.h&gt;
	#include &lt;string.h&gt;
	#include &lt;sys/socket.h&gt;
	#include &lt;sys/un.h&gt;
	#include &lt;unistd.h&gt;
	/* 	Чтение текста из сокета и вывод его на печать. Продолжение цикла до закрытия сокета. 
	 *	В качестве результата возвратит не ноль, если клиент передал сообщение "quit", иначе 0 */
	int server (int client_socket)
	{
		while (1) {
			int length;
			char* text;
			/* Сначала из сокета прочитать длину текстого сообщения. Если в качестве результата возвратиться 0,
			   то клиент закрыл соединение */
			if (read (client_socket, &amp;ength, sizeof (length)) == 0)
				return 0;
			/* выделить место в буфере для хранения текста */
			text = (char*) malloc (length);
			/* Чтение текста и распечатка */
			read (client_socket, text, length);
			printf ("%s\n", text);
			/* Освободить буфер */
			free (text);
			/* Если от клиента поступило сообщение "quit", завершить работу */
			if (!strcmp (text, "quit"))
				return 1;
		}
	}
	int main (int argc, char* const argv[])
	{
		const char* const socket_name = argv[1];
		int socket_fd;
		struct sockaddr_un name;
		int client_sent_quit_message;
		/* Создать сокет */
		socket_fd = socket (PF_LOCAL, SOCK_STREAM, 0);
		/* Определить что это сервер */
		name.sun_family = AF_LOCAL;
		strcpy (name.sun_path, socket_name);
		bind (socket_fd, &amp;name, SUN_LEN (&amp;name));
		/* Слушать (ожидать) соединения */
		listen (socket_fd, 5);
		/* Неоднократно принимать соединения, создавая для каждого клиента server().
		   Продолжать до получения от клиента сообщения "quit" */
		do {
			struct sockaddr_un client_name;
			socklen_t client_name_len;
			int client_socket_fd;
			/* Принимать соединение */
			client_socket_fd = accept (socket_fd, &amp;client_name, &amp;client_name_len);
			client_sent_quit_message = server (client_socket_fd);
			/* Закрыть соединение с нашей стороны */
			close (client_socket_fd);
		}
		while (!client_sent_quit_message);
		/* Удалить файл сокета */
		close (socket_fd);
		unlink (socket_name);
		return 0;
	}
</pre>
	<p>	Клиент-программа, представленная в листинге 5.11, соединяется с локальным сокетом 
		и посылает сообщения. Путь к сокету и сообщения передаtтся через командную строку. 
	<p>	Листинг 5.11(<a href="socket-client.c">socket-client.c</a>)
<pre>
	#include &lt;stdio.h&gt;
	#include &lt;string.h&gt;
	#include &lt;sys/socket.h&gt;
	#include &lt;sys/un.h&gt;
	#include &lt;unistd.h&gt;
	/* Записать TEXT в сокет, переданный дескриптором файла SOCKET_FD */
	void write_text (int socket_fd, const char* text)
	{
		/* Записать в строку количество байт, включая NUL-терминал */
		int length = strlen (text) + 1;
		write (socket_fd, &amp;length, sizeof (length));
		/* Записать строку */
		write (socket_fd, text, length);
	}
	int main (int argc, char* const argv[])
	{
		const char* const socket_name = argv[1];
		const char* const message = argv[2];
		int socket_fd;
		struct sockaddr_un name;
		/* Создать сокет */
		socket_fd = socket (PF_LOCAL, SOCK_STREAM, 0);
		/* Сохранить имя сервера в адресе сокета */
		name.sun_family = AF_LOCAL;
		strcpy (name.sun_path, socket_name);
		/* Соединиться с сокетом */
		connect (socket_fd, &amp;name, SUN_LEN (&amp;name));
		/* Записать текст командной строки в сокет */
		write_text (socket_fd, message);
		close (socket_fd);
		return 0;
	}
</pre>
	<p>	Перед передачей сообщения, посылается размер сообщения в байтах в качестве переменной length.
		Сервер сохраняет размер сообщения, для выделения памяти под сообщение. Чтобы выполнить этот 
		пример, необходимо запустить сервер-программу в одном окне, определить путь к сокету.
	<p>	Например, <span class="term"> /tmp/socket</span> .
<pre>
	% ./socket-server /tmp/socket
</pre>
	<p>	В  другом окне запустить клиент-программу несколько раз, опеределяя один и тот же путь
		сокета и посылая клиенту сообщение:
<pre>
	% ./socket-client /tmp/socket "Hello, world."
	% ./socket-client /tmp/socket "This is a test."
</pre>
	<p>	Сервер-программа получает и печатает эти сообщения. Для закрытия соединения, 
		клиент посылает сообщение "quit":
<pre>
	% ./socket-client /tmp/socket "quit"
</pre>	
	<p>	Сервер-программа завершена.
	
	<a name="inet"></a>
	<h2>Internet-Domain сокеты</h2> 
	<p>	Cокеты UNIX-domain использоваться только для взаимодействия двух процессов только 
		на одном компьютере. Сокеты Internet, используются для соединения нескольких процессов
		на различных машинах, подключенных к сети.
	<p>	Для соединения процессов через Интернет сокеты используют пространство имен Интернет 
		указываемое с помощью <span class="term"> PF_INET</span> . Большинство протоколов являются 
		<span class="term"> TCP/IP</span> . Интернет протокол (<span class="term"> IP</span>), 
		протокол нижнего уровня, отправляет пакеты через Интернет, разбивая на меньшие пакеты,
		в случае необходимости. Он гарантирует только доставку "лучшего усилия", так что пакеты 
		могут быть потеряны или переупорядочены во время транспортировки. Каждый компьютер имеет
		<span class="term"> IP</span>  адрес. Протокол управления передачей (<span class="term"> 
		TCP</span> ), который следует за <span class="term"> IP </span> протоколом, обеспечивает 
		надежное подключение. Это позволяет установить между компьютерами соединение, наподобие 
		телефонного и гарантирует доставку данных в парвильном порядке.
	<p>	Интернет адрес сокета состоит из двух частей: номера компьютера и номера порта. 
		Эта информация хранится в переменной структуры <span class="term"> sockaddr_in</span> .
		Для идентификации того, что это адрес Интернет пространства имен, необходимо установить
		поле <span class="term"> sin_family</span>  в <span class="term"> AF_INET</span> .
		В поле <span class="term"> Sin_addr </span> хранится Интернет адрес компьютера,
		как 32-разрядное целое число <span class="term"> IP</span> . 
		Каждому сокету на одном компьютере присваивается номер порта.
		Поскольку различные машины сохраняют многобайтовые значения в различном порядке байта,
		используют <span class="func"> htons</span> , чтобы преобразовать число порта к сетевому 
		порядку байтов. 
	<p>	Команда <span class="func"> gethostbyname</span>  преобразовывает удобочитаемые имена хоста,
		числа со стандартной точечной нотацией (типа 10.0.0.1) или <span class="term"> DNS</span> 
		имена (такие как www.codesourcery.com) в 32-разрядные IP адреса. В качестве результата
		возвращается указатель на структуру <span class="term"> struct hostent</span> ;  в поле
		<span class="term"> h_addr</span>  хранится IP адрес главного компьютера. 
	<p>	Листинг 5.12 иллюстрирует использование Internet-domain сокетов. 
		Программа получает домашнюю страницу от Web сервера, имя хоста которого определено
		в командной строке.
	<p>	Листинг 5.12(<a href="socket-inet.c">socket-inet.c</a>)
<pre>
	#include &lt;stdlib.h&gt;
	#include &lt;stdio.h&gt;
	#include &lt;netinet/in.h&gt;
	#include &lt;netdb.h&gt;
	#include &lt;sys/socket.h&gt;
	#include &lt;unistd.h&gt;
	#include &lt;string.h&gt;
	/* Печать содержимого домашней страницы. 
	 * В качестве результата передать флаг успешного завершения процесса.*/
	void get_home_page (int socket_fd)
	{
		char buffer[10000];
		ssize_t number_characters_read;
		/* Передать команду HTTP GET для домашней страницы */
		sprintf (buffer, "GET /\n");
		write (socket_fd, buffer, strlen (buffer));
		/* Читать данные из сокета. Не все данные могут быть возвращены одновременно, 
		 * продолжать попытку до завершения процесса */
		while (1) {
			number_characters_read = read (socket_fd, buffer, 10000);
			if (number_characters_read == 0)
				return;
			/* Записать данные в стандартный вывод */
			fwrite (buffer, sizeof (char), number_characters_read, stdout);
		}
	}
	int main (int argc, char* const argv[])
	{
		int socket_fd;
		struct sockaddr_in name;
		struct hostent* hostinfo;
		/* Создать сокет */
		socket_fd = socket (PF_INET, SOCK_STREAM, 0);
		/* Сохранить адрес сервера в адрессе сокета */
		name.sin_family = AF_INET;
		/* Преобразовать строку в число */
		hostinfo = gethostbyname (argv[1]);
		if (hostinfo == NULL)
			return 1;
		else
			name.sin_addr = *((struct in_addr *) hostinfo-&gt;h_addr);
		/* Web сервер использует 80 порт */
		name.sin_port = htons (80);
		/* Установить соединение с Web сервером */
		if (connect (socket_fd, &amp;name, sizeof (struct sockaddr_in)) == -1) {
			perror ("connect");
			return 1;
		}
		/* Получить домашнюю страницу */
		get_home_page (socket_fd);
		return 0;
	}
</pre>
	<p>	Имя хоста Web сервера задается в командно строке (без "http: //"). Команда 
		<span class="func"> gethostbyname </span> преобразовывает имя хоста в числовой 
		IP адрес и затем подключает поток (TCP) сокета к порту 80 на главном компьютере. 
		Серверы используют Гипертекстовый Транспортный Протокол (<span class="term"> HTTP
		</span>), поэтому передается команда <span class="term"> HTTP GET</span> , сервер 
		в качестве ответа передает текст домашней страницы. 	
	<p>	Для отображения страницы www.codesourcery.com, необходимо задать следующуе команду
<pre>
	% ./socket-inet www.codesourcery.com
	&lt;html&gt;
	&lt;meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"&gt;
	...
</pre>
	<a name="pair"></a>
	<h2>Пары сокетов</h2>
	<p>	Как упоминалось ранее, функция <span class="func"> pipe</span> , создает два
		дескриптора файлов для начала и конца канала. Каналы ограничены, потому что 
		дескрипторы файлов используются только связанными процессами и  потому что 
		взаимодействие однонаправлено. Функция <span class="func"> socketpair </span> 
		создает два дескриптора файлов для двух сокетов, подключенных на одном компьютере.
		Эти дескрипторы файлов разрешают двухстороннее взаимодействие двух связанных 
		процессов. Первые три параметра команды - идентичны параметрам  команды
		<span class="func"> socket</span> : они определяют домен, стиль подключения и протокол. 
		Последний параметр - массив с двумя целыми числами, в котором хранятся характеристики 
		файлов этих двух сокетов. При использовании команды <span class="func"> socketpair
		</span> , необходимо определить <span class="term"> PF_LOCAL</span> как пространство имен.
</body>
