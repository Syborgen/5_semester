<HTML>
<HEAD>
<title>Общая (совместно используемая) память</title>
</HEAD>
<body>
	<h1>Общая (совместно используемая) память</h1>
	<ul>
		<li><a href="#fast_local">Быстрое локальное взаимодействие</a></li>
		<li><a href="#memory_model">Модель памяти</a></li>
		<li><a href="#allocation">Выделение</a></li>
		<li><a href="#attach">Подключение и отключение</a></li>
		<li><a href="#conterol">Управление и освобождение общей памяти</a></li>
		<li><a href="#example">Пример программы</a></li>
		<li><a href="#debug">Отладка</a></li>
		<li><a href="#vs">За и против</a></li>
	</ul>
	<p>
		Один из самых простых методов межпроцессового взаимодействия - использовать общую память.
		Общая память позволяет двум или более процессам обращаться к одной и той же области памяти,
		как будто они все вызывали malloc и им были возвращены указатели на одну и ту же физическую память.
		Когда один процесс изменяет память, все другие процессы "видят" модификацию. 
	</p>  
	<a name="fast_local"></a>     
	<h2> Быстрое локальное взаимодействие</h2>
	<p>
		Общая память - самая быстрая форма межпроцессового взаимодействия, потому что все процессы совместно используют
		одну иту же часть памяти. Доступ к этой общей памяти осуществляется с той же скоростью,
		что и при обращении к несовместно используемой памяти, и это не требует системного вызова 
		или входа в ядро. Это также не требует излишнего копирования данных.
	</p>
	<p>
		Поскольку ядро не синхронизирует доступы к совместно используемой памяти,
		вы должны сами обеспечить синхронизацию. Например, процесс не должен читать из памяти,
		пока данные не записаны туда, и два процесса не должны написать по одному и тому же адресу памяти
		в одно и то же время. Общая стратегия избежания условий гонки состоит в том, чтобы использовать 
		<a href="sem.html">семафоры</a>.
	</p>
	<a name="memory_model"></a> 
	<h2>Модель памяти</h2> 
	<p>
		Чтобы использовать сегмент общей памяти, один процесс должен выделить сегмент. 
		Тогда каждый процесс, желающий обращаться к сегменту должен подключить сегмент. 
		После окончания его использования сегмента, каждый процесс отключает сегмент.
		В некоторый момент, один процесс должен освободить сегмент. 
	</p>
	<p>
		Понимание модели памяти <span class="term">Linux</span> помогает объяснить процесс
		выделения и подключения. Под <span class="term">Linux</span>, виртуальная память 
		каждого процесса разбита на страницы. Каждый процесс поддерживает отображение его 
		адресов памяти на эти страницы виртуальной памяти, которые содержат фактические данные.
		И хотя каждый процесс имеет собственные адреса, отображения многих процессов могут 
		указывать на одну и ту же страницу, разрешая совместное использование памяти. 
	</p>
	<p>	
		Выделение нового сегмента общей памяти приводит к созданию страницы виртуальной памяти.
		Поскольку все процессы желают обратиться к одному и тому же общему сегменту,
		то только один процесс должен выделить новый общий сегмент.
		Выделение существующего сегмента не создает новых страниц,
		а возвращает идентификатор для существующих.
		Чтобы разрешить процессу использовать сегмент общей памяти, процесс подключает сегмент,
		который добавляет отображение его виртуальной памяти на общедоступные страницы сегмента. 
		Когда работа с сегментом завершена, эти отображения удаляются. 
		Когда ни одни из процессов не хочет обращаться к сегментам общей памяти, какой-то один 
		процесс должен освободить страницы виртуальной памяти. 
		Все сегменты общей памяти выделяются постранично и округляются до размера страницы системы,
		который является числом байтов в странице памяти. На системах <span class="term">Linux</span>,
		размер страницы равен 4 КБ, но вы должны получить это значение, вызывая функцию 
		<span class="func">getpagesize</span>.
	</p>
	<a name="allocation"></a> 
	<h2>Выделение</h2> 
	<p>
		Процесс выделяет сегмент общей памяти, используя <span class="func">shmget</span>
		("<span class="term">SHared Memory GET</span>"). Его первый параметр - целочисленный
		ключ, который определяет, какой сегмент создать. Несвязанные процессы могут обращаться
		к одному и тому же сегменту, используя одно и то же ключевое значение. К сожалению,
		другие процессы, возможно, также выбрали тот же самый ключ, что может привести к конфликту.
		Используя специальную константу <span class="term">IPC_PRIVATE</span> как ключевое значение,
		гарантируется, что создастся совершенно новый сегмент памяти.
	</p>
	<p>
		Его второй параметр определяет число байтов в сегменте.
		Поскольку сегменты выделяются постранично, число фактически выделенных байт округляется 
		до размера страницы.
	</p>
	<p>
		Третий параметр - поразрядное двоичное или значений флажка, которые определяют опции к 
		<span class="func">shmget</span>. Значения флажка включают такие параметры:
		<ul>
			<li>	<span class="term">IPC_CREAT</span> - этот флажок указывает, что должен 
				быть создан новый сегмент. Это разрешает создавать новый сегмент, 
				определяя ключ.
			</li>
			<li>	<span class="term">IPC_EXCL</span> - этот флажок, который всегда 
				используется с <span class="term">IPC_CREAT</span>,заставляет 
				<span class="func">shmget</span> возвращать ошибку, если сегментный
				ключ определен, как уже существующий. Это используется для выделения
				"эксклюзивного" сегмента. Если этот флажок не дается, и ключ 
				существующего сегмента используется, <span class="func">shmget</span>
				возвращает существующий сегмент вместо того, чтобы создать новый. 
			</li>
			<li>	<span class="term">Mode flags</span> - это значение из 9 битов, 
				указывающих права, предоставленные владельцу, группе, и миру(остальным),
				на управление доступом к сегменту. Биты выполнения игнорируются. 
				Простой способ определить права состоит в том, чтобы использовать
				константы, определенные в <span class="term">&lt;sys/stat.h&gt;</span> 
				и описаные в разделе 2 <span class="term">stat man-страниц</span>.
				Например, <span class="term">S_IRUSR</span> и <span class="term">S_IWUSR</span>
				определяют права на чтение и запись для владельца сегмента общей памяти,
				а <span class="term">S_IROTH</span> и <span class="term">S_IWOTH</span> 
				определяют права на чтение и запись для других.
			</li>
		</ul>
	</p>
	<p>
		Например, этот вызов <span class="func">shmget</span> создает новый сегмент общей
		памяти (или обращается к существующему, если <span class="term">shm_key</span> уже
		используется), с правами на читение и запись владельцем, но не другими пользователями. 
	</p>       
	<div class="code">
		int segment_id = shmget (shm_key, getpagesize (), IPC_CREAT | S_IRUSR | S_IWUSER);
	</div>
	<p>
		Если вызов успешен, <span class="func">shmget</span> возвращает идентификатор сегмента. 
		Если сегмент общей  памяти уже существует, то права на доступ проверены,
		и проверка гарантирует, что сегмент не отмечен для удаления. 
	</p>
	<a name="attach"></a> 
 	<h2>Подключение и отключение</h2>
	<p>
		Чтобы сделать сегмент общей памяти доступным, процесс должен использовать 
		<span class="func">shmat</span>, "<span class="term">SHared Memory ATtach</span>"
		Передайте ему идентификатор сегмента общей памяти <span class="term">SHMID</span>,
		возвращенный <span class="func">shmget</span>. 
		Второй параметр - указатель, который определяет, где в адресном пространстве вашего процесса 
		вы хотите отобразить общую память; если вы передадите <span class="term">NULL</span>,
		то <span class="term">Linux</span> выберет любой доступный адрес.
		Третий параметр - флажок, который может включить следующие параметры: 
		<ul>
			<li>	<span class="term">SHM_RND</span> указывает, что адрес, определенный
				для второго параметра, должен быть округлен назад к множителю размера
				страницы. Если Вы не определяете этот флажок, Вы должны выровнять на
				границу страницы второй параметр передаваемый <span class="func">shmat</span>
				самостоятельно. 
			</li>
			<li>	<span class="term">SHM_RDONLY</span> указывает, что сегмент будет 
				доступен только для чтения. 
			</li>
			<li>	Биты прав достапа такие же как и для файлов.
			</li>
		</ul>
	</p>
	<p>
		Если вызов успешен, он вернет адрес подключенного общего сегмента. 
		Потомки, созданные вызовами <span class="func">fork</span>, наследуют подключенные 
		общие сегменты; они могут отключить сегменты общей памяти, если захотят. 
	</p>
	<p>
		Когда вы закончили работу с сегментом общей памяти, сегмент должен быть отключен, 
		используя <span class="func">shmdt</span> ("<span class="term">SHared Memory DeTach</span>").
		Передайте ему адрес, возвращенный <span class="func">shmat</span>. 
		Если сегмент был освобожден, и больше не осталось процессов, использующих его, он будет удален.
		Вызовы <span class="func">exit</span> и <span class="func">exec</span> автоматически 
		отключают сегменты. 
	</p>
	<a name="control"></a> 
	<h2>Управление и освобождение общей памяти</h2>
 	<p>
		<span class="func">Shmctl</span> ("<span class="term">SHared Memory ConTrol</span>") вызов
		возвращает информацию об сегменте общей памяти и может изменить его.Первый параметр - 
		идентификатор сегмента общей памяти. 
	</p>
	<p>
		Чтобы получить информацию о сегменте общей памяти,
		передайте <span class="term">IPC_STAT</span> как второй параметр и указатель на 
		<span class="term">struct shmid_ds</span>. 
	</p>
	<p>
		Чтобы удалить сегмент, передайте <span class="term">IPC_RMID</span> как второй параметр,
		и передайте <span class="term">NULL</span> как третий параметр. Сегмент удален, когда 
		последний процесс, который подключил его, отключит его. 
	</p>
	<p>
		Каждый сегмент общей памяти должен быть явно освобожден, используя <span class="func">
		shmctl</span>, когда Вы закончили работу с ним, чтобы избежать нарушение системного 
		предела размера количества сегментов общей памяти. Вызовы <span class="func">exit</span>
		и <span class="func">exec</span> отключат сегменты памяти, но не освобождят их. 
	</p>
	<p>
		Смотри <span class="func">shmctl</span> man-страницу для описания других операций,
		которые можно выполнять с сегментами общей памяти. 
	</p>
	<a name="example"></a> 
	<h2>Пример программы</h2>
	<p>
		Программа листинга 5.1 иллюстрирует использование общей памяти. 
	</p>
	<p>	
		Листинг 5.1 (<a href="shm.c">shm.c</a>)
	</p>
	
<pre>
#include &lt;stdio.h&gt;
#include &lt;sys/shm.h&gt;
#include &lt;sys/stat.h&gt;
	
int main (){
	int segment_id;
	char* shared_memory;
	struct shmid_ds shmbuffer;
	int segment_size;
	const int shared_segment_size = 0x6400;
	
	/* Выделить сегмент  общей памяти. */
	segment_id = shmget (IPC_PRIVATE, shared_segment_size, IPC_CREAT | IPC_EXCL | S_IRUSR | S_IWUSR);
	
	/* Подключить сегмент общей памяти.  */
	shared_memory = (char*) shmat (segment_id, 0, 0);
	printf ("Общая память подключена по адресу %p\n", shared_memory);
	
	/* Определить размер сегмента. */
	shmctl (segment_id, IPC_STAT, &amp;shmbuffer);
	segment_size = shmbuffer.shm_segsz;
	printf ("Размер сегмента: %d\n", segment_size);
	
	/* Написать строку в сегмент общей памяти. */
	sprintf (shared_memory, "Hello, world.");
	
	/* Отключить сегмент общей памяти. */ 
	shmdt (shared_memory);
	
	/* Снова подключить сегмент общей памяти, по различным адресам. */ 
	shared_memory = (char*) shmat (segment_id, (void*) 0x5000000, 0);
	printf ("Общая память переподключена по адресу %p\n", shared_memory);
	
	/* Распечатать строку из общей памяти.  */ 
	printf ("%s\n", shared_memory);
	
	/* Отключить сегмент общей памяти. */ 
	shmdt (shared_memory);
	
	/* Освободить сегмент общей памяти.  */
	shmctl (segment_id, IPC_RMID, 0);
	return 0;
}
</pre>
	<a name="debug"></a> 
	<h2>Отладка</h2> 
	<p>
		Команда <span class="term">ipcs</span> предоставляет информацию относительно 
		средств взаимодействия процессов, включая общие сегменты памяти. Используйте 
		флаг <span class="term">-m</span>, чтобы получить  информацию об общей памяти.
		Например, этот код иллюстрирует что сегмент общей памяти, пронумерованный 1627649,
		находится  в использовании: 
	</p>
<pre>
% ipcs -m
------ Shared Memory Segments --------
key	    shmid	owner	perms	bytes	nattch	status
0x00000000  1627649	user	640	25600	0
</pre>
	<p>
		Если этот сегмент памяти был ошибочно оставлен программой,
		вы можете использовать команду <span class="term">ipcrm</span>, чтобы удалить его. 
	</p>
<pre>
% ipcrm shm 1627649
</pre>
	<a name="vs"></a> 
	<h2>За и против</h2> 
	<p>
		Cегменты общей памяти позволяют осуществлять быструю двунаправленную связь среди
		любого числа процессов. Каждый пользователь  может и читать и писать, но программа
		должна установить и следовать некоторому протоколу для того, чтобы предотвратить
		условия гонки типа перезаписи информации прежде, чем она прочитается. К сожалению,
		<span class="term">Linux</span> строго не гарантирует эксклюзивный доступ даже 
		если вы создадите новый общий сегмент с <span class="term">IPC_PRIVATE</span>.
	</p>
	<p>
		Кроме  того, для того чтоб несколько процессов могли использовать общую память, они
		должны принять меры, чтобы не использовать один и тот же ключ.
	</p>
</body>
