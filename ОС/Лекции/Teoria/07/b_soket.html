<HTML>
<HEAD>
<title>Сокеты</title>
</HEAD>
<body>


<h1> ГНЕЗДА</h1>

<p>    Было показано, каким образом взаимодействуют  между
собой  процессы, протекающие на разных машинах, при этом обращалось внимание
на то, что способы реализации взаимодействия могут быть различаться в  зави-
симости от используемых протоколов и сетевых средств. Более того, эти спосо-
бы  не всегда применимы для обслуживания взаимодействия процессов, выполняю-
щихся на одной и той же машине, поскольку в них предполагается существование
обслуживающего (серверного) процесса, который при выполнении системных функ-
ций open или read будет приостанавливаться драйвером. В целях создания более
универсальных методов взаимодействия процессов на основе использования  мно-
гоуровневых  сетевых протоколов для системы BSD был разработан механизм, по-
лучивший название<span class=term> "sockets" </span>(гнезда). В  данном  разделе
мы рассмотрим некоторые аспекты применения гнезд (на пользовательском уровне
представления).
</p>
<pre>
               Процесс-клиент       Процесс-сервер
                       і                 і
                       АДДї           ЪДДЩ
ЪДДДДДДДДДДДДДДДДДДДДДДДДДЕДДї     ЪДДЕДДДДДДДДДДДДДДДДДДДДДДДДДДї
і Уровень гнезд              і     і          Уровень гнезд      і
ГДДДДДДДДДДДДДДДДДДДДДДДДДЕДДґ     ГДДЕДДДДДДДДДДДДДДДДДДДДДДДДДДґ
і                        TCP і     і TCP                         і
і Уровень протоколов      і  і     і  і       Уровень протоколов і
і                        IP  і     і IP                          і
ГДДДДДДДДДДДДДДДДДДДДДДДДДЕДДґ     ГДДЕДДДДДДДДДДДДДДДДДДДДДДДДДДґ
і                     Драйвері     і Драйвер                     і
і Уровень устройств  Ethernetі     іEthernet  Уровень устройств  і
АДДДДДДДДДДДДДДДДДДДДДДДДДЕДДЩ     АДДЕДДДДДДДДДДДДДДДДДДДДДДДДДДЩ
                          АДДДї   ЪДДДЩ
                              і   і
                             С е т ь

           Рисунок 11.18. Модель с использованием гнезд
</pre>
<p>    Структура  ядра имеет три уровня: гнезд, протоколов и устройств (Рисунок
11.18). Уровень гнезд выполняет функции интерфейса между обращениями к  опе-
рационной  системе (системным функциям) и средствами низких уровней, уровень
протоколов содержит модули, обеспечивающие взаимодействие процессов (на  ри-
сунке  упомянуты протоколы TCP и IP), а уровень устройств содержит драйверы,
управляющие сетевыми устройствами. Допустимые сочетания протоколов и драйве-
ров указываются при построении системы (в секции конфигурации); этот  способ
уступает  по гибкости вышеупомянутому потоковому механизму. Процессы взаимо-
действуют между собой по схеме клиент-сервер: сервер ждет сигнала от гнезда,
находясь на одном конце дуплексной линии связи, а  процессы-клиенты  взаимо-
действуют  с сервером через гнездо, находящееся на другом конце, который мо-
жет располагаться на другой машине. Ядро обеспечивает внутреннюю связь и пе-
редает данные от клиента к серверу.</p>
<p>    Гнезда, обладающие одинаковыми свойствами, например, опирающиеся на  об-
щие  соглашения по идентификации и форматы адресов (в протоколах), группиру-
ются в домены (управляемые одним узлом). В системе  BSD  4.2  поддерживаются
домены:  "UNIX  system" - для взаимодействия процессов внутри одной машины и
"Internet" (межсетевой) - для взаимодействия через сеть с помощью  протокола
DARPA  (Управление перспективных исследований и разработок Министерства обо-
роны США).  Гнезда бывают двух типов:  виртуальный  канал  (потоковое  гнездо, если пользоваться терминологией Беркли) и
дейтаграмма. Виртуальный канал обеспечивает надежную доставку данных с  сох-
ранением  исходной  последовательности.  Дейтаграммы не гарантируют надежную
доставку с сохранением уникальности и последовательности, но они более  эко-
номны  в смысле использования ресурсов, поскольку для них не требуются слож-
ные установочные операции; таким образом, дейтаграммы  полезны  в  отдельных
случаях взаимодействия. Для каждой допустимой комбинации типа домен-гнездо в
системе  поддерживается  умолчание  на используемый протокол. Так, например,
для домена "Internet" услуги виртуального канала выполняет  протокол  транс-
портной  связи (TCP), а функции дейтаграммы - пользовательский дейтаграммный
протокол (UDP).</p>
<p>    Существует несколько системных функций работы с гнездами. Функция socket
устанавливает оконечную точку линии связи.

   <span class=term> sd = socket(format,type,protocol);</span>

Format обозначает домен ("UNIX system" или "Internet"), type - тип связи че-
рез гнездо (виртуальный канал или дейтаграмма), а protocol - тип  протокола,
управляющего  взаимодействием.  Дескриптор  гнезда sd, возвращаемый функцией
socket, используется другими системными функциями. Закрытие гнезд  выполняет
функция close.</p>
<p>    Функция bind связывает дескриптор гнезда с именем:

  <span class=term>  bind(sd,address,length);</span>

где <span class=term> sd</span> - дескриптор гнезда,<span class=term> address</span> - адрес структуры, определяющей иденти-
фикатор, характерный для данной комбинации домена  и  протокола  (в  функции
<span class=term>socket</span>).<span class=term> Length</span> - длина структуры address; без этого параметра ядро не знало
бы,  какова  длина  структуры, поскольку для разных доменов и протоколов она
может быть различной. Например, для домена "UNIX system" структура  содержит
имя  файла. Процессы-серверы связывают гнезда с именами и объявляют о состо-
явшемся присвоении имен процессам-клиентам.</p>
<p>    С помощью системной функции connect делается запрос на подключение к су-
ществующему гнезду:

  <span class=term>  connect(sd,address,length);</span>

Семантический смысл параметров функции остается прежним,
но <span class=term> address </span>указывает уже на выходное гнездо, образующее противоположный ко-
нец линии связи. Оба гнезда должны использовать одни и те же домен и  прото-
кол связи, и тогда ядро удостоверит правильность установки линии связи. Если
тип  гнезда  - дейтаграмма, сообщаемый функцией connect ядру адрес будет ис-
пользоваться в последующих обращениях к функции send через данное гнездо;  в
момент вызова никаких соединений не производится.</p>
<p>    Пока процесс-сервер готовится к приему связи по виртуальному каналу, яд-
ру  следует  выстроить поступающие запросы в очередь на обслуживание. Макси-
мальная длина очереди задается с помощью системной функции<span class=term> listen</span>:

<span class=term>    listen(sd,qlength)</span>

где<span class=term> sd</span> - дескриптор гнезда, а <span class=term>qlength</span> - максимально-допустимое число  запро-
сов, ожидающих обработки.</p>
<pre>
    ЪДДДДДДДДДДДДДДДДДДДДї         ЪДДДДДДДДДДДДДДДДДДДДДДДДДї
    і   Процесс-клиент   і         і     Процесс-сервер      і
    і         і          і         і          і  щ           і
    і         і          і         і     ЪДДДДЩ  щщщщщщ      і
    і         і          і         і     і            щ      і
    і         і          і         іlisten addr   accept addrі
    АДДДДДДДДДЕДДДДДДДДДДЩ         АДДДДДЕДДДДДДДДДДДДщДДДДДДЩ
              і                          і            щ
              АДДДДДДДДДДДДДДДДДДДДДДДДДДЩщщщщщщщщщщщщщ

               Рисунок 11.19. Прием вызова сервером

    </pre><p>
    Системная  функция  accept принимает запросы на подключение, поступающие
на вход процесса-сервера:

<span class=term>    nsd = accept(sd,address,addrlen);</span>

где<span class=term> sd</span> - дескриптор гнезда,<span class=term> address</span> - указатель на пользовательский  массив,
в  котором  ядро  возвращает  адрес  подключаемого клиента, addrlen - размер
пользовательского массива. По завершении выполнения функции ядро  записывает
в переменную <span class=term>addrlen </span>размер пространства, фактически занятого массивом. Фун-
кция  возвращает  новый дескриптор гнезда <span class=term>(nsd)</span>, отличный от дескриптора<span class=term> sd</span>.
Процесс-сервер может продолжать слежение за состоянием объявленного  гнезда,
поддерживая связь с клиентом по отдельному каналу (Рисунок 11.19).</p>
<p>    Функции send и recv выполняют передачу данных через подключенное гнездо.
Синтаксис вызова функции <span class=term>send</span>:

<span class=term>    count = send(sd,msg,length,flags)</span>;

где <span class=term> sd</span>  - дескриптор гнезда,<span class=term> msg</span> - указатель на посылаемые данные, <span class=term>length </span>-
размер данных,<span class=term> count</span> - количество фактически переданных байт. Параметр<span class=term> flags</span>
может содержать значение SOF_OOB (послать данные <span class=term>out-of-band</span> - "через тамож-
ню"), если посылаемые данные не учитываются в  общем  информационном  обмене
между взаимодействующими процессами. Программа удаленной регистрации, напри-
мер,  может послать<span class=term> out-of-band</span> сообщение, имитирующее нажатие на клавиатуре
терминала клавиши<span class=term> "delete"</span>. Синтаксис вызова системной функции <span class=term>recv</span>:

<span class=term>    count = recv(sd,buf,length,flags)</span>;

где<span class=term> buf</span> - массив для приема данных,<span class=term> length </span>- ожидаемый объем данных, <span class=term>count</span> -
количество байт, фактически  переданных  пользовательской  программе.  Флаги
<span class=term>(flags)</span> могут быть установлены таким образом, что поступившее сообщение пос-
ле чтения и анализа его содержимого не будет удалено из очереди, или настро-
ены на получение данных<span class=term> out-of-band</span>. В дейтаграммных версиях указанных функ-
ций,<span class=term> sendto и recvfrom</span>, в качестве дополнительных параметров указываются ад-
реса.  После выполнения подключения к гнездам потокового типа процессы могут
вместо функций <span class=term>send и recv</span> использовать функции<span class=term> read и write</span>. Таким образом,
согласовав тип протокола, серверы могли бы  порождать  процессы,  работающие
только с функциями<span class=term> read и write</span>, словно имеют дело с обычными файлами.</p>
<p>    Функция shutdown закрывает гнездовую связь:

  <span class=term>  shutdown(sd,mode)</span>

где<span class=term> mode</span> указывает, какой из сторон (посылающей, принимающей или обеим вмес-
те)  отныне  запрещено  участие в процессе передачи данных. Функция сообщает
используемому протоколу о завершении сеанса сетевого взаимодействия,  остав-
ляя,  тем  не  менее,  дескрипторы гнезд в неприкосновенности. Освобождается
дескриптор гнезда только в результате выполнения функции<span class=term> close</span>.
<p>    Системная функция getsockname получает имя гнездовой связи,  установлен-
ной ранее с помощью функции <span class=term>bind</span>:

<span class=term>    getsockname(sd,name,length)</span>;
</p>
   <p> Функции <span class=term> getsockopt  и setsockopt </span>получают и устанавливают значения раз-
личных связанных с гнездом параметров в соответствии с типом домена и прото-
кола.</p>
<p>    Рассмотрим обслуживающую программу,  представленную  на  Рисунке  11.20.
Процесс  создает в домене "UNIX system" гнездо потокового типа и присваивает
ему имя sockname. Затем с помощью функции<span class=term> listen </span>устанавливается длина  оче-
реди  поступающих сообщений и начинается цикл ожидания поступления запросов.
Функция <span class=term>accept</span> приостанавливает свое выполнение до тех пор, пока  протоколом
не будет зарегистрирован запрос на подключение к гнезду с означенным именем;
после  этого функция завершается, возвращая поступившему запросу новый деск-
риптор гнезда. Процесс-сервер порождает потомка, через которого  будет  под-
держиваться связь с процессом-клиентом; родитель и потомок при этом закрыва-
ют  свои дескрипторы, чтобы они не становились помехой для коммуникационного
траффика другого процесса. Процесс-потомок ведет разговор с клиентом  и  за-
вершается после выхода из функции read. Процесс-сервер возвраща-
ется к началу цикла и ждет поступления следующего запроса на подключение. </p>
<p>    На  Рисунке  11.21  показан  пример процесса-клиента, ведущего общение с
сервером. Клиент создает гнездо в том же домене, что и  сервер,  и  посылает
запрос  на  подключение к гнезду с именем sockname. В результате подключения

  <pre>
    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
    і #include &lt;sys/types.h&gt;                                     і
    і #include &lt;sys/socket.h&gt;                                    і
    і                                                            і
    і main()                                                     і
    і {                                                          і
    і     int sd,ns;                                             і
    і     char buf[256];                                         і
    і     struct sockaddr sockaddr;                              і
    і     int fromlen;                                           і
    і                                                            і
    і     sd = socket(AF_UNIX,SOCK_STREAM,0);                    і
    і                                                            і
    і     /* имя гнезда - не может включать пустой символ */     і
    і     bind(sd,"sockname",sizeof("sockname") - 1);            і
    і     listen(sd,1);                                          і
    і                                                            і
    і     for (;;)                                               і
    і     {                                                      і
    і                                                            і
    і          ns = accept(sd,&sockaddr,&fromlen);               і
    і          if (fork() == 0)                                  і
    і          {                                                 і
    і              /* потомок */                                 і
    і              close(sd);                                    і
    і              read(ns,buf,sizeof(buf));                     і
    і              printf("сервер читает '%s'\n",buf);           і
    і              exit();                                       і
    і          }                                                 і
    і          close(ns);                                        і
    і     }                                                      і
    і }                                                          і
    АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ

        Рисунок 11.20. Процесс-сервер в домене "UNIX system"

    ЪДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДї
    і #include &lt;sys/types.h&gt;                                     і
    і #include &lt;sys/socket.h&gt;                                    і
    і                                                            і
    і main()                                                     і
    і {                                                          і
    і    int sd,ns;                                              і
    і    char buf[256];                                          і
    і    struct sockaddr sockaddr;                               і
    і    int fromlen;                                            і
    і                                                            і
    і    sd = socket(AF_UNIX,SOCK_STREAM,0);                     і
    і                                                            і
    і    /* имя в запросе на подключение не может включать       і
    і    /* пустой символ */                                     і
    і    if (connect(sd,"sockname",sizeof("sockname") - 1) == -1)і
    і         exit();                                            і
    і                                                            і
    і    write(sd,"hi guy",6);                                   і
    і }                                                          і
    АДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДДЩ

         Рисунок 11.21. Процесс-клиент в домене "UNIX system"
   </pre>
процесс-клиент получает виртуальный канал связи с сервером. В  рассматривае-
мом примере клиент передает одно сообщение и завершается.</p>
<p>    Если сервер обслуживает процессы в сети, указание о том, что гнездо при-
надлежит домену "Internet", можно сделать следующим образом:

  <span class=term>  socket(AF_INET,SOCK_STREAM,0)</span>;

и  связаться с сетевым адресом, полученным от сервера. В системе BSD имеются
библиотечные функции, выполняющие эти действия. Второй  параметр  вызываемой
клиентом функции connect содержит адресную информацию, необходимую для иден-
тификации машины в сети (или адреса маршрутов посылки сообщений через проме-
жуточные машины), а также дополнительную информацию, идентифицирующую прием-
ное  гнездо машины-адресата. Если серверу нужно одновременно следить за сос-
тоянием сети и выполнением локальных процессов, он использует два гнезда и с
помощью функции<span class=term> select</span> определяет, с каким клиентом устанавливается связь  в
данный момент.                              </p>
</body>                                               
</html>
