<HTML>
<HEAD>
<title>—океты</title>
</HEAD>
<body>


<h1> √Ќ≈«ƒј</h1>

<p>    Ѕыло показано, каким образом взаимодействуют  между
собой  процессы, протекающие на разных машинах, при этом обращалось внимание
на то, что способы реализации взаимодействи€ могут быть различатьс€ в  зави-
симости от используемых протоколов и сетевых средств. Ѕолее того, эти спосо-
бы  не всегда применимы дл€ обслуживани€ взаимодействи€ процессов, выполн€ю-
щихс€ на одной и той же машине, поскольку в них предполагаетс€ существование
обслуживающего (серверного) процесса, который при выполнении системных функ-
ций open или read будет приостанавливатьс€ драйвером. ¬ цел€х создани€ более
универсальных методов взаимодействи€ процессов на основе использовани€  мно-
гоуровневых  сетевых протоколов дл€ системы BSD был разработан механизм, по-
лучивший название<span class=term> "sockets" </span>(гнезда). ¬  данном  разделе
мы рассмотрим некоторые аспекты применени€ гнезд (на пользовательском уровне
представлени€).
</p>
<pre>
               ѕроцесс-клиент       ѕроцесс-сервер
                       ≥                 ≥
                       јƒƒњ           Џƒƒў
Џƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒњ     Џƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒњ
≥ ”ровень гнезд              ≥     ≥          ”ровень гнезд      ≥
√ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒі     √ƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒі
≥                        TCP ≥     ≥ TCP                         ≥
≥ ”ровень протоколов      ≥  ≥     ≥  ≥       ”ровень протоколов ≥
≥                        IP  ≥     ≥ IP                          ≥
√ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒі     √ƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒі
≥                     ƒрайвер≥     ≥ ƒрайвер                     ≥
≥ ”ровень устройств  Ethernet≥     ≥Ethernet  ”ровень устройств  ≥
јƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒ≈ƒƒў     јƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒў
                          јƒƒƒњ   Џƒƒƒў
                              ≥   ≥
                             — е т ь

           –исунок 11.18. ћодель с использованием гнезд
</pre>
<p>    —труктура  €дра имеет три уровн€: гнезд, протоколов и устройств (–исунок
11.18). ”ровень гнезд выполн€ет функции интерфейса между обращени€ми к  опе-
рационной  системе (системным функци€м) и средствами низких уровней, уровень
протоколов содержит модули, обеспечивающие взаимодействие процессов (на  ри-
сунке  упом€нуты протоколы TCP и IP), а уровень устройств содержит драйверы,
управл€ющие сетевыми устройствами. ƒопустимые сочетани€ протоколов и драйве-
ров указываютс€ при построении системы (в секции конфигурации); этот  способ
уступает  по гибкости вышеупом€нутому потоковому механизму. ѕроцессы взаимо-
действуют между собой по схеме клиент-сервер: сервер ждет сигнала от гнезда,
наход€сь на одном конце дуплексной линии св€зи, а  процессы-клиенты  взаимо-
действуют  с сервером через гнездо, наход€щеес€ на другом конце, который мо-
жет располагатьс€ на другой машине. ядро обеспечивает внутреннюю св€зь и пе-
редает данные от клиента к серверу.</p>
<p>    √незда, обладающие одинаковыми свойствами, например, опирающиес€ на  об-
щие  соглашени€ по идентификации и форматы адресов (в протоколах), группиру-
ютс€ в домены (управл€емые одним узлом). ¬ системе  BSD  4.2  поддерживаютс€
домены:  "UNIX  system" - дл€ взаимодействи€ процессов внутри одной машины и
"Internet" (межсетевой) - дл€ взаимодействи€ через сеть с помощью  протокола
DARPA  (”правление перспективных исследований и разработок ћинистерства обо-
роны —Ўј).  √незда бывают двух типов:  виртуальный  канал  (потоковое  гнездо, если пользоватьс€ терминологией Ѕеркли) и
дейтаграмма. ¬иртуальный канал обеспечивает надежную доставку данных с  сох-
ранением  исходной  последовательности.  ƒейтаграммы не гарантируют надежную
доставку с сохранением уникальности и последовательности, но они более  эко-
номны  в смысле использовани€ ресурсов, поскольку дл€ них не требуютс€ слож-
ные установочные операции; таким образом, дейтаграммы  полезны  в  отдельных
случа€х взаимодействи€. ƒл€ каждой допустимой комбинации типа домен-гнездо в
системе  поддерживаетс€  умолчание  на используемый протокол. “ак, например,
дл€ домена "Internet" услуги виртуального канала выполн€ет  протокол  транс-
портной  св€зи (TCP), а функции дейтаграммы - пользовательский дейтаграммный
протокол (UDP).</p>
<p>    —уществует несколько системных функций работы с гнездами. ‘ункци€ socket
устанавливает оконечную точку линии св€зи.

   <span class=term> sd = socket(format,type,protocol);</span>

Format обозначает домен ("UNIX system" или "Internet"), type - тип св€зи че-
рез гнездо (виртуальный канал или дейтаграмма), а protocol - тип  протокола,
управл€ющего  взаимодействием.  ƒескриптор  гнезда sd, возвращаемый функцией
socket, используетс€ другими системными функци€ми. «акрытие гнезд  выполн€ет
функци€ close.</p>
<p>    ‘ункци€ bind св€зывает дескриптор гнезда с именем:

  <span class=term>  bind(sd,address,length);</span>

где <span class=term> sd</span> - дескриптор гнезда,<span class=term> address</span> - адрес структуры, определ€ющей иденти-
фикатор, характерный дл€ данной комбинации домена  и  протокола  (в  функции
<span class=term>socket</span>).<span class=term> Length</span> - длина структуры address; без этого параметра €дро не знало
бы,  какова  длина  структуры, поскольку дл€ разных доменов и протоколов она
может быть различной. Ќапример, дл€ домена "UNIX system" структура  содержит
им€  файла. ѕроцессы-серверы св€зывают гнезда с именами и объ€вл€ют о состо-
€вшемс€ присвоении имен процессам-клиентам.</p>
<p>    — помощью системной функции connect делаетс€ запрос на подключение к су-
ществующему гнезду:

  <span class=term>  connect(sd,address,length);</span>

—емантический смысл параметров функции остаетс€ прежним,
но <span class=term> address </span>указывает уже на выходное гнездо, образующее противоположный ко-
нец линии св€зи. ќба гнезда должны использовать одни и те же домен и  прото-
кол св€зи, и тогда €дро удостоверит правильность установки линии св€зи. ≈сли
тип  гнезда  - дейтаграмма, сообщаемый функцией connect €дру адрес будет ис-
пользоватьс€ в последующих обращени€х к функции send через данное гнездо;  в
момент вызова никаких соединений не производитс€.</p>
<p>    ѕока процесс-сервер готовитс€ к приему св€зи по виртуальному каналу, €д-
ру  следует  выстроить поступающие запросы в очередь на обслуживание. ћакси-
мальна€ длина очереди задаетс€ с помощью системной функции<span class=term> listen</span>:

<span class=term>    listen(sd,qlength)</span>

где<span class=term> sd</span> - дескриптор гнезда, а <span class=term>qlength</span> - максимально-допустимое число  запро-
сов, ожидающих обработки.</p>
<pre>
    Џƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒњ         Џƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒњ
    ≥   ѕроцесс-клиент   ≥         ≥     ѕроцесс-сервер      ≥
    ≥         ≥          ≥         ≥          ≥  щ           ≥
    ≥         ≥          ≥         ≥     Џƒƒƒƒў  щщщщщщ      ≥
    ≥         ≥          ≥         ≥     ≥            щ      ≥
    ≥         ≥          ≥         ≥listen addr   accept addr≥
    јƒƒƒƒƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒў         јƒƒƒƒƒ≈ƒƒƒƒƒƒƒƒƒƒƒƒщƒƒƒƒƒƒў
              ≥                          ≥            щ
              јƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒўщщщщщщщщщщщщщ

               –исунок 11.19. ѕрием вызова сервером

    </pre><p>
    —истемна€  функци€  accept принимает запросы на подключение, поступающие
на вход процесса-сервера:

<span class=term>    nsd = accept(sd,address,addrlen);</span>

где<span class=term> sd</span> - дескриптор гнезда,<span class=term> address</span> - указатель на пользовательский  массив,
в  котором  €дро  возвращает  адрес  подключаемого клиента, addrlen - размер
пользовательского массива. ѕо завершении выполнени€ функции €дро  записывает
в переменную <span class=term>addrlen </span>размер пространства, фактически зан€того массивом. ‘ун-
кци€  возвращает  новый дескриптор гнезда <span class=term>(nsd)</span>, отличный от дескриптора<span class=term> sd</span>.
ѕроцесс-сервер может продолжать слежение за состо€нием объ€вленного  гнезда,
поддержива€ св€зь с клиентом по отдельному каналу (–исунок 11.19).</p>
<p>    ‘ункции send и recv выполн€ют передачу данных через подключенное гнездо.
—интаксис вызова функции <span class=term>send</span>:

<span class=term>    count = send(sd,msg,length,flags)</span>;

где <span class=term> sd</span>  - дескриптор гнезда,<span class=term> msg</span> - указатель на посылаемые данные, <span class=term>length </span>-
размер данных,<span class=term> count</span> - количество фактически переданных байт. ѕараметр<span class=term> flags</span>
может содержать значение SOF_OOB (послать данные <span class=term>out-of-band</span> - "через тамож-
ню"), если посылаемые данные не учитываютс€ в  общем  информационном  обмене
между взаимодействующими процессами. ѕрограмма удаленной регистрации, напри-
мер,  может послать<span class=term> out-of-band</span> сообщение, имитирующее нажатие на клавиатуре
терминала клавиши<span class=term> "delete"</span>. —интаксис вызова системной функции <span class=term>recv</span>:

<span class=term>    count = recv(sd,buf,length,flags)</span>;

где<span class=term> buf</span> - массив дл€ приема данных,<span class=term> length </span>- ожидаемый объем данных, <span class=term>count</span> -
количество байт, фактически  переданных  пользовательской  программе.  ‘лаги
<span class=term>(flags)</span> могут быть установлены таким образом, что поступившее сообщение пос-
ле чтени€ и анализа его содержимого не будет удалено из очереди, или настро-
ены на получение данных<span class=term> out-of-band</span>. ¬ дейтаграммных верси€х указанных функ-
ций,<span class=term> sendto и recvfrom</span>, в качестве дополнительных параметров указываютс€ ад-
реса.  ѕосле выполнени€ подключени€ к гнездам потокового типа процессы могут
вместо функций <span class=term>send и recv</span> использовать функции<span class=term> read и write</span>. “аким образом,
согласовав тип протокола, серверы могли бы  порождать  процессы,  работающие
только с функци€ми<span class=term> read и write</span>, словно имеют дело с обычными файлами.</p>
<p>    ‘ункци€ shutdown закрывает гнездовую св€зь:

  <span class=term>  shutdown(sd,mode)</span>

где<span class=term> mode</span> указывает, какой из сторон (посылающей, принимающей или обеим вмес-
те)  отныне  запрещено  участие в процессе передачи данных. ‘ункци€ сообщает
используемому протоколу о завершении сеанса сетевого взаимодействи€,  остав-
л€€,  тем  не  менее,  дескрипторы гнезд в неприкосновенности. ќсвобождаетс€
дескриптор гнезда только в результате выполнени€ функции<span class=term> close</span>.
<p>    —истемна€ функци€ getsockname получает им€ гнездовой св€зи,  установлен-
ной ранее с помощью функции <span class=term>bind</span>:

<span class=term>    getsockname(sd,name,length)</span>;
</p>
   <p> ‘ункции <span class=term> getsockopt  и setsockopt </span>получают и устанавливают значени€ раз-
личных св€занных с гнездом параметров в соответствии с типом домена и прото-
кола.</p>
<p>    –ассмотрим обслуживающую программу,  представленную  на  –исунке  11.20.
ѕроцесс  создает в домене "UNIX system" гнездо потокового типа и присваивает
ему им€ sockname. «атем с помощью функции<span class=term> listen </span>устанавливаетс€ длина  оче-
реди  поступающих сообщений и начинаетс€ цикл ожидани€ поступлени€ запросов.
‘ункци€ <span class=term>accept</span> приостанавливает свое выполнение до тех пор, пока  протоколом
не будет зарегистрирован запрос на подключение к гнезду с означенным именем;
после  этого функци€ завершаетс€, возвраща€ поступившему запросу новый деск-
риптор гнезда. ѕроцесс-сервер порождает потомка, через которого  будет  под-
держиватьс€ св€зь с процессом-клиентом; родитель и потомок при этом закрыва-
ют  свои дескрипторы, чтобы они не становились помехой дл€ коммуникационного
траффика другого процесса. ѕроцесс-потомок ведет разговор с клиентом  и  за-
вершаетс€ после выхода из функции read. ѕроцесс-сервер возвраща-
етс€ к началу цикла и ждет поступлени€ следующего запроса на подключение. </p>
<p>    Ќа  –исунке  11.21  показан  пример процесса-клиента, ведущего общение с
сервером.  лиент создает гнездо в том же домене, что и  сервер,  и  посылает
запрос  на  подключение к гнезду с именем sockname. ¬ результате подключени€

  <pre>
    Џƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒњ
    ≥ #include &lt;sys/types.h&gt;                                     ≥
    ≥ #include &lt;sys/socket.h&gt;                                    ≥
    ≥                                                            ≥
    ≥ main()                                                     ≥
    ≥ {                                                          ≥
    ≥     int sd,ns;                                             ≥
    ≥     char buf[256];                                         ≥
    ≥     struct sockaddr sockaddr;                              ≥
    ≥     int fromlen;                                           ≥
    ≥                                                            ≥
    ≥     sd = socket(AF_UNIX,SOCK_STREAM,0);                    ≥
    ≥                                                            ≥
    ≥     /* им€ гнезда - не может включать пустой символ */     ≥
    ≥     bind(sd,"sockname",sizeof("sockname") - 1);            ≥
    ≥     listen(sd,1);                                          ≥
    ≥                                                            ≥
    ≥     for (;;)                                               ≥
    ≥     {                                                      ≥
    ≥                                                            ≥
    ≥          ns = accept(sd,&sockaddr,&fromlen);               ≥
    ≥          if (fork() == 0)                                  ≥
    ≥          {                                                 ≥
    ≥              /* потомок */                                 ≥
    ≥              close(sd);                                    ≥
    ≥              read(ns,buf,sizeof(buf));                     ≥
    ≥              printf("сервер читает '%s'\n",buf);           ≥
    ≥              exit();                                       ≥
    ≥          }                                                 ≥
    ≥          close(ns);                                        ≥
    ≥     }                                                      ≥
    ≥ }                                                          ≥
    јƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒў

        –исунок 11.20. ѕроцесс-сервер в домене "UNIX system"

    Џƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒњ
    ≥ #include &lt;sys/types.h&gt;                                     ≥
    ≥ #include &lt;sys/socket.h&gt;                                    ≥
    ≥                                                            ≥
    ≥ main()                                                     ≥
    ≥ {                                                          ≥
    ≥    int sd,ns;                                              ≥
    ≥    char buf[256];                                          ≥
    ≥    struct sockaddr sockaddr;                               ≥
    ≥    int fromlen;                                            ≥
    ≥                                                            ≥
    ≥    sd = socket(AF_UNIX,SOCK_STREAM,0);                     ≥
    ≥                                                            ≥
    ≥    /* им€ в запросе на подключение не может включать       ≥
    ≥    /* пустой символ */                                     ≥
    ≥    if (connect(sd,"sockname",sizeof("sockname") - 1) == -1)≥
    ≥         exit();                                            ≥
    ≥                                                            ≥
    ≥    write(sd,"hi guy",6);                                   ≥
    ≥ }                                                          ≥
    јƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒƒў

         –исунок 11.21. ѕроцесс-клиент в домене "UNIX system"
   </pre>
процесс-клиент получает виртуальный канал св€зи с сервером. ¬  рассматривае-
мом примере клиент передает одно сообщение и завершаетс€.</p>
<p>    ≈сли сервер обслуживает процессы в сети, указание о том, что гнездо при-
надлежит домену "Internet", можно сделать следующим образом:

  <span class=term>  socket(AF_INET,SOCK_STREAM,0)</span>;

и  св€затьс€ с сетевым адресом, полученным от сервера. ¬ системе BSD имеютс€
библиотечные функции, выполн€ющие эти действи€. ¬торой  параметр  вызываемой
клиентом функции connect содержит адресную информацию, необходимую дл€ иден-
тификации машины в сети (или адреса маршрутов посылки сообщений через проме-
жуточные машины), а также дополнительную информацию, идентифицирующую прием-
ное  гнездо машины-адресата. ≈сли серверу нужно одновременно следить за сос-
то€нием сети и выполнением локальных процессов, он использует два гнезда и с
помощью функции<span class=term> select</span> определ€ет, с каким клиентом устанавливаетс€ св€зь  в
данный момент.                              </p>
</body>                                               
</html>
