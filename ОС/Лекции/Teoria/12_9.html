<HTML>
<HEAD>
<TITLE>Сетевые терминалы</TITLE>
</HEAD>
<BODY>
  <b><font size="6"><center>Сетевые терминалы</center></font></b><br>
  <br>
  Сетевые терминалы используются для того, чтобы соединить удаленного пользователя 
  с компьютером по локальной или глобальной сети. Существует две различные философские 
  концепции, касающиеся способа работы сетевых терминалов. Одна точка зрения заключается 
  в том, что сетевой терминал должен обладать огромной вычислительной мощностью 
  и памятью, что должно позволить работать на нем сложным протоколам и снизить 
  объем данных, пересылаемых по сети. (<b>Протоколом</b> называется набор запросов 
  и ответов, о которых договариваются отправитель и получатель, чтобы общаться 
  по сети или другому интерфейсу.) Другая точка зрения состоит в том, что терминал 
  должен быть максимально простым и дешевым, в основном занимающимся лишь отображением 
  пикселов на экране. В следующих двух разделах мы на примерах обсудим каждую 
  точку зрения. Сначала мы познакомимся с изощренной системой X Windows, затем 
  рассмотрим минимальный терминал <b>SLIM.</b><br>
  <br>
  <br>
<a NAME="01"></a>
  <b><font size="4">Система X Window</font></b><br>
  <br>
  Крайняя степень интеллектуального терминала представляет собой терминал, содержащий 
  центральный процессор, такой же мощный, как и у основного компьютера, с мегабайтами 
  памяти, клавиатурой и мышью. Терминалом такого типа является <b>X-терминал</b>, 
  на котором работает система <b>X Window System</b> (часто называемая просто 
  X), разработанная в Массачусетсском технологическом институте как часть проекта 
  Athena. X-терминал представляет собой компьютер, на котором работают Х-программы 
  и который взаимодействует с программами, работающими на удаленном компьютере.<br>
<dd> Программа, работающая на X-терминале, собирающая ввод с клавиатуры или мыши 
  и принимающая команды от удаленного компьютера, называется <b>Х-серве</b><b>ром.</b> 
  Она должна следить за тем, которое из окон выбрано в данный момент (то, над 
  которым находится курсор мыши). Таким образом Х-сервер узнает, которому клиенту 
  направлять ввод с клавиатуры. Х-сервер общается по сети с <b>Х-клиента</b><b>ми,</b> 
  работающими на удаленном хосте. Он посылает им ввод с клавиатуры и мыши, а также 
  принимает от них команды отображения.<br>
<dd> Может показаться странным наличие Х-сервера на терминале и клиентов на удаленном 
  хосте, но работа Х-сервера состоит в отображении битов, поэтому он должен находиться 
  близко к пользователю. С точки зрения программы, клиент велит серверу выполнить 
  те или иные действия, например вывести текст или отобразить геометрическую фигуру. 
  Сервер (в терминале), как и все серверы, просто делает то, что ему велят. Схема 
  клиента и сервера показана на рис. 5.38.<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_36.jpg" alt="Клиенты и серверы в системе X Windows"><br>
    <br>
    <b><font face="Arial">Рис. 5.38.</font></b><font face="Arial"> Клиенты и серверы 
    в системе X Windows</font><br>
  </center>
  <br>
<dd> Система X Windows может работать поверх UNIX или другой операционной системы. 
  Действительно, на многих разновидностях системы UNIX в качестве стандартной 
  оконной системы работает X Windows, даже на автономных машинах или для доступа 
  к удаленным машинам через Интернет. Что система X Windows определяет в действительности 
  — это протокол между Х-клиентом и Х-сервером, как показано на рис. 5.38. Не 
  имеет значения, работают ли клиент и сервер на одной машине, соединены ли они 
  локальной сетью на расстоянии сотни метров или между ними тысячи километров, 
  и они обмениваются информацией по Интернету. Протокол и операционная система 
  идентичны во всех случаях.<br>
<dd> Система X Windows представляет собой всего лишь оконную систему. Она не является 
  полным графическим интерфейсом пользователя. Для предоставления пользователю 
  полного графического интерфейса поверх системы X Windows запускаются другие 
  уровни программного обеспечения. Одним таким уровнем является <b>Xlib</b>, представляющий 
  собой набор библиотечных процедур, необходимых для предоставления доступа к 
  функциям системы X Windows. Эти процедуры образуют базис системы X Windows, 
  и мы их изучим ниже, но они слишком примитивны для большинства программ пользователя, 
  чтобы их применять напрямую. Например, они сообщают о каждом щелчке мыши отдельно, 
  поэтому, чтобы определить, являются ли два последовательных щелчка двойным щелчком, 
  требуется дополнительная обработка этих сообщений на уровне выше Xlib.<br>
<dd> Чтобы облегчить программирование в системе X Windows, вместе с ней поставляется 
  набор инструментальных средств, называющийся <b>Intrinsics</b> (встроенные средства). 
  Этот уровень управляет кнопками, полосами прокрутки и другими элементами графического 
  интерфейса пользователя, называемыми <b>widget</b> (&laquo;штуковина&raquo;). 
  Для создания настоящего графического интерфейса пользователя, однородно воспринимаемого 
  пользователем, требуется еще один уровень. Наиболее популярный стандарт графического 
  интерфейса пользователя называется <b>Motif</b>. Большинство приложений пользуются 
  именно функциями интерфейса Motif, а не Xlib.<br>
<dd> Также следует заметить, что управление окнами не является частью самой системы 
  X Windows. Из системы оно вынесено преднамеренно. Вместо нее созданием, удалением 
  и перемещением окон по экрану управляет отдельный Х-клиент-ский процесс, называемый 
  <b>оконным менеджером</b>. Для этого он посылает команды Х-серверу. Часто он 
  работает на той же машине, что и Х-клиент, но теоретически он может работать 
  где угодно.<br>
<dd> Такой модульный дизайн, состоящий из нескольких уровней и большого количества 
  программ, делает систему X Windows в высочайшей степени переносимой и гибкой. 
  Она была установлена на большинство версий системы UNIX, включая Sun Solaris, 
  BSD, AIX, Linux и т. п., что предоставило разработчикам стандартный интерфейс 
  пользователя на различных платформах. Система X Windows была также установлена 
  на другие операционные системы. Напротив, в системе Windows управление окнами 
  и графический интерфейс пользователя смешаны вместе в интерфейсе GDI и располагаются 
  в ядре, в результате чего управление ими усложняется. Например, графический 
  интерфейс пользователя системы Windows 98 по-прежнему в основном остается 16-разрядным, 
  спустя более чем десять лет после появления 32-разрядных процессоров Intel.<br>
<dd> Взглянем теперь на систему X Windows с точки зрения уровня Xlib. Когда в 
  системе X Windows запускается программа, она устанавливает соединение с одним 
  или более Х-серверами — мы будем называть их рабочими станциями, даже если они 
  располагаются на той же машине, что и сама программа. Система X Windows считает 
  это соединение надежным, в том смысле, что потерянные сообщения и дубликаты 
  сообщений обрабатываются сетевым программным обеспечением и программе не нужно 
  беспокоиться об ошибках связи. Обычно для соединения клиента и сервера используется 
  пара протоколов TCP/IP.<br>
<dd> По соединению передаются следующие четыре типа сообщений:<br>
  <br>
<dd> 1. Команды рисования от программы к рабочей станции.<br>
<dd> 2. Ответы рабочей станции на запросы программы.<br>
<dd> 3. Объявления о различных событиях, таких как ввод с клавиатуры или мыши 
  и т. п.<br>
<dd> 4. Сообщения об ошибках.<br>
  <br>
<dd> Большинство команд рисования посылаются от программы к рабочей станции как 
  сообщения, на которые не ожидается никакого ответа. Причина этого в том, что 
  при нахождении клиента и сервера на различных машинах для прохождения сообщения 
  и ответа на него по сети может потребоваться значительное время. Блокирование 
  прикладной программы в течение этого периода времени лишь сильно замедлило бы 
  ее выполнение без особой на то необходимости. С другой стороны, когда программе 
  требуется информация от рабочей станции, она просто должна подождать, пока не 
  придет ответ.<br>
<dd> Как и Windows, система X Windows в значительной степени управляется событиями. 
  Поток событий направляется от рабочей станции к программе, обычно в ответ на 
  некое действие пользователя, например ввод с клавиатуры, перемещение мыши или 
  открытие окна. Каждое сообщение имеет 32 байт в длину, из которых первый байт 
  содержит тип сообщения, а остальные 31 байт содержат дополнительную информацию. 
  Существует несколько десятков сообщений, но программе посылаются только те сообщения, 
  о которых она заявила, что хочет сама их обрабатывать. Например, если программу 
  не интересуют такие события, как отпускание клавиш, то о таких событиях ей не 
  сообщается. Как и в Windows, события устанавливаются в очередь, из которой их 
  читает программа. Однако в отличие от Windows операционная система никогда не 
  вызывает процедуры прикладной программы сама. Операционная система даже не знает, 
  какая процедура, какие события обрабатывает.<br>
<dd> Ключевой концепцией системы X Windows является <b>ресурс.</b> Ресурсом называется 
  структура данных, хранящая определенную информацию. Прикладные программы создают 
  ресурсы на рабочих станциях. Ресурсы могут использоваться совместно несколькими 
  процессами на рабочей станции. Обычно ресурсы живут недолго и не переживают 
  перезагрузки рабочей станции. К типичным ресурсам относятся окна, шрифты, карты 
  цветов (цветовые палитры) карты пикселов (растровые изображения), курсоры и 
  графические контексты. Последние используются для связи свойств с окнами и концептуально 
  схожи с контекстами устройств в Windows.<br>
<dd> Грубый незаконченный скелет программы для системы X Windows приведен в листинге 
  5.3. В начале этой программы включаются необходимые файлы заголовков, после 
  чего объявляются переменные. Затем она устанавливает соединение с Х-сервером, 
  указанным как параметр процедуры <i>XOpenDisplay.</i> После этого программа 
  запрашивает память для ресурса окна и сохраняет дескриптор окна в переменной 
  <i>win</i>. В действительности здесь должна производиться определенная инициализация. 
  Затем программа сообщает оконному менеджеру о существовании нового окна.<br>
  <br>
  <center>
    <b><font face="Arial">Листинг 5.3.</font></b><font face="Arial"> Скелет прикладной 
    программы для системы X Windows</font><br>
    <br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="763" HEIGHT="60">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD width="763" height="58"> #include &lt;X11/Xlib.h&gt;<br>
          #include &lt;X11/Xutil.h&gt;<br>
          main(int argc, char * argv[])<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {Display disp; /* идентификатор 
          сервера */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Window win; /* идентификатор 
          окна */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; GC gc; /* идентификатор графического 
          контекста */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XEvent event; /* место хранения 
          для одного события */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int running = 1;<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; disp = XOpenDisplay("display_name"); 
          /* установить соединение с Х-сервером */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; win = XCreateSimpleWindow(disp, 
          ... ); /* запросить память для нового окна */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XSetStandardPropertiesCdisp, 
          ...); /* объявить об окне оконному менеджеру */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; gc = XCreateGC(disp, win, 
          0, 0); /* создать графический контекст */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XSelectInput(disp, win, ButtonPressMask 
          | KeyPressMask | ExposureMask);<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XMapRaised(disp, win); /* 
          отобразить окно: послать событие Expose */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while (running)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {XNextEvent(disp, &event); /* получить следующее событие */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          switch (event,type)<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          {case Expose: ...; break; /* перерисовать окно */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          case ButtonPress: ...; break; /* обработать щелчок мыши */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          case Keypress: ...; break; /* обработать ввод с клавиатуры */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          }<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XFreeGC(disp, gc); /* освободить 
          графический контекст */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XDestroyWindow(disp, win); 
          /* вернуть память, занимаемую окном */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; XCloseDisplay(disp); /* разорвать 
          сетевое соединение */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </TD>
      </TR>
    </table>
  </center>
  <br>
<dd> Вызов <i>XCreateGC</i> создает графический контекст, в котором сохраняются 
  свойства окна. В более полной программе они, возможно, в этом месте будут проинициализированы. 
  Следующая строка, обращаясь к системной процедуре <i>XSelectInput,</i> сообщает 
  Х-серверу, какие события программа собирается обрабатывать сама. В данном случае 
  ее интересуют щелчки мыши, нажатия на клавиши и открытие окон. В действительности 
  программы обычно обрабатывают также и другие события. Наконец, вызов <i>XMapRaised</i> 
  отображает новое окно на экран поверх остальных окон. С этого момента окно становится 
  видимым на экране.<br>
<dd> Главный цикл состоит из двух операторов и логически значительно проще, чем 
  соответствующий цикл в системе Windows. Первый оператор здесь получает событие, 
  а второй осуществляет диспетчеризацию событий, направляя их на обработку в соответствии 
  с типами. Когда событие сообщает программе, что ее выполнение завершается, значение 
  логической переменной <i>running</i> устанавливается равным 0 и выполнение цикла 
  прекращается. Перед тем как закончить свою работу, программа освобождает графический 
  контекст, окно и соединение.<br>
<dd> Следует отметить, что далеко не всем программистам нравится графический интерфейс 
  пользователя. Многие предпочитают традиционный интерфейс командной строки, вроде 
  обсуждавшегося в разделе &laquo;Программное обеспечение ввода&raquo; данной 
  главы. Системой X Windows интерфейс командной строки поддерживается при помощи 
  программы <i>xterm.</i> Эта программа эмулирует старый &laquo;умный&raquo; терминал 
  VT102, поддерживающий полный набор ESC-последовательностей. В этих окнах без 
  каких бы то ни было переделок работают текстовые редакторы <i>vi</i> и <i>emacs</i>, 
  а также другое программное обеспечение, использующее базу данных termcap.<br>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Сетевой терминал SLIM</font></b><br>
  <br>
  В течение многих лет основная компьютерная парадигма колебалась между централизованными 
  и децентрализованными вычислениями. Первые компьютеры, такие как ENIAC, были 
  на самом деле персональными компьютерами, хотя и очень большими, поскольку только 
  один пользователь мог работать на таком компьютере в каждый момент времени. 
  Затем появились системы разделения времени, в которых много удаленных пользователей 
  одновременно работали на большом центральном компьютере. Потом наступила эра 
  персональных компьютеров, то есть у пользователей снова появились собственные 
  компьютеры.<br>
<dd> Хотя децентрализованная модель персональных компьютеров обладает определенными 
  преимуществами, у нее есть также серьезные недостатки, которые только последнее 
  время начинают серьезно рассматриваться. Возможно, самая большая проблема персональных 
  компьютеров состоит в том, что у каждого ПК имеется большой жесткий диск и сложное 
  программное обеспечение, которым требуется управлять. Например, при выходе новой 
  версии операционной системы на каждой машине отдельно потребуется выполнить 
  обновление программного обеспечения, что может занять довольно много времени. 
  В большинстве корпораций затраты на выполнение подобного рода работ сопоставимы 
  со стоимостью оборудования и самого программного обеспечения. Домашним пользователям 
  компьютеров не нужно платить самим себе за эту работу, однако далеко не все 
  пользователи могут выполнить ее корректно, и еще меньшему числу пользователей 
  нравится этим заниматься. В централизованных системах программное обеспечение 
  должно быть обновлено лишь на одной машине или небольшом количестве машин, для 
  обслуживания которых у корпорации обычно имеется штат экспертов, способных выполнить 
  эту работу.<br>
<dd> Помимо периодического обновления программного обеспечения, пользователям 
  также следует регулярно архивировать свои гигабайтные файловые системы, хотя 
  мало кто этим занимается. Когда случается несчастье, пользователям остается 
  только причитать. В централизованной системе резервные копии могут каждую ночь 
  записываться автоматами на магнитные ленты.<br>
<dd> Еще одно преимущество централизованной системы состоит в том, что в этом 
  случае упрощается совместное использование ресурсов. В системе из 64 удаленных 
  пользователей, у каждого из которых есть по 64 Мбайт оперативной памяти, большую 
  часть времени значительная часть памяти будет оставаться неиспользуемой. В централизованной 
  системе с 4 Гбайт ОЗУ никогда не случается так, что какому-либо пользователю 
  временно требуется много оперативной памяти, но он не может ее получить, так 
  как она кем-то занята. Тот же аргумент справедлив для дискового пространства 
  и других ресурсов.<br>
<dd> Вероятно, мы не сильно ошибемся, если скажем, что большинству пользователей 
  нужна высокопроизводительная интерактивная компьютерная среда, но они не хотели 
  бы заниматься администрированием компьютера. Это заключение заставило многих 
  исследователей вспомнить о системах разделения времени с &laquo;глупыми&raquo; 
  терминалами (теперь вежливо называемыми <b>&laquo;тонкими&raquo; клиентами</b>), 
  вполне соответствующих современным представлениям о терминалах. Система X Windows 
  была одним из шагов в этом направлении, но Х-сервер все еще остается сложной 
  системой, состоящей из нескольких мегабайтов программного обеспечения, которое 
  требуется периодически обновлять. Идеалом была бы высокопроизводительная интерактивная 
  компьютерная система, в которой машина пользователя вообще не имела бы программного 
  обеспечения. И что интересно, такая цель достижима. Ниже мы опишем одну такую 
  систему, разработанную исследователями корпорации Sun<br>
<dd> Microsystems и Стэнфордского университета. Сегодня эта система распространяется 
  на коммерческой основе корпорацией Sun [295].<br>
<dd> Система получила название <b>SLIM</b> (Stateless Low-level Interface Machine 
  — машина низкоуровневого интерфейса без состояний). В основе идеи лежит традиционная 
  схема централизованного разделения времени, показанная на рис. 5.39. Клиентские 
  машины представляют собой просто &laquo;глупые&raquo; растровые дисплеи с разрешением 
  1280x1024 точки, с клавиатурой и мышью, но без программного обеспечения, устанавливаемого 
  пользователем. Все это в большой степени соответствует духу старых &laquo;интеллектуальных&raquo; 
  алфавитно-цифровых терминалов, у которых не было никакого программного обеспечения, 
  а только некоторое количество программно-аппаратных средств для интерпретации 
  ESC-последовательностей. Терминалы такого типа, не обладающие мощными вычислительными 
  способностями, называются <b>&laquo;тонкими&raquo; клиентами.</b><br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_37.jpg" alt="Архитектура терминальной системы SLIM"><br>
    <br>
    <b><font face="Arial">Рис. 5.39.</font></b><font face="Arial"> Архитектура 
    терминальной системы SLIM</font><br>
  </center>
  <br>
<dd> Простейшая модель, состоящая в передаче сервером растровых изображений по 
  сети &laquo;тонким&raquo; клиентам, не работает. Для этого потребуется пропускная 
  способность для каждой выделенной линии около 2 Гбайт/с, что слишком много для 
  современных сетей. Следующая по простоте модель, заключающаяся в хранении образа 
  экрана в буфере кадра на терминале и обновлении экрана локально, является намного 
  более обещающей. В частности, если центральный сервер будет хранить копию буфера 
  кадра каждого терминала и посылать только обновления (изменения), требуемая 
  пропускная способность будет уже не столь велика. Таким образом работают &laquo;тонкие&raquo; 
  клиенты системы SLIM.<br>
<dd> В отличие от Х-протокола, состоящего из сотен сложных сообщений для управления 
  окнами, рисования геометрических фигур и отображения текста различными шрифтами, 
  у протокола SLIM есть всего пять сообщений от сервера к терминалу, перечисленные 
  в табл. 5.6 (помимо них имеется еще небольшое количество не приведенных в таблице 
  управляющих сообщений). Сообщение SET просто заменяет прямоугольник в буфере 
  кадра новыми пикселами. Каждый заменяемый пиксел требует трех байтов в сообщении, 
  чтобы указать его полное (24-разрядное) значение цвета. В принципе этого сообщения 
  достаточно, чтобы выполнить всю работу. Остальные сообщения представляют собой 
  всего лишь оптимизацию.<br>
  <br>
  <center>
    <b><font face="Arial">Таблица 5.6.</font></b><font face="Arial"> Сообщения 
    от сервера к терминалу протокола SLIM</font><br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="593" height="165">
      <tr> 
        <td width="112" align="center" height="39"><b>Сообщение</b></td>
        <td width="481" height="39"> 
          <p align="center"><b> Значение</b> 
        </td>
      </tr>
      <tr> 
        <td width="112" align="center" height="19"> SET</td>
        <td width="481" height="19"> Обновить прямоугольник новыми пикселами</td>
      </tr>
      <tr> 
        <td width="112" align="center" height="19"> FILL</td>
        <td width="481" height="19"> Заполнить прямоугольник пикселами одного 
          значения</td>
      </tr>
      <tr> 
        <td width="112" align="center" height="19"> BITMAP</td>
        <td width="481" height="19"> Растянуть растровое изображение, чтобы заполнить 
          прямоугольник</td>
      </tr>
      <tr> 
        <td width="112" align="center" height="19"> COPY</td>
        <td width="481" height="19"> Копировать прямоугольник из одной части буфера 
          в другую</td>
      </tr>
      <tr> 
        <td width="112" align="center" height="38"> CSCS</td>
        <td width="481" height="38"> Преобразовать прямоугольник в RGB из телевизионной 
          системы цветов (YUV)</td>
      </tr>
    </table>
  </center>
  <br>
<dd> Сообщение FILL заполняет целый прямоугольник пикселами одного значения. Эта 
  команда используется для заполнения однородных фоновых поверхностей. Сообщение 
  BITMAP заполняет целый прямоугольник, повторяя одно растровое изображение, содержащееся 
  в сообщении. Эта команда полезна для заполнения мозаичного фона.<br>
<dd> Сообщение COPY велит терминалу скопировать прямоугольник из одной части экранного 
  буфера в другую. Она наиболее всего полезна при скроллинге экрана и перемещении 
  окон.<br>
<dd> Наконец, сообщение CSCS преобразует цвета из системы YUV, используемой в 
  США в телевизионной системе NTSC, в систему RGB, применяемую компьютерными мониторами. 
  В первую очередь эта команда может использоваться при передаче необработанного 
  видеокадра от сервера терминалу. Алгоритм преобразования несложен, но занимает 
  много времени, поэтому эту работу лучше поручить терминалам. Если терминалы 
  не будут использоваться для просмотра видеоформата NTSC, то это сообщение не 
  понадобится.<br>
<dd> В целом идея &laquo;глупых&raquo; &laquo;тонких&raquo; клиентов оказывается 
  либо работоспособной, либо неработоспособной в зависимости от требующейся и 
  доступной производительности сети и серверов, измерением которой интенсивно 
  занимались Шмидт с коллегами [295]. В исследуемом ими прототипе как на участке 
  между серверами и коммутатором, так и для соединений между коммутатором и терминалами 
  использовалась 100-Мбитная коммутируемая быстрая сеть Ethernet. В принципе сервер 
  с коммутатором можно было соединить и гигабитной сетью, так как весь этот участок 
  находился в центральном вычислительном зале.<br>
<dd> Первые измерения касались вывода эха символа на экран. Каждый введенный с 
  клавиатуры символ посылается на сервер, который вычисляет координаты пикселов, 
  требующих обновления, чтобы поместить на экран символ в нужную позицию, с правильными 
  цветами и шрифтом. Измерения показали, что для появления символа на экране требуется 
  0,5 мс. Для сравнения: на локальной рабочей станции из-за буферизации в ядре 
  это время составляет около 30 мс.<br>
<dd> Остальные тесты измеряли производительность системы. При этом пользователи 
  работали с современными интерактивными прикладными программами, такими как Adobe 
  Photoshop (программа для ретуширования фотографий), Adobe Framemaker (настольная 
  издательская система) и Netscape (web-браузер). Было замечено, что половина 
  команд пользователей требовала обновления менее 10 000 пикселов, что в несжатом 
  виде составляет 30 000 байт. На скорости 10 Мбит/с для передачи по кабелю 10 
  000 пикселов требуется 2,4 мс. Еще 2,7 мс нужно для помещения их в буфер кадра 
  по прибытии, итого 5,1 мс (это время может немного варьироваться в зависимости 
  от обстоятельств). Поскольку время реакции человека составляет около 100 мс, 
  обновления кажутся практически мгновенными. Даже изменения больших объемов данных 
  воспринимались бы как почти мгновенные. Более того, при использовании сжатия 
  для более чем 85 % обновлений экрана требуется передача менее 30 000 байт.<br>
<dd> Эксперименты были повторены с 10-Мбитной сетью, 1-Мбитной сетью и 128-Кбитной 
  сетью. При использовании 10-Мбитной сети система была практически мгновенной. 
  На 1-Мбитной сети результаты оставались хорошими. 128-Кбитная сеть оказалась 
  слишком медленной для таких задач. Поскольку соединения с пропускной способностью 
  1 Мбит/с становятся все более распространенными благодаря сетям кабельного телевидения 
  и ADSL (Asymmetric Digital Subscriber Loop — асимметричная цифровая абонентская 
  линия), то, похоже, что эта технология уже может применяться как для домашних 
  пользователей, так и для деловых клиентов.<br>
</BODY>
</HTML>
