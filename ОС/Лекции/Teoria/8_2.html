<HTML>
<HEAD>
<TITLE>Ресурсы</TITLE>
</HEAD>
<body>
  <b><font size="6"><center>Ресурсы</center></font></b><br>
  <br>
  Система может зайти в тупик, когда процессам предоставляются исключительные 
  права доступа к устройствам, файлам и т. д. Чтобы максимально обобщить рассказ 
  о взаимоблокировках, мы будем называть объекты предоставления доступа ресурсами. 
  Ресурсом может быть аппаратное устройство (например, накопитель на магнитной 
  ленте) или часть информации (например, закрытая запись в базе данных). В компьютере 
  существует масса различных ресурсов, к которым могут происходить обращения. 
  Кроме того, в системе может оказаться несколько идентичных экземпляров какого-либо 
  ресурса, например три накопителя на магнитных лентах. Если в системе есть несколько 
  экземпляров ресурса, то в ответ на обращение к нему может предоставляться любая 
  из доступных копий. Короче говоря, ресурс — это все то, что может использоваться 
  только одним процессом в любой момент времени.<br>
  <br>
  <br>
<a NAME="01"></a>
  <b><font size="4">Выгружаемые и невыгружаемые ресурсы</font></b><br>
  <br>
  Ресурсы бывают двух типов: выгружаемые и невыгружаемые. Выгружаемый ресурс можно 
  безболезненно забирать у владеющего им процесса. Образцом такого ресурса является 
  память. Рассмотрим, например, систему с пользовательской памятью размером 32 
  Мбайт, одним принтером и двумя процессами по 32 Мбайт, каждый из которых хочет 
  что-то напечатать. Процесс <i>А </i> запрашивает и получает принтер, затем начинает 
  вычислять данные для печати. Еще не закончив расчеты, он превышает свой квант 
  времени и выгружается на диск в область подкачки.<br>
<dd> Теперь работает процесс <i>В</i> и безуспешно пытается обратиться к принтеру. 
  В данный момент мы получили потенциальную тупиковую ситуацию, потому что процесс 
  <i>А</i> использует принтер, а процесс <i>В</i> занимает память, и ни один из 
  них не может продолжать работу без ресурса, удерживаемого другим. К счастью, 
  можно выгрузить (забрать) память у процесса В, переместив его на диск в область 
  подкачки и скачав с диска в память процесс <i>А.</i> Теперь процесс <i>А</i> 
  может закончить вычисления, выполнить печать и затем освободить принтер. Взаимоблокировки 
  не происходит.<br>
<dd> <b>Невыгружаемый ресурс,</b> в противоположность выгружаемому, — это такой 
  ресурс, который нельзя забрать от текущего владельца, не уничтожив результаты 
  вычислений. Если в момент записи компакт-диска внезапно отнять у процесса устройство 
  для записи и передать его другому процессу, то в результате мы получим испорченный 
  компакт-диск. Устройство для записи компакт-дисков не является выгружаемым в 
  произвольный момент времени ресурсом.<br>
<dd> Вообще говоря, взаимоблокировки касаются невыгружаемых ресурсов. Потенциальные 
  тупиковые ситуации, в которые вовлечен противоположный вид ресурсов, обычно 
  можно разрешить с помощью перераспределения ресурсов от одного процесса к другому. 
  Поэтому мы сконцентрируем свое внимание на невыгружаемых ресурсах.<br>
<dd> Последовательность событий, необходимых для использования ресурса, представлена 
  ниже в абстрактной форме:<br>
  <br>
<dd> 1. Запрос ресурса.<br>
<dd> 2. Использование ресурса.<br>
<dd> 3. Возврат ресурса.<br>
  <br>
<dd> Если ресурс недоступен, когда он требуется, то запрашивающий его процесс 
  вынужден ждать. В некоторых операционных системах при неудачном обращении к 
  ресурсу процесс автоматически блокируется и возобновляется только после того, 
  как ресурс становится доступным. В других системах запрос ресурса, получивший 
  отказ, возвращает код ошибки, тогда вызывающий процесс может подождать немного 
  и повторить попытку заново.<br>
<dd> Процесс, чье обращение к ресурсу оказалось неудачным, обычно дальше попадает 
  в короткий цикл: запрос ресурса, затем режим ожидания, потом очередная попытка. 
  Хотя этот процесс не блокирован, он во всех смыслах ведет себя, как заблокированный, 
  поскольку не может выполнить никакой полезной работы. В дальнейшем мы будем 
  предполагать, что когда процессу отказывается в предоставлении ресурса, он переходит 
  в режим ожидания.<br>
<dd> Истинная природа запросов ресурсов сильно зависит от системы. В некоторых 
  системах существует системный вызов request, позволяющий процессам запрашивать 
  ресурсы явно. В других случаях единственный вид ресурсов, известных операционной 
  системе, — это специальные файлы, которые в каждый данный момент времени могут 
  открыть только один процесс. Они открываются с помощью обычного вызова open. 
  Если файл уже используется, вызывающая программа блокируется до тех пор, пока 
  текущий владелец файла не закроет его.<br>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Получение ресурса</font></b><br>
  <br>
  Для некоторых видов ресурсов, таких как записи в базе данных, управление использованием 
  ресурсов зависит от самих пользовательских процессов. Один из способов, делающих 
  возможным пользовательское управление, заключается в присоединении семафора 
  к каждому из ресурсов. Все семафоры в исходном состоянии равны 1. С тем же успехом 
  можно использовать мьютексы. Три шага, перечисленные выше, выполняются следующим 
  образом: сначала для запроса ресурса используется вызов down, примененный к 
  семафору, затем программа использует ресурс и, наконец, используется вызов up 
  для его освобождения. Эти шаги представлены в листинге 3.1, а.<br>
  <br>
  <center>
    <font face="Arial"><b>Листинг 3.1.</b> Использование семафора для защиты ресурсов: 
    один ресурс (а); два ресурса (б)<br>
    </font> <br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="599" HEIGHT="181">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD width="341" height="179"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="226" HEIGHT="63">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD width="226" height="61"> typedef int semaphore;<br>
                semaphore resource_1;<br>
                void process_A(void)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {down(&amp;resource_1);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use_resource_1( );<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;resource_1);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </TD>
            </TR>
          </TABLE>
          <br>
          <br>
          <br>
          <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            <i>а</i></p>
        </TD>
        <TD width="267" height="179"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="261" HEIGHT="99">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD width="296" height="97"> typedef int semaphore;<br>
                semaphore resource_1;<br>
                semaphore resource_2;<br>
                void process_A(void)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {down(&amp;resource_1);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; down(&amp;resource_2);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use_both_resources( 
                );<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;resource_2);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;resource_1);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </TD>
            </TR>
          </TABLE>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>б</i> 
        </TD>
      </TR>
    </TABLE>
  </center>
  <br>
<dd> Иногда процессы нуждаются в двух и более ресурсах. Их можно получать последовательно, 
  как показано в листинге 3.1, б. Если требуется больше двух ресурсов, их запрашивают 
  непосредственно один за другим.<br>
<dd> Пока все хорошо. Эта схема работает прекрасно до тех пор, пока она касается 
  только одного процесса. Конечно, при наличии всего лишь одного процесса отсутствует 
  необходимость формального приобретения ресурсов, поскольку не возникает соперничества 
  за их использование.<br>
<dd> Теперь рассмотрим ситуацию с двумя процессами <i>А</i> и <i>В</i> и двумя 
  ресурсами. В листинге 3.2 показаны два сценария: <i>а — оба</i> процесса получают 
  ресурсы в одном и том же порядке; <i>б —</i> они запрашивают ресурсы в разном 
  порядке. Разница может показаться несущественной, но это не так.<br>
<dd> В листинге 3.2, а один из процессов запрашивает первый ресурс, опережая второй 
  процесс. Затем этот же процесс успешно получает второй ресурс и выполняет свою 
  работу. Если второй процесс попытается получить ресурс 1 до его освобождения, 
  второй процесс просто будет заблокирован до тех пор, пока не станет доступен 
  ресурс.<br>
<dd> Другая ситуация представлена в листинге 3.2, <i>б.</i> Может случиться так, 
  что один из процессов получит оба ресурса и эффективно блокирует другой процесс 
  до завершения своей работы. Однако также может произойти и то, что процесс <i>А</i> 
  займет ресурс 1, а процесс <i>В</i> получит ресурс 2. Теперь, когда они попытаются 
  запросить еще по одному ресурсу, каждый из них будет заблокирован. Ни один из 
  двух процессов не сможет когда-либо заработать снова. Это ситуация взаимоблокировки.<br>
<dd> Здесь мы видим, как проявляется несущественное различие в коде программы 
  — последовательность запросов ресурсов, — которое вызывает разницу между работающей 
  программой и программой, завершающейся аварийно, причем с трудно обнаруживаемой 
  причиной ошибки. Поскольку взаимоблокировки могут происходить так просто, на 
  поиски методов борьбы с ними было направлено большое количество исследований. 
  В этой главе подробно будут обсуждены тупиковые ситуации и то, что можно в таких 
  ситуациях предпринять.<br>
  <br>
  <center>
    <b><font face="Arial">Листинг 3.2.</font></b><font face="Arial"> Код, не приводящий 
    к тупику (а); код с потенциальной взаимоблокировкой (б)</font><br>
    <br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="599" HEIGHT="181">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD width="341" height="179"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="232" HEIGHT="63">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD width="232" height="61"> typedef int semaphore;<br>
                semaphore resource_1;<br>
                semaphore resource_2;<br>
                void process_A(void)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {down(&amp;resource_1);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; down(&amp;resource_2);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use_both_resources( 
                );<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;resource_2);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;resource_1);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
                void process_B(void)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {down(&resource_1);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; down(&resource_2);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use_both_resources( 
                );<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;resource_2);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;resource_l);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </TD>
            </TR>
          </TABLE>
          <br>
          <center>
            <i>а</i> 
          </center>
        </TD>
        <TD width="267" height="179"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="261" HEIGHT="99">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD width="296" height="97"> typedef int semaphore;<br>
                semaphore resource_1;<br>
                semaphore resource_2;<br>
                void process_A(void)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {down(&amp;resource_1);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; down(&resource_2);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use_both_resources( 
                );<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;resource_2);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;resource_1);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; }<br>
                void process_B(void)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; {down(&resource_2);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; down(&resource_l);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use_both_resources( 
                );<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;resource_l);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; up(&amp;resource_2);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; } </TD>
            </TR>
          </TABLE>
          <br>
          <center>
            <i>б</i> 
          </center>
        </TD>
      </TR>
    </TABLE>
    <br>
  </center>
</BODY>
</HTML>
