<HTML>
<HEAD>
<TITLE>Потоки</TITLE>
</HEAD>
<body>
  
<h1 align="center"><B>Потоки</B></h1>
<p>В обычных операционных системах каждому процессу соответствует адресное пространство 
  и одиночный управляющий поток. Фактически это и определяет процесс. Тем не менее 
  часто встречаются ситуации, в которых предпочтительно иметь несколько квазипараллельных 
  управляющих потоков в одном адресном пространстве, как если бы они были различными 
  процессами (однако разделяющим одно адресное пространство). В следующих разделах 
  мы рассмотрим такие ситуации.<BR>
 </p>
<p>
  <br>
<a NAME="01"></a>
  <B><font size="4">Модель потока</font></B><BR>
  <br>
  Модель процесса, которую мы рассматривали, базируется на двух независимых концепциях: 
  группировании ресурсов и выполнении программы. Иногда полезно их разделять, 
  и тут появляется понятие потока.<BR>
</p>
<p>С одной стороны, процесс можно рассматривать как способ объединения родственных 
  ресурсов в одну группу. У процесса есть адресное пространство, содержащее текст 
  программы и данные, а также другие ресурсы. Ресурсами являются открытые файлы, 
  дочерние процессы, необработанные аварийные сообщения, обработчики сигналов, 
  учетная информация и многое другое. Гораздо проще управлять ресурсами, объединив 
  их в форме процесса.<BR>
</p>
<p>С другой стороны, процесс можно рассматривать как поток исполняемых команд 
  или просто <B>поток. </B>У потока есть счетчик команд, отслеживающий порядок 
  выполнения действий. У него есть регистры, в которых хранятся текущие переменные. 
  У него есть стек, содержащий протокол выполнения процесса, где на каждую процедуру, 
  вызванную, но еще не вернувшуюся, отведен отдельный фрейм. Хотя поток должен 
  исполняться внутри процесса, следует различать концепции потока и процесса. 
  Процессы используются для группирования ресурсов, а потоки являются объектами, 
  поочередно исполняющимися на центральном процессоре.<BR>
</p>
<p>Концепция потоков добавляет к модели процесса возможность одновременного выполнения 
  в одной и той же среде процесса нескольких программ, в достаточной степени независимых. 
  Несколько потоков, работающих параллельно в одном процессе, аналогичны нескольким 
  процессам, идущим параллельно на одном компьютере. В первом случае потоки разделяют 
  адресное пространство, открытые файлы и другие ресурсы. Во втором случае процессы 
  совместно пользуются физической памятью, дисками, принтерами и другими ресурсами. 
  Потоки обладают некоторыми свойствами процессов, поэтому их иногда называют 
  <B>упрощенными процессами. </B>Термин <B>многопоточность </B>также используется 
  для описания использования нескольких потоков в одном процессе.<BR>
</p>
<p>На рис. 2.4, <i>а </i>представлены три обычных процесса, у каждого из которых 
  есть собственное адресное пространство и одиночный поток управления. На рис. 
  2.4, <i>б </i>представлен один процесс с тремя потоками управления. В обоих 
  случаях мы имеем три потока, но на рис. 2.4, <i>а </i>каждый из них имеет собственное 
  адресное пространство, а на рис. 2.4, б потоки разделяют единое адресное пространство.<BR>
</p>
<p>При запуске многопоточного процесса в системе с одним процессором потоки работают 
  поочередно. Пример работы процессов в многозадачном режиме мы уже видели на 
  рис. 2.1. Иллюзия параллельной работы нескольких различных последовательных 
  процессов создается путем постоянного переключения системы между процессами. 
  Многопоточность реализуется примерно так же. Процессор быстро переключается 
  между потоками, создавая впечатление параллельной работы потоков, хотя и на 
  не столь быстром процессоре. В случае трех ограниченных производительностью 
  процессора потоков в одном процессе все потоки будут работать параллельно, и 
  каждому потоку будет соответствовать виртуальный процессор с быстродействием, 
  равным одной трети быстродействия реального процессора.<BR>
  <br>
  
</p>
<center>
    <img src="06/Tanenbaum_2_4.jpg" alt="Три процесса с одиночными потоками управления"><br>
    <br>
    <font face="Arial"><B>Рис. 2.4. </B>Три процесса с одиночными потоками управления 
    (а); один процесс с тремя<BR>
    потоками управления (б)</font><BR>
  </center>
  <br>
<p>Различные потоки в одном процессе не так независимы, как различные процессы. 
  У всех потоков одно и то же адресное пространство, что означает совместное использование 
  глобальных переменных. Поскольку любой поток имеет доступ к любому адресу ячейки 
  памяти в адресном пространстве процесса, один поток может считывать, записывать 
  или даже стирать информацию из стека другого потока. Защиты не существует, поскольку 
  (1) это невозможно и (2) это ненужно. В отличие от различных процессов, которые 
  могут быть инициированы различными пользователями и преследовать несовместимые 
  цели, один процесс всегда запущен одним пользователем, и потоки созданы таким 
  образом, чтобы работать совместно, не мешая друг другу. Как показано в табл. 
  2.3, потоки разделяют не только адресное пространство, но и открытые файлы, 
  дочерние процессы, сигналы и т. п. Таким образом, ситуацию на рис. 2.4, <i>а 
  </i>следует использовать в случае абсолютно несвязанных процессов, тогда как 
  схема на рис. 2.4, <i>б </i>будет уместна, когда потоки выполняют совместно 
  одну работу.<BR>
  <br>
  
</p>
<center>
    <font face="Arial"><B>Таблица 2.3. </B>В первой колонке перечислены элементы, 
    совместно используемые всеми потоками процесса, а во второй — элементы, индивидуальные 
    для каждого потока</font><BR>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="551" HEIGHT="135">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD height="133"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="568" HEIGHT="25">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="349" HEIGHT="22"><B>Элементы 
                процесса</B></TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="213" HEIGHT="22"><B>Элементы 
                потока</B></TD>
            </TR>
          </TABLE>
          <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="567" HEIGHT="133">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="353" HEIGHT="22">Адресное пространство</TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="214" HEIGHT="22"> Счетчик команд 
              </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="353" HEIGHT="22">Глобальные 
                переменные</TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="214" HEIGHT="22"> Регистры 
              </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="353" HEIGHT="22"> Открытые 
                файлы </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="214" HEIGHT="22"> Стек </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="353" HEIGHT="22"> Дочерние 
                процессы </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="214" HEIGHT="22"> Состояние 
              </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="353" HEIGHT="22"> Необработанные 
                аварийные сигналы </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="214" HEIGHT="22"> </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="353" HEIGHT="22"> Сигналы и 
                их обработчики </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="214" HEIGHT="22"> </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="353" HEIGHT="22"> Информация 
                об использовании ресурсов </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="214" HEIGHT="22"> </TD>
            </TR>
          </TABLE>
        </TD>
      </TR>
    </TABLE>
  </center>
  <br>
<p>Первая колонка содержит элементы, являющиеся свойствами процесса, а не потока. 
  Например, если один поток открывает файл, этот файл тут же становится видимым 
  для остальных потоков, и они могут считывать информацию и записывать ее в файл. 
  Это логично, поскольку процесс, а не поток является единицей управления ресурсами. 
  Если бы у каждого потока было собственное адресное пространство, открытые файлы, 
  аварийные сигналы, требующие обработки и т. д., это были бы отдельные процессы. 
  Концепция потоков состоит в возможности совместного использования набора ресурсов 
  несколькими потоками для выполнения некой задачи в тесном взаимодействии.<BR>
</p>
<p>Как и любой обычный процесс (то есть процесс с одним потоком), поток может 
  находиться в одном из нескольких состояний: рабочем, заблокированном, готовности 
  или завершенном. Действующий поток взаимодействует с процессором. Блокированный 
  поток ожидает некоторого события, которое его разблокирует. Например, при выполнении 
  системного запроса чтения с клавиатуры поток блокируется, пока не поступит сигнал 
  с клавиатуры. Поток может быть разблокирован каким-либо внешним событием или 
  другим потоком. Поток в состоянии готовности будет запущен, как только до него 
  дойдет очередь. Переходы между состояниями потоков такие же, как на рис. 2.2.<BR>
</p>
<p>Важно понимать, что у каждого потока свой собственный стек, как показано на 
  рис. 2.5. Стек каждого потока содержит по одному фрейму для каждой процедуры, 
  вызванной, но еще не вернувшей управления. Во фрейме находятся локальные переменные 
  процедуры и адрес возврата. Например, если процедура <B><I>X</I></B><i> </i>вызывает 
  процедуру <B><I>Y</I></B> и она, в свою очередь, вызывает процедуру <B>Z</B>, 
  то во время работы процедуры <B>Z</B> в стеке будут находиться фреймы для всех 
  трех процедур. Каждый поток может вызывать различные процедуры и, соответственно, 
  иметь различный протокол выполнения процесса — именно поэтому каждому потоку 
  необходим собственный стек.<BR>
  
</p>
<center>
    <br>
    <img src="06/Tanenbaum_2_5.jpg" alt="У каждого потока свой собственный стек"><br>
    <br>
    <font face="Arial"><B>Рис. 2.5.</B> У каждого потока свой собственный стек</font><BR>
  </center>
  <br>
<p>В многопоточном режиме процессы, как правило, запускаются с одним потоком. 
  Этот поток может создавать новые потоки, вызывая библиотечную процедуру, например 
  <i>thread_create. </i>Параметром обычно является имя процедуры, которую необходимо 
  запустить для создания нового потока. Указание какой-либо информации, касающейся 
  адресного пространства нового потока, не является необходимым (или даже возможным), 
  поскольку новый поток создается в адресном пространстве существующего потока. 
  Иногда возникает иерархия потоков с отношениями типа &laquo;родительский—дочерний 
  поток&raquo;, но чаще всего иерархия отсутствует и все потоки считаются равнозначными. 
  Независимо от иерархических отношений, создающему потоку чаще всего возвращается 
  идентификатор потока, который дает имя новому потоку.<BR>
</p>
<p>Выполнив задачу, поток может прекратить работу, вызвав библиотечную процедуру, 
  скажем, <i>thread_exit. </i>После этого поток исчезает и уже не рассматривается 
  планировщиком. В некоторых потоковых системах один поток может ждать прекращения 
  работы другого (определенного) потока. Для этого вызывается процедура, например 
  <i>thread_wait. </i>Процедура блокирует вызывающий процедуру поток, пока другой 
  поток (определенный) не прекратит работу. В этом отношении создание и завершение 
  потоков очень похожи на создание и завершение процессов с практически такими 
  же параметрами.<BR>
</p>
<p>Еще одно распространенное обращение потока — <i>thread_yield — </i>позволяет 
  потоку добровольно &laquo;уступать свою очередь&raquo; другому потоку. Это важный 
  момент, поскольку в случае потоков не существует прерывания по таймеру, позволяющего 
  установить режим разделения времени, как это было в случае процессов. Потокам 
  необходимо быть вежливыми и время от времени самим уступать процессор другим 
  потокам. Существуют и процедуры, позволяющие одному потоку подождать, пока другой 
  завершит какое-либо действие, оповестить о том, что он закончил какое-либо действие 
  и т. п.<BR>
</p>
<p>Несмотря на то что потоки часто бывают полезными, они существенно усложняют 
  программную модель. Представьте себе системный вызов fork в UNIX. Если у родительского 
  процесса было много потоков, должно ли это свойство распространяться на дочерний 
  процесс? Если нет, то процесс может неправильно функционировать, поскольку все 
  потоки могут оказаться необходимы.<BR>
</p>
<p>Но что произойдет, если поток родительского процесса будет блокирован вызовом 
  read с клавиатуры, а у дочернего процесса столько же потоков, сколько у родительского? 
  Будут ли теперь блокированы два потока — один из родительского процесса, другой 
  из дочернего? И если с клавиатуры поступит строка, получат ли оба потока ее 
  копию? Или только один — тогда какой? Эта же проблема возникает при работе с 
  открытыми сетевыми соединениями.<BR>
</p>
<p>Другой класс проблем связан с тем, что потоки совместно используют большое 
  количество структур данных. Что произойдет, если один поток закроет файл в то 
  время, когда другой считывает из него данные? Представьте себе, что одному потоку 
  стало недостаточно памяти и он просит выделить дополнительную память. На полпути 
  происходит переключение потоков, и теперь новый поток также замечает, что ему 
  не хватает памяти, и просит выделить дополнительную память. В этой ситуации 
  память может быть выделена дважды. Все эти проблемы можно решить, но для создания 
  корректно работающих многопоточных программ необходима тщательная и всесторонне 
  обдуманная разработка.<BR>
  <br>
  <br>
<a NAME="02"></a>
  <B><font size="4">Использование потоков</font></B><BR>
  <br>
  Настало время объяснить, почему же, собственно, потоки так необходимы. Основной 
  причиной является выполнение большинством приложений существенного числа действий, 
  некоторые из них могут время от времени блокироваться. Схему программы можно 
  существенно упростить, если разбить приложение на несколько последовательных 
  потоков, запущенных в квазипараллельном режиме.<BR>
</p>
<p>С этим рассуждением мы уже сталкивались — оно являлось аргументом в пользу 
  существования процессов, не так ли? Мы можем рассуждать на языке параллельных 
  процессов вместо прерываний, таймеров и переключателей контекста. В случае потоков 
  придется добавить еще один элемент: возможность совместного использования параллельными 
  объектами адресного пространства и всех содержащихся в нем данных. Для определенных 
  приложений эта возможность является существенной, и в таких случаях схема параллельных 
  процессов (с разными адресными пространствами) не подходит.<BR>
</p>
<p>Еще одним аргументом в пользу потоков является легкость их создания и уничтожения 
  (поскольку с потоком не связаны никакие ресурсы). В большинстве систем на создание 
  потока уходит примерно в 100 раз меньше времени, чем на создание процесса. Это 
  свойство особенно полезно, если необходимо динамическое и быстрое изменение 
  числа потоков.<BR>
</p>
<p>Третьим аргументом является производительность. Концепция потоков не дает 
  увеличения производительности, если все они ограничены возможностями процессора. 
  Но когда имеется одновременная потребность в выполнении большого объема вычислений 
  и операций ввода-вывода, наличие потоков позволяет совмещать эти виды деятельности 
  во времени, тем самым увеличивая общую скорость работы приложения.<BR>
</p>
<p>И наконец, концепция потоков полезна в системах с несколькими процессорами, 
  где возможен настоящий параллелизм. Мы еще вернемся к этой теме в главе 8.<BR>
  Необходимость потоков проще продемонстрировать на конкретных примерах. Возьмем 
  в качестве первого примера текстовый редактор. Большинство текстовых редакторов 
  выводят текст на экран монитора в том виде, в котором он будет напечатан. В 
  частности, разрывы строк и страниц находятся на своих местах, и пользователь 
  может при необходимости их откорректировать (например, удалить неполные строки 
  вверху и внизу страницы, неприемлемые с эстетической точки зрения).<BR>
</p>
<p>Представьте себе, что пользователь пишет книгу. С точки зрения автора проще 
  всего хранить книгу в одном файле, чтобы легче было искать отдельные разделы, 
  выполнять глобальную замену и т. п. С другой стороны, можно хранить каждую главу 
  в отдельном файле. Но было бы крайне неудобно хранить каждый раздел и параграф 
  в своем файле — в случае глобальных изменений пришлось бы редактировать сотни 
  файлов. Например, если предполагаемый стандарт ххх был утвержден только перед 
  отправкой книги в печать, придется заменять &laquo;Черновой стандарт ххх&raquo; 
  на &laquo;Стандарт ххх&raquo; в последнюю минуту. Эта операция делается одной 
  командой в случае одного файла и, напротив, займет очень много времени, если 
  придется редактировать каждый из 300 файлов, на которые разбита книга.<BR>
</p>
<p>Теперь представьте себе, что произойдет, если пользователь удалит одно предложение 
  на первой странице документа, в котором 800 страниц. Пользователь перечитал 
  эту страницу и решил исправить предложение на 600-й странице. Он дает команду 
  текстовому редактору перейти на страницу с номером 600 (например, задав поиск 
  фразы, встречающейся только на этой странице). Текстовому редактору придется 
  переформатировать весь документ вплоть до 600 страницы, поскольку до форматирования 
  он не будет знать, где начинается эта страница. Это может занять довольно много 
  времени и вряд ли обрадует пользователя.<BR>
</p>
<p>В этом случае помогут потоки. Пусть текстовый редактор написан в виде двух-поточной 
  программы. Один поток взаимодействует с пользователем, а второй переформатирует 
  документ в фоновом режиме. Как только предложение на первой странице было удалено, 
  интерактивный поток дает команду фоновому потоку переформатировать весь документ. 
  В то время как первый поток продолжает отслеживать и выполнять команды с клавиатуры 
  или мыши — предположим, прокручивает первую страницу, — второй поток быстро 
  переформатирует книгу. Немного везения — и форматирование будет закончено раньше, 
  чем пользователь захочет перейти к 600 странице, и тогда команда будет выполнена 
  мгновенно.<BR>
</p>
<p>Раз уж мы об этом задумались, почему бы не добавить третий поток? Большинство 
  текстовых редакторов автоматически сохраняет редактируемый текст раз в несколько 
  минут, чтобы пользователь не лишился плодов работы целого дня в случае аварийного 
  завершения программы, отказа системы или перебоев с питанием. Этим может заниматься 
  третий поток, не отвлекая два оставшихся (рис. 2.6).<BR>
  
</p>
<center>
    <br>
    <img src="06/Tanenbaum_2_6.jpg" alt="Текстовый редактор с тремя потоками"><br>
    <br>
    <font face="Arial"><B>Рис. 2.6. </B>Текстовый редактор с тремя потоками</font><BR>
  </center>
  <br>
<p>Если бы программа была однопоточной, тогда при каждой операции сохранения 
  файла все команды с клавиатуры и мыши игнорировались до окончания дисковой операции. 
  У пользователя это создало бы впечатление низкой производительности. В качестве 
  альтернативы команды с клавиатуры и мыши могут прерывать сохранение файла, обеспечивая 
  высокую производительность, но приводя к сложной программной модели, управляемой 
  прерываниями. Программная модель с тремя потоками существенно проще. Первый 
  поток взаимодействует с пользователем, второй при необходимости переформатирует 
  документ, а третий периодически сохраняет на диске содержимое оперативной памяти.<BR>
</p>
<p>Очевидно, что в этом случае модель с тремя процессами не подойдет, поскольку 
  всем трем необходимо работать с одним и тем же документом. Три же потока совместно 
  используют общую память, и все три имеют доступ к документу.<BR>
</p>
<p>Ситуация выглядит точно так же в случае многих других интерактивных программ. 
  Динамическая электронная таблица — программа, позволяющая пользователю работать 
  с матрицей, некоторые элементы которой заданы пользователем. Остальные элементы 
  вычисляются на основе заданных элементов с использованием достаточно сложных 
  формул. Если пользователь изменяет один элемент матрицы, это приводит к пересчету 
  многих других элементов. Пока один поток занят пересчетом элементов в фоновом 
  режиме, другой может позволить пользователю в это время вносить дальнейшие изменения. 
  А третий поток может периодически сохранять резервную копию файла на диске.<BR>
</p>
<p>Теперь давайте рассмотрим еще одну ситуацию, в которой необходимы потоки: 
  сервер web-сайта. На сервер приходят запросы, и клиенту отсылается содержимое 
  запрашиваемых web-страниц. У большинства web-сайтов некоторые страницы существенно 
  более посещаемы, чем другие. Например, главная страница компании Sony посещается 
  гораздо чаще, чем страница с техническими спецификациями конкретных моделей 
  записывающих видеокамер. Для повышения эффективности работы сервер использует 
  эту особенность, храня содержимое особо популярных страниц в основной памяти 
  (чтобы не надо было каждый раз обращаться за ними на диск). Этот раздел памяти 
  называется кэш, и он используется также во многих других ситуациях.<BR>
</p>
<p>На рис. 2.7 представлен один из способов организации web-сервера. Один поток, 
  называемый диспетчером, считывает приходящие по сети запросы. После этого он 
  находит свободный (то есть блокированный) рабочий поток и передает ему запрос, 
  скажем, записывая указатель сообщения в специальное слово, связанное с каждым 
  потоком. Затем диспетчер активизирует ждущий поток, переводя его из состояния 
  блокировки в состояние готовности.<BR>
  <br>
  
</p>
<center>
    <img src="06/Tanenbaum_2_7.jpg" alt="Многопоточный web-сервер"><br>
    <br>
    <font face="Arial"><B>Рис. 2.7.</B> Многопоточный web-сервер</font><BR>
  </center>
  <br>
<p>После активации рабочий поток проверяет возможность удовлетворения запроса 
  в кэше web-страниц, к которому имеют доступ все потоки. В случае отрицательного 
  ответа поток начинает операцию чтения read, чтобы считать страницу с диска, 
  и блокируется до завершения этой операции. Когда рабочий поток блокируется, 
  для запуска выбирается следующий поток, им может оказаться диспетчер или другой 
  готовый рабочий поток.<BR>
</p>
<p>Эта модель позволяет создать сервер в виде набора последовательных потоков. 
  Программа диспетчера состоит из бесконечного цикла, в который входит получение 
  запроса и передача его рабочему потоку. Программа каждого рабочего потока состоит 
  из бесконечного цикла, включающего получение запроса от диспетчера и проверку 
  кэша на наличие запрашиваемой страницы. При наличии страницы в кэше она отсылается 
  клиенту, и рабочий процесс блокируется в ожидании нового запроса. При отсутствии 
  страницы в кэше она считывается с диска, отсылается клиенту, и рабочий процесс 
  блокируется в ожидании нового запроса.<BR>
</p>
<p>Приблизительный набросок программы представлен на рис. 2.8. Здесь и в дальнейшем 
  <i>TRUE </i>предполагается константой, равной 1. Переменные <i>buf </i>и <i>page 
  </i>являются структурами, подходящими соответственно для хранения запроса и 
  web-страницы.<BR>
  
</p>
<center>
    <br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="689" HEIGHT="181">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD width="341" height="179"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="226" HEIGHT="63">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD width="226" height="61"> while(TRUE)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{get next request(&amp;buf);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; handoff work (&amp;buf);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} </TD>
            </TR>
          </TABLE>
          <br>
          <br>
          <br>
          <br>
          <p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
            <i>а</i></p>
        </TD>
        <TD width="357" height="179"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="355" HEIGHT="99">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD width="390" height="97"> while(TRUE)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{wait_for_work(&amp;buf);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; look_for_page_in_cache(&amp;buf,&amp;page);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if(page_not_in_cache(&amp;page))<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
                read_page_from_disk(&amp;buf,&amp;page);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return_page(&amp;page);<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} </TD>
            </TR>
          </TABLE>
          <br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>б</i> 
        </TD>
      </TR>
    </TABLE>
    <br>
    <font face="Arial"><B>Рис. 2.8.</B> Приблизительный набросок программы для 
    рис. 2.7: поток диспетчера (а);<BR>
    рабочий поток (б)</font><BR>
  </center>
  <br>
<p>Теперь рассмотрим, как можно было написать web-сервер в отсутствие потоков. 
  Одна из возможностей — заставить его работать как один поток. Основной цикл 
  получает запрос, проверяет его и удовлетворяет, затем переходит к следующему. 
  Пока web-страница считывается с диска, сервер простаивает и не обрабатывает 
  другие поступающие запросы. Если сервер расположен на выделенном компьютере 
  — а чаще всего именно так и бывает, — процессор простаивает, пока web-страница 
  считывается с диска. В результате в единицу времени однопоточное приложение 
  может обрабатывать существенно меньшее число запросов. Таким образом, использование 
  нескольких потоков дает заметное увеличение производительности, хотя каждый 
  поток программируется последовательно, обычным способом.<BR>
</p>
<p>Итак, мы рассмотрели два возможных варианта: web-сервер с одним потоком и 
  несколькими потоками. Представьте себе, что многопоточная система невозможна, 
  но хочется увеличить эффективность системы с одним потоком. Возможен третий 
  вариант web-сервера в случае существования версии системного запроса read без 
  блокировки. На сервер приходит запрос, его считывает и проверяет единственный 
  поток. Если запрашиваемая web-страница есть в кэше — хорошо, если нет — запускается 
  дисковая операция без блокировки.<BR>
</p>
<p>Сервер записывает в таблицу текущее состояние запроса и переходит к следующему 
  событию. Оно может быть как новым запросом, так и ответом предыдущей операции. 
  В случае нового запроса он начинает обрабатываться, в противном случае соответствующая 
  информация считывается из таблицы и формируется ответ. В случае процедуры ввода-вывода 
  с диска без блокировки ответ может иметь форму сигнала или прерывания.<BR>
</p>
<p>При такой схеме модель &laquo;последовательных процессов&raquo;, которая была 
  справедлива в первых двух ситуациях, не действует. Состояние программы должно 
  явно сохраняться и восстанавливаться в таблице каждый раз, когда сервер переключается 
  между запросами. Фактически мы имитируем потоки и стеки, причем не самым простым 
  способом. Такая модель, в которой каждому расчету соответствует сохраненное 
  состояние и есть несколько событий, которые могут изменить это состояние, называется 
  машиной с конечным числом состояний или конечным автоматом . Эта модель широко 
  используется в программировании.<BR>
</p>
<p>Теперь должно быть ясно, какие преимущества привносят потоки. Они дают возможность 
  сохранить модель последовательных процессов, выполняющих блокирующие системные 
  запросы (например, для ввода-вывода с диска), и тем не менее добиться параллелизма. 
  Системные запросы с блокировкой упрощают программирование, а параллелизм увеличивает 
  производительность. Однопоточный сервер сохраняет простоту программирования, 
  связанную с наличием блокирующих системных запросов, но уступает в производительности. 
  Модель конечного автомата существенно повышает производительность при помощи 
  параллелизма, но использует системные запросы без блокировки, что усложняет 
  программирование. Эти модели представлены в табл. 2.4.<BR>
  
</p>
<center>
    <br>
    <font face="Arial"><B>Таблица 2.4.</B> Три способа конструирования сервера</font><br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="771" HEIGHT="68">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD height="76"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="812" HEIGHT="25">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="253" HEIGHT="22"><B>Модель</B></TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="553" HEIGHT="22"><B>Характеристики</B></TD>
            </TR>
          </TABLE>
          <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="812" HEIGHT="53">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="256" HEIGHT="22">Потоки</TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="556" HEIGHT="22"> Параллелизм, 
                системные запросы с блокировкой</TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="256" HEIGHT="22">Процесс с 
                одним потоком</TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="556" HEIGHT="22"> Нет параллелизма, 
                системные запросы с блокировкой</TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="256" HEIGHT="2"> Конечный автомат</TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="556" HEIGHT="2"> Параллелизм, 
                системные запросы без блокировки, прерывания</TD>
            </TR>
          </TABLE>
        </TD>
      </TR>
    </TABLE>
  </center>
  <br>
<p>Третий пример необходимости потоков — приложения, оперирующие большим количеством 
  данных. Обычно считывается блок данных, обрабатывается и снова записывается. 
  Проблема состоит в том, что при наличии только системных запросов с блокировкой 
  процесс будет блокироваться при чтении и записи данных. Необходимо избегать 
  простоя процессора, особенно при таком большом объеме вычислений.<BR>
</p>
<p>Решение проблемы — в потоках. Процесс можно разбить на входной поток, обрабатывающий 
  поток и выходной поток. Входной поток считывает данные и помещает их во входной 
  буфер. Обрабатывающий поток считывает данные из входного буфера, обрабатывает 
  их и помещает в выходной буфер, а выходной поток считывает их оттуда и записывает 
  обратно на диск. В такой модели считывание данных, обработка и запись происходят 
  одновременно. Разумеется, это возможно лишь в том случае, когда системные вызовы 
  блокируют только вызывающий поток, а не весь процесс.<BR>
  <br>
  <br>
<a NAME="03"></a>
  <B><font size="4">Реализация потоков в пространстве пользователя</font></B><BR>
  <br>
  Есть два основных способа реализации пакета потоков: в пространстве пользователя 
  и ядре. Выбор между ними остается спорным вопросом, и возможна смешанная реализация. 
  Мы рассмотрим оба способа, а также их преимущества и недостатки.<BR>
</p>
<p>Первый метод состоит в размещении пакета потоков целиком в пространстве пользователя. 
  При этом ядро о потоках ничего не знает и управляет обычными, однопоточными 
  процессами. Наиболее очевидное преимущество этой модели состоит в том, что пакет 
  потоков на уровне пользователя можно реализовать даже в операционной системе, 
  не поддерживающей потоки. Все операционные системы когда-то относились к этой 
  категории, а некоторые относятся до сих пор.<BR>
</p>
<p>Подобные реализации имеют в своей основе одинаковую общую схему, представленную 
  на рис. 2.9, <i>а. </i>Потоки работают поверх системы поддержки исполнения программ, 
  которая является набором процедур, управляющих потоками. С четырьмя из них мы 
  уже знакомы: <i>thread_create, thread_exit, thread_wait </i>и <i>thread_yield, 
  </i>но обычно их больше.<BR>
  
</p>
<center>
    <br>
    <img src="06/Tanenbaum_2_8.jpg" alt="Пакеты потоков"><br>
    <br>
    <font face="Arial"><B>Рис. 2.9. </B>Пакет потоков в пространстве пользователя 
    (а);<br>
    пакет потоков, управляемый ядром (б)</font><BR>
  </center>
  <br>
<p>Если управление потоками происходит в пространстве пользователя, каждому процессу 
  необходима собственная таблица потоков для отслеживания потоков в процессе. 
  Эта таблица аналогична таблице процессов, с той лишь разницей, что она отслеживает 
  лишь характеристики потоков, такие как счетчик команд, указатель вершины стека, 
  регистры, состояние и т. п. Когда поток переходит в состояние готовности или 
  блокировки, вся информация, необходимая для повторного запуска, хранится в таблице 
  потоков подобному тому, как в ядре хранится информация о процессах в таблице 
  процессов.<BR>
</p>
<p>Когда поток, ожидая окончания действия другого потока в том же процессе, делает 
  нечто, что может привести к локальной блокировке, он вызывает процедуру системы 
  поддержки исполнения программ. Процедура проверяет необходимость блокирования 
  потока. В этом случае процедура сохраняет регистры потока в таблице потоков, 
  ищет в таблице поток, готовый к запуску, и загружает его сохраненные значения 
  в регистры машины. Как только указатель стека и счетчик команд переключены, 
  работа нового потока возобновляется автоматически. Если у процессора есть команда, 
  позволяющая за одну инструкцию сохранить все регистры, и еще одна, чтобы загрузить 
  их все заново, переключение потоков может быть выполнено с помощью очень небольшого 
  количества инструкций. Такое переключение потоков по крайней мере на порядок 
  быстрее, чем переключения в режим ядра, и является серьезным аргументом в пользу 
  управления потоками в пространстве пользователя.<BR>
</p>
<p>Но существует одно серьезное отличие потоков от процессов. В тот момент, когда 
  поток завершает на время свою работу, например, когда он вызывает процедуру 
  <i>thread_yield, </i>программа <i>thread_yield </i>может сама сохранить информацию 
  о потоке в таблице потоков. Более того, она может после этого вызвать планировщик 
  потоков для выбора следующего потока. Процедура, сохраняющая информацию о потоке, 
  и планировщик являются локальными процедурами, и их вызов существенно более 
  эффективен, чем вызов ядра. Не требуются прерывание, переключение контекста, 
  сохранение кэша и т. п., что существенно ускоряет переключение потоков.<BR>
</p>
<p>Потоки, реализованные на уровне пользователя, имеют и другие преимущества. 
  Они позволяют каждому процессу иметь собственный алгоритм планирования. Для 
  некоторых приложений, например приложений с потоком &laquo;сборки мусора&raquo;, 
  оказывается удобным не задумываться о том, что поток может остановиться в неподходящий 
  момент. Эти приложения также лучше масштабируются, поскольку потоки ядра неизменно 
  занимают некоторое пространство в таблице и стековое пространство в ядре, что 
  может стать проблемой в случае большого числа потоков.<BR>
</p>
<p>Несмотря на более высокую производительность, с реализацией потоков на уровне 
  пользователя связаны и некоторые серьезные проблемы. Первой из них является 
  проблема реализации блокирующих системных запросов. Представьте, что поток начинает 
  считывание с клавиатуры до того, как была нажата хотя бы одна клавиша. Было 
  бы неприемлемо позволить потоку выполнить системный запрос, поскольку это остановило 
  бы все потоки. Одной из основных целей использования потоков было предоставление 
  возможности каждому потоку использовать блокирующие запросы, но так, чтобы один 
  блокированный поток не мешал остальным. Не очень понятно, как достичь этой цели, 
  если использовать блокирующие системные запросы.<BR>
</p>
<p>Можно сделать все системные запросы не блокирующими (как, например, запрос 
  на чтение с клавиатуры read, который возвращал бы 0 байт в случае отсутствия 
  данных), но это потребует неприемлемых изменений операционной системы. Вспомните, 
  ведь одним из основных аргументов в пользу потоков на уровне пользователя была 
  возможность работы в существующих операционных системах. К тому же изменение 
  семантики запроса read повлекло бы за собой изменения во многих пользовательских 
  программах.<BR>
</p>
<p>Оказалось, что существует альтернатива, если имеется возможность узнавать 
  заранее, последует ли за запросом блокировка. В некоторых версиях UNIX есть 
  системный запрос <B>select</B>, позволяющий узнать о наличии или отсутствии 
  блокировки у последующего запроса <B>read</B>. При наличии такого системного 
  запроса библиотечную процедуру <B><I>read</I></B><i> </i>можно заменить новой, 
  сначала выполняющей запрос <B>select</B>, а потом запрос <B>read</B>, если за 
  ним не последует блокировки. Если блокировка должна произойти, то запрос не 
  выполняется и запускается другой поток. <i>В </i>следующий момент, когда система 
  поддержки исполнения программ получит управление, она может проверить еще раз, 
  последует ли за запросом <B>read</B> блокировка. Такой подход требует перезаписи 
  части библиотеки системных запросов, неэффективен и не отличается изяществом, 
  но выбор не так уж велик. Код, который помещается вокруг системного запроса 
  для проверки на блокировку, называется чехлом (jacket) или упаковкой (wrapper).<BR>
</p>
<p>Схожей проблемой является ошибка из-за отсутствия страницы. Мы рассмотрим 
  ее подробнее в главе 4. На данный момент нам важно, что компьютер можно настроить 
  так, чтобы не вся программа находилась в основной памяти. Если программа производит 
  вызов или переход к той инструкции, которой нет в памяти, возникает ошибка из-за 
  отсутствия страницы, и операционная система берет недостающую часть программы 
  с диска. Именно эта ситуация называется ошибкой из-за отсутствия страницы. Процесс 
  блокируется, пока необходимая инструкция не будет найдена и считана. Если поток 
  приводит к ошибке из-за отсутствия страницы, ядро, не знающее о существовании 
  потоков, блокирует весь процесс целиком, до завершения операции чтения с диска, 
  несмотря на наличие остальных нормально функционирующих потоков.<BR>
</p>
<p>Еще одной проблемой потоков на уровне пользователя является тот факт, что 
  при запуске одного потока ни один другой поток не будет запущен, пока первый 
  поток добровольно не отдаст процессор. Внутри одного процесса нет прерываний 
  по таймеру, в результате чего невозможно создать планировщик для поочередного 
  выполнения потоков. Планировщик ничего не сможет сделать, пока поток не окажется 
  в системе поддержки исполнения программ по собственному желанию.<BR>
</p>
<p>Одним из решений этой проблемы может стать ежесекундное прерывание, передающее 
  управление системе поддержки исполнения программ, но этот способ достаточно 
  груб и неудобен. Периодические прерывания по таймеру с более высокой частотой 
  не всегда возможны, а если и возможны, то издержки все равно будут существенными. 
  Более того, возможно, что потоку необходимы свои прерывания по таймеру, которые 
  будут конфликтовать с прерываниями системы поддержки исполнения программ.<BR>
</p>
<p>Еще один, и, возможно, наиболее серьезный аргумент против использования потоков 
  на уровне пользователя состоит в том, что программисты хотят использовать потоки 
  именно в тех приложениях, в которых потоки часто блокируются, например в многопоточном 
  web-сервере. Эти потоки все время посылают системные запросы. И ядру, перехватившему 
  управление, чтобы выполнить системный запрос, не составит труда заодно переключить 
  потоки, если один из них блокирован. При этом исключается необходимость постоянных 
  обращений к системе с запросом select для проверки наличия или отсутствия блокировки 
  у последующего запроса read. А для приложений, которые полностью ограничены 
  возможностями процессора и редко блокируются, потоки вообще не нужны. Вряд ли 
  кто-либо станет всерьез применять потоки для вычисления первых <i>п </i>простых 
  чисел или игры в шахматы.<BR>
  <br>
  <br>
<a NAME="04"></a>
  <B><font size="4">Реализация потоков в ядре</font></B><BR>
  <br>
  Теперь рассмотрим ситуацию, в которой ядро знает о существовании потоков и управляет 
  ими. В этом случае система поддержки исполнения программ не нужна, как показано 
  на рис. 2.9, <i>б. </i>Нет необходимости и в наличии таблицы потоков в каждом 
  процессе, вместо этого есть единая таблица потоков, отслеживающая все потоки 
  системы. Если потоку необходимо создать новый поток или завершить имеющийся, 
  он выполняет запрос ядра, который создает или завершает поток, внося изменения 
  в таблицу потоков.<BR>
</p>
<p>Таблица потоков, находящаяся в ядре, содержит регистры, состояние и другую 
  информацию о каждом потоке. Информация та же, что и в случае управления потоками 
  на уровне пользователя, только теперь она располагается не в пространстве пользователя 
  (внутри системы поддержки исполнения программ), а в ядре. Эта информация является 
  подмножеством информации, которую традиционное ядро хранит о каждом из своих 
  однопоточных процессов (то есть подмножеством состояния процесса). Дополнительно 
  ядро содержит обычную таблицу процессов, отслеживающую все процессы системы.<BR>
</p>
<p>Все запросы, которые могут блокировать поток, реализуются как системные запросы, 
  что требует значительно больших временных затрат, чем вызов процедуры системы 
  поддержки исполнения программ. Когда поток блокируется, ядро по желанию запускает 
  другой поток из этого же процесса (если есть поток в состоянии готовности) либо 
  поток из другого процесса. При управлении потоками на уровне пользователя система 
  поддержки исполнения программ запускает потоки из одного процесса, пока ядро 
  не передает процессор другому процессу (или пока не кончаются потоки, находящиеся 
  в состоянии готовности).<BR>
</p>
<p>Поскольку создание и завершение потоков в ядре требует относительно больших 
  расходов, некоторые системы используют повторное использование потоков. После 
  завершения поток помечается как нефункционирующий, но в остальном его структура 
  данных, хранящаяся в ядре, не затрагивается. Позже, когда нужно создать новый 
  поток, реактивируется отключенный поток, что позволяет сэкономить на некоторых 
  накладных расходах. При управлении потоками на уровне пользователя повторное 
  использование потоков тоже возможно, но поскольку накладных расходов, связанных 
  с управлением потоками, в этом случае существенно меньше, то и смысла в этом 
  меньше.<BR>
</p>
<p>Управление потоками в ядре не требует новых не блокирующих системных запросов. 
  Более того, если один поток вызвал ошибку из-за отсутствия страницы, ядро легко 
  может проверить, есть ли в этом процессе потоки в состоянии готовности, и запустить 
  один из них, пока требуемая страница считывается с диска. Основным недостатком 
  управления потоками в ядре является существенная цена системных запросов, поэтому 
  постоянные операции с потоками (создание, завершение и т. п.) приведут к увеличению 
  накладных расходов.<BR>
  <br>
  <br>
<a NAME="05"></a>
  <B><font size="4">Смешанная реализация</font></B><BR>
  <br>
  С целью совмещения преимуществ реализации потоков на уровне ядра и на уровне 
  пользователя были опробованы многие способы смешанной реализации. Один из методов 
  заключается в использовании управления ядром и последующем мультиплексировании 
  потоков на уровне пользователя, как показано на рис. 2.10.<BR>
  
</p>
<center>
    <br>
    <img src="06/Tanenbaum_2_9.jpg" alt="Мультиплексирование потоков пользователя 
в потоках ядра"><br>
    <br>
    <font face="Arial"><B>Рис. 2.10.</B> Мультиплексирование потоков пользователя 
    в потоках ядра</font><BR>
  </center>
  <br>
<p>В такой модели ядро знает только о потоках своего уровня и управляет ими. 
  Некоторые из этих потоков могут содержать по нескольку потоков пользовательского 
  уровня, мультиплексированных поверх них. Потоки пользовательского уровня создаются, 
  завершаются и управляются так же, как потоки уровня пользователя в процессе, 
  запущенном в не поддерживающей многопоточность системе. Предполагается, что 
  у каждого потока ядра есть набор потоков на уровне пользователя, которые используют 
  его по очереди.<BR>
  <br>
  <br>
<a NAME="06"></a>
  <B><font size="4">Активация планировщика</font></B><BR>
  <br>
  Многие исследователи старались совместить преимущества реализации потоков на 
  уровне ядра (простота реализации) и реализации потоков на уровне пользователя 
  (высокая производительность). Ниже мы рассмотрим один из таких подходов, разработанный 
  Андерсоном [12], который называется <B>активацией планировщика. </B>Соответствующие 
  разработки описаны в [104, 296].<BR>
</p>
<p>Целью активации планировщика является имитация функциональности потоков ядра, 
  но с большей производительностью и гибкостью, свойственной потокам уровня пользователя. 
  В частности, пользовательские потоки не должны выполнять специальные системные 
  запросы без блокировки или заранее должны проверять, не вызовет ли запрос блокировку. 
  Тем не менее, когда поток блокируется системным запросом или ошибкой из-за отсутствия 
  страницы, должна оставаться возможность запустить другой поток этого же процесса 
  (если такой есть и находится в состоянии готовности).<BR>
</p>
<p>Увеличение эффективности достигается за счет уменьшения количества ненужных 
  переходов между пространством пользователя и ядром. Например, если поток блокирован 
  в ожидании действий другого потока, совершенно не обязательно обращаться к ядру, 
  что позволяет избежать накладных расходов по переходу &laquo;пользователь — 
  ядро&raquo;. Система поддержки исполнения программ, работающая в пространстве 
  пользователя, может блокировать синхронизирующий поток и самостоятельно выбрать 
  другой.<BR>
</p>
<p>При использовании активации планировщика ядро назначает каждому процессу некоторое 
  количество виртуальных процессоров и позволяет системе поддержки исполнения 
  программ (в пространстве пользователя) распределять потоки по процессорам. Этот 
  метод можно использовать и в мультипроцессорной системе, заменяя виртуальные 
  процессоры реальными. Исходное число виртуальных процессоров, соответствующих 
  одному процессу, равно единице, но процесс может запросить больше процессоров 
  и позже вернуть их. Ядро также может забрать виртуальный процессор у одного 
  процесса и отдать другому, более нуждающемуся в нем в данный момент.<BR>
</p>
<p>В основе механизма работы этой схемы лежит следующее утверждение. Если ядро 
  знает, что поток блокирован (например, если он выполнил блокирующий системный 
  запрос или вызвал ошибку из-за отсутствия страницы), ядро оповещает об этом 
  систему поддержки исполнения программ процесса, пересылая через стек в качестве 
  параметров номер потока в запросе и описание случившегося. Оповещение происходит 
  при помощи активации ядром в определенном начальном адресе системы поддержки 
  исполнения программ, что приблизительно аналогично сигналу в UNIX. Этот метод 
  называется <B>upcall </B>(&laquo;вызов вверх&raquo;, также иногда именуемый 
  обратным вызовом — callback — в противоположность обычным вызовам, производящимся 
  из верхних уровней в нижние).<BR>
</p>
<p>Активизированная таким образом система поддержки исполнения программ перепланирует 
  свои потоки, обычно помечая текущий поток как блокированный, выбирая следующий 
  поток из списка, устанавливая значения его регистров и запуская его. Позже, 
  когда ядро получает информацию о том, что поток снова готов к работе (например, 
  канал, из которого он пытался считывать данные, теперь их содержит, или недостающая 
  страница считана с диска), оно выполняет еще один обратный вызов, информируя 
  об этом систему поддержки исполнения программ. Система поддержки исполнения 
  программ по своему усмотрению запускает блокированный поток тут же или помещает 
  его в список готовых процессов, чтобы запустить позже.<BR>
</p>
<p>При возникновении аппаратного прерывания во время работы потока пользователя 
  процессор переключается в режим ядра. Если прерывание вызвано событием, не имеющим 
  отношения к прерванному процессу, например завершением операции ввода-вывода 
  другого процесса, по завершении работы обработчика прерываний прерванный поток 
  возвращается в состояние, в котором он находился до прерывания. Если же процесс 
  заинтересован в прерывании (например, вызванном поступлением страницы, которую 
  ждал один из потоков процесса), прерванный поток не запускается вновь. Вместо 
  этого прерванный поток приостанавливается, и на этом виртуальном процессоре 
  запускается система поддержки исполнения программ с состоянием прерванного потока 
  на стеке. Дальнейшее зависит от системы поддержки исполнения программ, решающей, 
  запустить ли на этом процессоре прерванный поток, другой, находящийся в состоянии 
  готовности, или какой-либо третий.<BR>
</p>
<p>Недостатком метода активации планировщика является существенная зависимость 
  от обратных вызовов, концепция, нарушающая свойственную любой многоуровневой 
  системе структуру. Обычно уровень <i>п + </i>1 может вызывать процедуры уровня 
  <i>п, </i>но не наоборот. Обратные вызовы противоречат этому фундаментальному 
  принципу.<BR>
  <br>
  <br>
<a NAME="07"></a>
  <B><font size="4">Всплывающие потоки</font></B><BR>
  <br>
  Потоки часто используются в распределенных системах. Важным примером может служить 
  обработка входящих сообщений, например запросов на обслуживание. Традиционный 
  подход заключается в наличии процесса или потока, который блокируется по системному 
  запросу recieve, ожидая входящего сообщения. Когда сообщение прибывает, оно 
  принимается и обрабатывается.<BR>
</p>
<p>Возможен и принципиально другой подход, при котором по прибытии сообщения 
  система создает новый поток для его обработки. Такой поток называется <B>всплывающим, 
  </B>его схема проиллюстрирована на рис. 2.11. Основным преимуществом всплывающих 
  потоков является их &laquo;свежесть&raquo; — у такого потока нет истории: регистров, 
  стека и прочей информации, которую нужно восстанавливать. Всплывающие потоки 
  абсолютно &laquo;стерильны&raquo; и идентичны, что позволяет создавать их быстро. 
  Новый поток обрабатывает входящее сообщение. Использование всплывающих потоков 
  позволяет значительно сократить промежуток времени между прибытием сообщения 
  и началом его обработки.<BR>
  
</p>
<center>
    <br>
    <img src="06/Tanenbaum_2_10.jpg" alt="Создание нового потока"><br>
    <br>
    <font face="Arial"><B>Рис. 2.11.</B> Создание нового потока по прибытии сообщения: 
    до прибытия сообщения (а);<BR>
    после прибытия сообщения (б)</font><BR>
  </center>
  <br>
<p>При использовании всплывающих потоков необходимо предварительное планирование. 
  Например, в каком процессе возникнет новый поток? Если система поддерживает 
  потоки, работающие в контексте ядра, новый поток может возникнуть там (именно 
  поэтому мы не показали ядро на рис. 2.11). Создание всплывающих потоков в пространстве 
  ядра всегда быстрее и проще, чем в пространстве пользователя. К тому же всплывающему 
  потоку в пространстве ядра проще получить доступ ко всем таблицам ядра и устройств 
  ввода-вывода, что может оказаться полезным при обработке прерываний. С другой 
  стороны, наличие ошибок в потоке, расположенном в пространстве ядра, может нанести 
  существенно больший ущерб. Например, если поток работает слишком долго и невозможно 
  воспользоваться приоритетным прерыванием, это может привести к потере входных 
  данных.<BR>
  <br>
  <br>
<a NAME="08"></a>
  <B><font size="4">Как сделать однопоточную программу многопоточной</font></B><BR>
  <br>
  Многие из существующих программ были написаны для однопоточных процессов. Сделать 
  их многопоточными гораздо сложнее, чем это может показаться на первый взгляд. 
  Ниже мы рассмотрим некоторые из возможных трудностей.<BR>
</p>
<p>Прежде всего, программа потока обычно состоит из нескольких процедур, так 
  же как и процесс. У этих процедур могут быть локальные переменные, глобальные 
  переменные и параметры. Проблем с локальными переменными и параметрами не будет, 
  зато проблемы будут с переменными, которые являются глобальными для потока, 
  но не глобальными для всей программы. Эти переменные являются глобальными с 
  точки зрения процедур одного потока (которые ими пользуются, как пользовались 
  бы любыми другими глобальными переменными), но не имеют никакого отношения к 
  другим потокам.<BR>
</p>
<p>В качестве примера рассмотрим переменную <i>errno</i> в UNIX. Если процесс 
  (или поток) выполняет неудачный системный запрос, код ошибки записывается в 
  <i>errno.</i> На рис. 2.12 поток 1 выполняет системный запрос access, чтобы 
  узнать, имеет ли он разрешение на доступ к конкретному файлу. Операционная система 
  возвращает ответ в глобальной переменной <i>errno.</i> После этого управление 
  возвращается к потоку 1. Однако прежде, чем у него появляется возможность считать 
  значение <i>errno,</i> планировщик решает, что поток 1 уже достаточно попользовался 
  процессором и пора переключиться на поток 2. Поток 2 выполняет запрос open, 
  завершающийся неудачей, в результате чего значение <i>errno</i> изменяется и 
  предыдущее значение теряется. После того как поток 1 вновь получит управление, 
  он прочитает неверное значение <i>errno,</i> и дальнейшие его действия будут 
  неправильными.<BR>
</p>
<p>Существует несколько различных решений проблемы. Одно из решений — запретить 
  глобальные переменные вообще. Какой бы заманчивой ни была эта идея, она вступит 
  в противоречие с большей частью существующего программного обеспечения. Другое 
  решение — предоставить каждому потоку собственные глобальные переменные, как 
  показано на рис. 2.13. В этом случае конфликт исключается, поскольку у каждого 
  потока будет своя копия <i>errno</i> и остальных глобальных переменных. Это 
  решение фактически приводит к появлению новых уровней видимости переменных: 
  переменные, доступные всем процедурам потока (в дополнение к уже имеющимся уровням 
  видимости переменных, доступных только одной процедуре), и переменные, доступные 
  всей программе.<BR>
  
</p>
<center>
    <br>
    <img src="06/Tanenbaum_2_11.jpg" alt="Конфликт между потоками при использовании глобальной переменной"><br>
    <br>
    <font face="Arial"><B>Рис. 2.12.</B> Конфликт между потоками при использовании 
    глобальной переменной</font><BR>
    <br>
    <img src="06/Tanenbaum_2_12.jpg" alt="У потоков могут быть собственные глобальные переменные"><br>
    <br>
    <font face="Arial"><B>Рис. 2.13.</B> У потоков могут быть собственные глобальные 
    переменные</font><BR>
  </center>
  <br>
<p>Обеспечить доступ к собственным глобальным переменным не очень просто, поскольку 
  в большинстве языков программирования есть способы описания локальных и глобальных 
  переменных, но не промежуточных разновидностей. Можно отвести под глобальные 
  переменные отдельный участок памяти и рассматривать их как дополнительные параметры 
  процедур. Несмотря на некоторую неуклюжесть, этот метод работает.<BR>
</p>
<p>В качестве альтернативы можно написать новые библиотечные процедуры, которые 
  будут создавать, записывать и считывать переменные, глобальные для потока. Первый 
  запрос будет выглядеть примерно так:<BR>
  <br>
  <font face="Arial">create_global(&quot;bufptr&quot;);</font><BR>
  <br>
  Этот запрос отводит участок памяти под указатель, называющийся <i>bufptr,</i> 
  в динамической памяти или в отдельном участке памяти, зарезервированном для 
  вызывающего потока. Не имеет значения, где именно расположен этот участок памяти, 
  важно, что лишь вызывающий поток имеет к нему доступ. Если другой поток создаст 
  глобальную переменную с таким же именем, она будет размещаться в другом участке 
  памяти и конфликта потоков не будет.<BR>
</p>
<p>Для доступа к глобальной переменной нужно два запроса: один, чтобы записать 
  ее значение, и другой — чтобы его считать. Для записи будет использоваться что-то 
  вроде<BR>
  <br>
  <font face="Arial">set_global(&quot;bufptr&quot;,&amp;buf);</font><BR>
  <br>
</p>
<p>Этот запрос сохраняет значение указателя в участке памяти, созданном запросом 
  <i>create_global.</i> Запрос на чтение может выглядеть как<BR>
  <br>
  <font face="Arial">bufptr=read_global(&quot;bufptr&quot;);</font><BR>
  <br>
</p>
<p>Запрос возвращает адрес для доступа к данным, хранящийся в глобальной переменной.<BR>
  Другим препятствием может стать тот факт, что большинство библиотечных процедур 
  не являются реентерабельными. Это означает, что при их написании не предполагалась 
  ситуация, при которой процедуре будет необходимо ответить на второй запрос, 
  не закончив ответа на первый. Например, пересылку сообщения по сети можно организовать 
  следующим образом: сообщение помещается в буфер, затем эмулируется прерывание 
  в ядро для его отсылки. Что произойдет, если один поток поместит сообщение в 
  буфер, а затем прерывание по таймеру приведет к передаче управления второму 
  потоку, который тут же поместит в этот буфер свое сообщение?<BR>
</p>
<p>Подобная же проблема возникает с процедурами распределения памяти <i>(malloc</i> 
  в UNIX), управляющими таблицами использования памяти (в виде связного списка 
  доступных участков памяти). Пока процедура <i>malloc</i> занята переписыванием 
  таблиц, таблицы могут временно находиться в несовместимом состоянии, с указателями, 
  никуда не указывающими. Если в этот момент произойдет переключение потоков и 
  от нового потока придет запрос, может быть использован неправильный указатель, 
  что приведет к нарушению работы программы. Решение всех подобных проблем равнозначно 
  полному переписыванию библиотеки.<BR>
</p>
<p>Другим решением может быть снабжение каждой процедуры чехлом (jacket), устанавливающим 
  бит, означающий, что эта процедура используется. Любая попытка использования 
  процедуры другим потоком до окончания выполнения предыдущего запроса блокируется. 
  Этот метод можно использовать, но он практически исключает параллелизм.<BR>
</p>
<p>Теперь рассмотрим сигналы. Одни из них связаны с потоками, тогда как другие 
  — нет. Например, если поток выполняет запрос alarm, результирующий сигнал по 
  логике должен вернуться к этому потоку. Однако если потоки реализованы в пространстве 
  пользователя, ядро ничего не знает об их существовании и вряд ли направит сигнал 
  к правильному потоку. Ситуация еще больше усложняется, если одновременно у процесса 
  может быть только один необработанный аварийный сигнал, а несколько потоков 
  выполняют запрос alarm независимо друг от друга.<BR>
</p>
<p>Другие сигналы, такие как прерывание с клавиатуры, не связаны с потоками. 
  Кто должен их перехватывать? Один назначенный поток? Все потоки? Специально 
  созданный всплывающий поток? Что случится, если один поток изменит обработчик 
  сигнала, не сообщив об этом остальным потокам? А что если один поток хочет перехватить 
  определенный сигнал (например, CTRL+C с клавиатуры), а другому потоку этот сигнал 
  нужен, чтобы прервать процесс? Подобная ситуация может возникнуть, если один 
  или более потоков пользуются стандартными библиотечными процедурами, а остальные 
  — процедурами, написанными пользователем. Эти потоки абсолютно несовместимы. 
  Вообще говоря, управлять сигналами даже в од-нопоточной среде достаточно сложно. 
  При переходе к многопоточному окружению обработка сигналов проще не становится.<BR>
</p>
<p>Последняя проблема, связанная с потоками, — управление стеками. Во многих 
  системах при переполнении стека процесса ядро автоматически увеличивает его. 
  Если у процесса несколько потоков, стеков тоже должно быть несколько. Если ядро 
  не знает о существовании этих стеков, оно не может их автоматически увеличивать 
  при переполнении. Ядро может даже не связать ошибки памяти с переполнением стеков.<BR>
</p>
<p>Разумеется, эти проблемы не являются непреодолимыми, но на их примере хорошо 
  видно, что введение потоков в существующую систему невозможно без тщательной 
  и продуманной реконструкции всей системы. По крайней мере, придется изменить 
  семантику системных запросов и переписать библиотеки. И результат ваших трудов 
  должен быть совместим с существующими программами для процессов с одним потоком. 
  Дополнительную информацию о потоках можно найти в [149, 225].<BR>
  <br>
</p>
</BODY>
</HTML>
