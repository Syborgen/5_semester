<html>
<head>
<title>ПРОГРАММИРОВАНИЕ НА shell (UNIX)</title>
</head>


<body>
<h1 align="center">Среда SHELL (Переменные и параметры)</h1>

<p>     На  языке  shell  можно  писать  командные файлы и с помощью
команды &quot;chmod&quot; делать их выполняемыми. После этого они ни чем не
отличаются от прочих команд ОС UNIX.


<h3>shell-переменные</h3>
<p>     Имя    shell-переменной   -   это   начинающаяся   с   буквы
последовательность букв, цифр и подчеркиваний.
<p>     Значение  shell-переменной  -  строка символов.
<p>     То,  что  в  shell  всего два типа данных: строка символов и
текстовый  файл,  с  одной  стророны, позволяет легко вовлекать в
программирование    конечных    пользователей,    никогда   ранее
программированием  не  занимавшихся, а с другой стороны, вызывает
некий  внутренний  протест  у  многих  программистов, привыкших к
существенно  большему  разнообразию  и  большей гибкости языковых
средств.
<p>     Однако    интересно   наблюдать   то,   как   высококлассные
программисты,  освоившись  с &quot;правилами игры&quot; shell, пишут на нем
программы  во  много  раз  быстрее,  чем  на Си, но, что особенно
интересно,  в  ряде  случаев эти программы работают даже быстрее,
чем реализованные на Си. (Но это уже случаи &quot;высшего пилотажа&quot;).

<p>     Имя  переменной  аналогично  традиционному  представлению об
идентификаторе,  т.е.  именем может быть последовательность букв,
цифр и подчеркиваний, начинающаяся с буквы или подчеркивания.
<p>     Для  присваивания  значений  переменным может использоваться
оператор присваивания &quot;=&quot;.

<p>     var_1=13 - &quot;13&quot; - это не число, а строка из двух цифр.
<p>     var_2=&quot;ОС UNIX&quot; - здесь двойные кавычки (&quot; &quot;) необходимы,
		       так как в строке есть пробел.

<p>     ВАЖНО: Обратим внимание на то, что, как переменная, так и ее
значение  должны  быть записаны без пробелов относительно символа
&quot;=&quot;.  Кстати,  как  видно  из примеров, первым словом в командной
строке  может  стоять  не  только  имя команды, но и присваивание
значения  переменной.  Об  этом  как  раз  и  говорит  наличие  в
беспробельной   строке   символов  наличие  (незаэкранированного)
символа &quot;=&quot;.
<p>     Возможны    и    иные    способы    присваивания    значений
shell-переменным. Так например запись,

<p>     DAT=`date`

<p>     приводит  к  тому,  что  сначала  выполняется команда &quot;date&quot;
(обратные   кавычки  говорят  о  том,  что  сначала  должна  быть
выполнена  заключенная в них команда), а результат ее выполнения,
вместо  выдачи  на  стандартный  выход,  приписывается в качестве
значения переменной, в данном случае &quot;DAT&quot;.
<p>     Можно  присвоить  значение  переменной  и  с помощью команды
&quot;read&quot;,   которая   обеспечивает   прием  значения  переменной  с
(клавиатуры) дисплея в диалоговом режиме. Обычно команде &quot;read&quot; в
командном  файле  предшествует  команда &quot;echo&quot;, которая позволяет
предварительно выдать какое-то сообщение на экран. Например:

<p>     echo -n &quot;Введите трехзначное число:&quot;
<p>     read x

<p>     При  выполнении  этого  фрагмента  командного  файла,  после
вывода на экран сообщения

<p>     Введите трехзначное число:

<p>     интерпретатор  остановится  и  будет  ждать ввода значения с
клавиатуры.  Если  вы  ввели,  скажем,  &quot;753&quot;  то  это  и  станет
значением переменной &quot;x&quot;.
<p>     Одна  команда  &quot;read&quot;  может  прочитать (присвоить) значения
сразу для нескольких переменных. Если переменных в &quot;read&quot; больше,
чем  их  введено (через пробелы), оставшимся присваивается пустая
строка.  Если  передаваемх  значений  больше,  чем  переменных  в
команде &quot;read&quot;, то лишние игнорируются.

<p>     ПРЕДУПРЕЖДЕНИЕ.  На самом деле интерпретатор для продолжения
работы  ждет  лишь  нажатия клавиши <Enter>. Введенное вами число
воспринимается   им   не  как  число,  а  как  последовательность
символов(!).  Интерпретор  не  проверяет, что вы ввели. Поэтому в
качестве  значения  переменной  может  оказаться  любая введенная
абракадабра  или  просто  нажатие  <Enter>,  как  значение пустой
строки.  (Для обеспечения проверки формата ввода следует написать
свою команду).

<p>     При  обращении  к  shell-переменной  необходимо перед именем
ставить символ &quot;$&quot;. Так команды

<p>     echo $var_2
<p>     echo var_2

<p>выдадут на экран

<p>     ОС UNIX
<p>     var_2

<p>     И еще один пример. Фрагмент командного файла:

<p>     echo &quot;var_2 = $var_2&quot;

<p>выдаст на экран

<p>     var_2 = ОС UNIX

<p>     В  команде  &quot;echo&quot; первое использование &quot;var_2&quot; - это просто
текст,   а  второе  (&quot;$var_2&quot;)  -  это  значение  соответствующей
переменной.
<p>     То  что здесь присутствуют пробелы между именем переменной и
символом  присваивания,  а  также  между  символом присваивания и
значением,  так  это  потому,  что  здесь  мы  имеем  дело лишь с
текстом,   куда   подставлены   значения   переменных.  Там,  где
действительно  выполняется  присваивание,  пробелы  в этих местах
НЕДОПУСТИМЫ.   Присваивание,  скажем,  w=  означает  присваивание
переменной   &quot;w&quot;   пустой   строки.  Но  и  пустую  строку  лучше
присваивать аккуратно, например w=&quot;&quot;.

<p>     Для  того,  чтобы  имя  переменной  не сливалось со строкой,
следующей за именем переменной, используются фигурные скобки.
<p>     Пусть  a=/mnt/lab/asu/

<p>тогда

<p>     cat /mnt/lab/asu/prim

<p>и

<p>     cat ${a}prim

<p>     равноценны  (т.е.  &quot;cat&quot; выдаст на экран содержимое одного и
того же файла).
<p>     Если  также  предположить,  что  в  системе  есть переменная
&quot;prim&quot; и &quot;prim=dir&quot; , то команда

<p>     echo ${a}$prim

<p>выдаст на экран

<p>     /mnt/lab/asu/dir


<h3>Экранирование</h3>

<p>     Рассмотрим более подробно приемы экранирования, используемые
в  shell.  В  качестве средств экранирования используются двойные
кавычки (&quot; &quot;), одинарные кавычки (' ') и бэк-слэш (\).
<p>     Из примеров очевидно их действие:
<p>     Можно  в  одной  строке  записывать  несколько приcваиваний.

<p>     x=22 y=33 z=$x
<p>     A=&quot;$x&quot; B='$x' C=\$x
<p>     D=&quot;$x + $y + $z&quot;  E='$x + $y + $z'  F=$x\ +\ $y\ +\ $z

<p>     (присваивание G=$x + $y не было бы выполнено из-за пробелов)

<p>     Тогда

<p>     echo A = $A   B = $B   C = $C
<p>     echo D = $D   E = $E   F = $F
<p>     eval echo evaluated A = $A
<p>     eval echo evaluated B = $B
<p>       eval echo evaluated C = $C

<p>     Выдадут на экран

<p>     A = 22 B = $x C = $x
<p>     D = 22 + 33 + 22 E = $x + $y + $z F = 22 + 33 + 22
<p>     evaluated A = 22
<p>     evaluated B = 22
<p>     evaluated C = 22

<p>     ВНИМАНИЕ. В трех последних случаях использована своеобразная
команда   &quot;eval&quot;   (от   evaluate   -   означивать),   которая  в
подставленной  в  нее  (в качестве  аргумента) команде  выполняет
означивание  переменных  (если  таковые  имеются).  В  результате
значение &quot;A&quot; остается прежним, поскольку &quot;A&quot; имеет значение &quot;22&quot;.
А  переменные &quot;B&quot; и &quot;C&quot; имеют значение &quot;$x&quot;. За счет означивания,
которое было выполнено командой &quot;eval&quot; - evaluated &quot;B&quot; и &quot;C&quot; дают
значения &quot;22&quot;.
<p>     Еще один пример на &quot;eval&quot;.
<p>     Пусть

   <p>  w=\$v v=\$u u=5

<p>     В результате выполнения команд

<p>	       echo $w
<p>	  eval echo $w
<p>     eval eval echo $w

<p>     на экран будет выведено

<p>     $v
<p>     $u
<p>     5

<p>     Приведем  еще  примеры,  связанные с экранированием перевода
строки.  Пусть  переменной  &quot;string&quot; присвоено значение &quot;массива&quot;
2x3:

<p>abc
<p>def

<p>     Обатим  внимание,  что  для  избежания  присваивания  лишних
пробелов  вторая строка массива начата с первой позиции следующей
строки:

<p>string=&quot;abc
<p>def&quot;

<p>Тогда три варианта записи переменной в команде &quot;echo&quot;

<p>echo  $string
<p>echo '$string'
<p>echo &quot;$string&quot;

<p>дадут соответсвенно три различных результата:

<p>abc def

<p>$string

<p>abc
<p>def

<p>а последовательность команд

<p>echo &quot;строка первая
<p>строка вторая&quot; &gt; f1

<p>echo 'строка первая
<p>строка вторая' &gt; f2

<p>cat f1 f2

<p>даст выдаст последовательно одинаковые файлы f1 и f2:

<p>строка первая
<p>строка вторая
<p>строка первая
<p>строка вторая

<p>     Заметим   также,  что  бэк-слэш  (\)  не  только  экранирует
следующий  за  ним символ, что позволяет использовать специальные
символы  просто  как  символы, представляющие сами себя (он может
экранировать  и  сам  себя  -  \\), но в командном файле бэк-слэш
позволяет об'единять строки в одну (экранировать конец строки).
<p>    Например, приводившийся ранее пример командной строки:

<p>     cat f1 | grep -h result | sort | cat -b &gt; f2

<p>может быть записан в командном файле, скажем, как

<p>     cat f1 | grep -h  \
<p>     result | sort | cat -b &gt; f2

<p>     Кстати,  эффект  продолжения командной строки обеспечивает и
символ   конвейера.   В   данном  случае  это  может  дать  более
симпатичный результат, например:

<p>     cat f1         |
<p>     grep -h result |
<p>     sort           |
<p>     cat -b &gt; f2


<h3>Манипуляции с shell-переменными</h3>

<p>     Несмотря   на   то,  что  shell-переменные  в  общем  случае
воспринимаются  как  строки, т.е &quot;35&quot; - это не число, а строка из
двух   символов   &quot;3&quot;   и   &quot;5&quot;,   в   раде   случаев  они  могут
интерпретироваться иначе, например, как целые числа.
<p>     Разнообразные     возможности    имеет    команда    &quot;expr&quot;.
<p>     Проиллюстрируем некоторые на примерах:
<p>     Выполнение командного файла:
<pre>
     x=7 y=2
     a=`expr $x + $y`   ; echo a=$a
     a=`expr $a + 1`    ; echo a=$a
     b=`expr $y - $x`   ; echo b=$b
     c=`expr $x '*' $y` ; echo c=$c
     d=`expr $x / $y`   ; echo d=$d
     e=`expr $x % $y`   ; echo e=$e
</pre>

<p>выдаст на экран
<pre>
     a=9
     a=10
     b=-5
     c=14
     d=3
     e=1
</pre>

<p>     ВНИМАНИЕ.  Операция  умножения (&quot;*&quot;) обязательно должна быть
заэкранирована, поскольку в shell этот значек воспринимается, как
спецсимвол,  означающий,  что на это место может быть подставлена
любая последовательность символов.
<p>     Следует  обратить  также  внимание  на обязательные пробелы,
отделяющие переменные и знаки операций.

<p>     С   командой   &quot;expr&quot;  возможны  не  только  (целочисленные)
арифметические операции, но и строковые:
<pre>
     A=`expr 'cocktail' : 'cock'`  ; echo $A
     B=`expr 'cocktail' : 'tail'`  ; echo $B
     C=`expr 'cocktail' : 'cook'`  ; echo $C
     D=`expr 'cock' : 'cocktail'`  ; echo $D
</pre>

<p>     На   экран   будут   выведены   числа,   показывающее  число
совпадающих  символов  в цепочках (от начала). Вторая из строк не
может быть длиннее первой :</p>

<pre>
     4
     0
     0
     0
</pre>

<p>     И наконец, об условной замене переменныйх.
<p>     Если переменные, скажем &quot;х&quot;, &quot;y&quot;, &quot;z&quot;, не определены, то при
обращении к переменным
<p>     ${x-new} - в качестве значения &quot;x&quot; будет выдано &quot;new&quot;,
<p>     ${y=new} - в качестве значения &quot;у&quot; будет присвоено &quot;new&quot;,
<p>     ${z?new} - в качестве значения &quot;z&quot; будет выдано &quot;z: new&quot; и
соответствующая процедура прекращается.
<p>     Во  всех  этих случаях, если переменная была к этому времени
определена, то ее значение используется обычным образом.
<p>     А  в  следующем  случае наоборот, пусть переменная &quot;v&quot; имеет
какое-то значение, тогда
<p>     ${z+new}  -  в  качестве  значения &quot;z&quot; будет выдано &quot;new&quot;, а
если не было присвоено значение, то пустая строка.

</body>
</html>
