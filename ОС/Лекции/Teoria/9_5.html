<HTML>
<HEAD>
<TITLE>Алгоритмы замещения страниц</TITLE>
</HEAD>
<body>
  <b><font size="6"><center>Алгоритмы замещения страниц</center></font></b><br>
  <br>
  Когда происходит страничное прерывание, операционная система должна выбрать 
  страницу для удаления из памяти, чтобы освободить место для страницы, которую 
  нужно перенести в память. Если удаляемая страница была изменена за время своего 
  присутствия в памяти, ее необходимо переписать на диск, чтобы обновить копию, 
  хранящуюся там. Однако если страница не была модифицирована (например, она содержит 
  текст программы), копия на диске уже является самой новой и ее не надо переписывать. 
  Тогда страница, которую нужно прочитать, просто считывается поверх выгружаемой 
  страницы.<br>
<dd> Хотя в принципе можно при каждом страничном прерывании выбирать случайную 
  страницу для удаления из памяти, производительность системы заметно повышается, 
  когда предпочтение отдается редко используемой странице. Если выгружается страница, 
  обращения к которой происходят часто, велика вероятность, что вскоре опять потребуется 
  ее возврат в память, что даст в результате дополнительные издержки. Теме разработки 
  алгоритмов замены страницы было посвящено много работ, как теоретических, так 
  и экспериментальных. Ниже мы опишем некоторые из наиболее важных алгоритмов.<br>
<dd> Следует отметить, что проблема &laquo;страничного обмена&raquo; также встает 
  и в других областях конструирования компьютеров. Например, у большинства компьютеров 
  есть один или несколько кэшей, состоящих из используемых в последнее время 32-байтовых 
  или 64-байтовых блоков памяти. Когда кэш заполнен, необходимо выбрать некоторые 
  блоки для удаления. Эта проблема практически аналогична замещению страниц лишь 
  с одной разницей, заключающейся в меньшем масштабе времени (операция должна 
  быть выполнена за несколько наносекунд, а не миллисекунд, как для замены страниц). 
  Причиной для более короткого промежутка времени является то, что неудачный поиск 
  блока в кэше обрабатывается из основной памяти, в которой не тратится время 
  на поиск нужного цилиндра диска и нет задержки из-за его вращения.<br>
<dd> Второй пример встречается на web-серверах. Сервер может хранить определенное 
  количество часто используемых web-страниц в своей кэш-памяти. Однако когда кэш-память 
  заполняется целиком и происходит обращение к новой странице, должно приниматься 
  решение о том, какую из страниц выгружать. Здесь применимы те же рассуждения, 
  что и для страниц в виртуальной памяти, с той разницей, что web-страницы никогда 
  не изменяются в кэше, поэтому для них всегда есть свежая копия на диске. В системе 
  виртуальной памяти страницы в оперативной памяти могут быть &laquo;чистыми&raquo; 
  или &laquo;грязными&raquo;.<br>
  <br>
  <br>
<a NAME="01"></a>
  <b><font size="4">Оптимальный алгоритм</font></b><br>
  <br>
  Наилучший из возможных алгоритмов замещения страниц легко описать, но невозможно 
  осуществить. Он действует так. В тот момент, когда происходит страничное прерывание, 
  в памяти находится некоторый набор страниц. К одной из этих страниц будет обращаться 
  следующая команда процессора (к странице, содержащей требуемую команду). На 
  другие страницы, возможно, не будет ссылок в течение следующих 10,100 или даже 
  1000 команд. Каждая страница может быть помечена количеством команд, которые 
  будут выполняться перед первым обращением к этой странице.<br>
<dd> Оптимальный страничный алгоритм просто сообщает, что должна быть выгружена 
  страница с наибольшей меткой. Если одна страница не будет использоваться в течение 
  8 млн команд, а другая — в течение 6 млн инструкций, удаление первой отодвинет 
  в будущее на возможно максимальный срок страничное прерывание, которое вернет 
  ее назад. Компьютеры, подобно людям, пытаются отложить неприятные события настолько, 
  насколько это возможно.<br>
<dd> С этим алгоритмом связана только одна проблема: он невыполним. В момент страничного 
  прерывания операционная система не имеет возможности узнать, когда произойдет 
  следующее обращение к каждой странице. (Мы рассматривали аналогичную ситуацию 
  раньше, когда обсуждали алгоритм планирования &laquo;кратчайшая задача — первая&raquo;: 
  как система может сказать, какая из задач самая короткая?) Тем не менее, выполняя 
  программу на модели и следя за всеми обращениями к страницам, оптимальную замену 
  можно осуществить при <i>втором </i> запуске, используя информацию о ссылках 
  на страницы, собранную во время <i>первого</i> запуска.<br>
<dd> В этом случае можно сравнивать производительность реализуемых алгоритмов 
  с наилучшим. Если операционная система добивается производительности, скажем, 
  всего на один процент ниже, чем при работе оптимального алгоритма, усилия, потраченные 
  на поиск лучшего алгоритма, повысят продуктивность схемы максимум на 1 %.<br>
<dd> Чтобы избежать возможных недоразумений, следует прояснить, что полученный 
  протокол обращений к страницам относится только к одной хорошо спланированной 
  программе и, кроме того, к определенным входным данным. Таким образом, алгоритм 
  замещения страниц, выведенный из него, будет характерен только для этой программы 
  с именно этими входными данными. Хотя такой метод полезен для оценки алгоритмов 
  замещения страниц, он не используется в практических системах. Ниже мы изучим 
  алгоритмы, которые <i>являются</i> применимыми в реальных системах.<br>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Алгоритм NRU — не использовавшаяся в последнее время страница</font></b><br>
  <br>
  Чтобы дать возможность операционной системе собирать полезные статистические 
  данные о том, какие страницы используются, а какие — нет, большинство компьютеров 
  с виртуальной памятью поддерживают два статусных бита, связанных с каждой страницей. 
  Бит <i>R</i> (Referenced — обращения) устанавливается всякий раз, когда происходит 
  обращение к странице (чтение или запись). Бит <i>М</i> (Modified — изменение) 
  устанавливается, когда страница записывается (то есть изменяется). Биты содержатся 
  в каждом элементе таблицы страниц, как показано на рис. 4.13. Важно реализовать 
  обновление этих битов при каждом обращении к памяти, поэтому необходимо, чтобы 
  они задавались аппаратно. Если однажды бит был установлен в 1, то он остается 
  равным 1 до тех пор, пока операционная система программно не вернет его в состояние 
  0.<br>
<dd> Если аппаратное обеспечение не поддерживает эти биты, их можно смоделировать 
  следующим образом. Когда процесс запускается, все его записи в таблице страниц 
  помечаются как отсутствующие в памяти. Как только происходит обращение к странице, 
  происходит страничное прерывание. Затем операционная система устанавливает бит 
  <i>R</i> (в своих внутренних таблицах); изменяет запись в таблице страниц, чтобы 
  она указывала на корректную страницу с режимом READ ONLY (только для чтения), 
  и перезапускает команду. Если страница позднее записывается, происходит другое 
  страничное прерывание, позволяющее операционной системе установить бит <i>М</i> 
  и изменить состояние страницы на READ/WRITE (чтение/запись).<br>
<dd> Биты <i>R</i> и М могут использоваться для построения простого алгоритма 
  замещения страниц, описанного ниже. Когда процесс запускается, оба страничных 
  бита для всех его страниц операционной системой установлены на 0. Периодически 
  (например, при каждом прерывании по таймеру) бит <i>R</i> очищается, чтобы отличить 
  страницы, к которым давно не происходило обращения от тех, на которые были ссылки.<br>
<dd> Когда возникает страничное прерывание, операционная система проверяет все 
  страницы и делит их на четыре категории на основании текущих значений битов 
  <i>R</i> и <i>М</i>:<br>
  <br>
<dd> Класс 0: не было обращений и изменений. <br>
<dd> Класс 1: не было обращений, страница изменена.<br>
<dd> Класс 2: было обращение, страница не изменена.<br>
<dd> Класс 3: произошло и обращение, и изменение.<br>
  <br>
<dd> Хотя класс 1 на первый взгляд кажется невозможным, такое случается, когда 
  у страницы из класса 3 бит <i>R</i> сбрасывается во время прерывания по таймеру. 
  Прерывания по таймеру не стирают бит <i>М,</i> потому что эта информация необходима 
  для того, чтобы знать, нужно ли переписывать страницу на диске или нет. Поэтому 
  если бит <i>R</i> устанавливается на ноль, а М остается нетронутым, страница 
  попадает в класс 1.<br>
<dd> Алгоритм NRU (Not Recently Used — не использовавшийся в последнее время) 
  удаляет страницу с помощью случайного поиска в непустом классе с наименьшим 
  номером. В этом алгоритме подразумевается, что лучше выгрузить измененную страницу, 
  к которой не было обращений по крайней мере в течение одного тика системных 
  часов (обычно 20 мс), чем стереть часто используемую страницу. Привлекательность 
  алгоритма NRU заключается в том, что он легок для понимания, умеренно сложен 
  в реализации и дает производительность, которая, конечно, не оптимальна, но 
  может вполне оказаться достаточной.<br>
  <br>
  <br>
<a NAME="03"></a>
  <b><font size="4">Алгоритм FIFO — первым прибыл — первым обслужен</font></b><br>
  <br>
  Другим требующим небольших издержек алгоритмом является <b>FIFO</b> (First-In, 
  First-Out — &laquo;первым прибыл — первым обслужен&raquo;). Чтобы проиллюстрировать 
  его работу, рассмотрим универсам, на полках которого можно выставить ровно <i>k</i> 
  различных продуктов. Он предлагает новую удобную пищу: растворимый, глубоко 
  замороженный, экологически чистый йогурт, который можно мгновенно приготовить 
  в микроволновой печи. Покупатели тут же обратили внимание на этот продукт, поэтому 
  наш ограниченный в размерах супермаркет, для того чтобы продавать йогурт, должен 
  избавиться от одного из старых товаров.<br>
<dd> Один из вариантов состоит в том, чтобы найти продукт, который супермаркет 
  продает дольше всего (то есть что-нибудь, что начали реализовывать 120 лет назад), 
  и освободить от него магазин на том основании, что им никто больше не интересуется. 
  В действительности супермаркет хранит перечень всех продаваемых в данный момент 
  товаров, упорядоченный по времени их появления. Каждый новый продукт помещается 
  в конец перечня, а из начала списка удаляется одно старое наименование.<br>
<dd> Ту же самую идею можно применить в качестве алгоритма замещения страниц. 
  Операционная система поддерживает список всех страниц, находящихся в данный 
  момент в памяти, в котором первая страница является старейшей, а страницы в 
  хвосте списка попали в него совсем недавно. Когда происходит страничное прерывание, 
  выгружается из памяти страница в голове списка, а новая страница добавляется 
  в его конец. Если алгоритм FIFO использовать в магазине, то он может удалить 
  воск для усов, но также может удалить и муку, соль или масло. Применительно 
  к компьютерам возникает та же проблема. По этой причине алгоритм FIFO редко 
  используется в своей исходной форме.<br>
  <br>
  <br>
<a NAME="04"></a>
  <b><font size="4">Алгоритм &laquo;вторая попытка&raquo;</font></b><br>
  <br>
  В простейшем варианте алгоритма FIFO, который позволяет избежать проблемы вытеснения 
  из памяти часто используемых страниц, у самой старейшей страницы изучается бит 
  <i>R.</i> Если он равен 0, страница не только находится в памяти долго, она 
  вдобавок еще и не используется, поэтому немедленно заменяется новой. Если же 
  бит <i>R</i> равен 1, то ему присваивается значение 0, страница переносится 
  в конец списка, а время ее загрузки обновляется, то есть считается, что страница 
  только что попала в память. Затем процедура продолжается.<br>
<dd> Работа этого алгоритма, называемого <b>&laquo;второй попыткой&raquo;</b> 
  (second chance), показана на рис. 4.15, <i>а.</i> Здесь изображены страницы 
  от <i>A</i> до <i>H</i>, хранящиеся в связанном списке и отсортированные по 
  времени их поступления в память. Числа над страницами обозначают их время загрузки 
  в память.<br>
<dd> Предположим, что в момент времени 20 происходит страничное прерывание. Самой 
  старшей страницей является страница <i>A</i>, она была загружена в память во 
  время 0, когда начал работу процесс. Если бит <i>R</i> страницы <i>А</i> равен 
  0, она выгружается из памяти или путем записи на диск (если страница &laquo;грязная&raquo;), 
  или просто удаляется (если она &laquo;чистая&raquo;). Во втором случае, если 
  бит <i>R</i> равен 1, страница <i>A</i> передвигается в конец списка, а ее &laquo;загрузочное 
  время&raquo; принимает текущее значение (20). При этом бит <i>R</i> <a href="../comment.html#05">очищается</a>. 
  Поиск подходящей страницы продолжается; следующей проверяется страница <i>В.</i><br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_15.jpg" alt="Действие алгоритма вторая попытка: страницы, отсортированные в порядке очереди (FIFO) (а); список страниц, если страничное прерывание произошло во время 20, а страница А имеет бит R, равный 0 (б)"><br>
    <br>
    <b>Рис. 4.15.</b> Действие алгоритма &laquo;вторая попытка&raquo;: страницы, 
    отсортированные в порядке<br>
    очереди (FIFO) (а); список страниц, если страничное прерывание произошло<br>
    во время 20, а страница <i>А</i> имеет бит R, равный 0 (б)<br>
    <br>
  </center>
<dd> Алгоритм &laquo;вторая попытка&raquo; ищет в списке самую старую страницу, 
  к которой не было обращений в предыдущем временном интервале. Если же происходили 
  ссылки на все страницы, то &laquo;вторая попытка&raquo; превращается в обычный 
  алгоритм FIFO. Представьте, что у всех страниц на рис. 4.15, <i>а</i> бит <i>R</i> 
  равен 1. Одну за другой передвигает операционная система страницы в конец списка, 
  очищая бит <i>R</i> каждый раз, когда она перемещает страницу в хвост. Наконец, 
  она вернется к странице <i>А, </i> но теперь уже ее биту <i>R</i> присвоено 
  значение 0. В этот момеш страница <i>А</i> выгружается из памяти. Таким образом, 
  алгоритм всегда успешно завершает свою работу.<br>
  <br>
  <br>
<a NAME="05"></a>
  <b><font size="4">Алгоритм &laquo;часы&raquo;</font></b><br>
  <br>
  Хотя алгоритм &laquo;вторая попытка&raquo; является корректным, он слишком неэффективен, 
  потому что постоянно передвигает страницы по списку. Поэтому лучше хранить все 
  страничные блоки в кольцевом списке в форме часов, как показано на рис. 4.16. 
  Стрелка указывает на старейшую страницу.<br>
<dd> Когда происходит страничное прерывание, проверяется та страница, на которую 
  направлена стрелка. Если ее бит <i>R</i> равен 0, страница выгружается, на ее 
  место в часовой круг встает новая страница, а стрелка сдвигается вперед на одну 
  позицию. Если бит <i>R</i> равен 1, то он сбрасывается, стрелка перемещается 
  к следующей странице. Этот процесс повторяется до тех пор, пока не находится 
  та страница, у которой бит <i>R =</i> 0. Неудивительно, что этот алгоритм называется 
  <b>&laquo;часы&raquo;.</b> Он отличается от алгоритма &laquo;вторая попытка&raquo; 
  только своей реализацией.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_16.jpg" alt="Алгоритм замещения страниц - часы"> 
    <br>
    <br>
    <b>Рис. 4.16.</b> Алгоритм замещения страниц &laquo;часы&raquo;<br>
    <br>
    <br>
  </center>
<a NAME="06"></a>
  <b><font size="4">Алгоритм LRU — страница не использовавшаяся дольше всего</font></b><font size="4"><br>
  </font><br>
  В основе этой неплохой аппроксимации оптимального алгоритма лежит наблюдение, 
  что страницы, к которым происходило многократное обращение в нескольких последних 
  командах, вероятно, также будут часто использоваться в следующих инструкциях. 
  И наоборот, можно полагать, что страницы, к которым ранее не возникало обращений, 
  не будут употребляться в течение долгого времени. Эта идея привела к следующему 
  реализуемому алгоритму: когда происходит страничное прерывание, выгружается 
  из памяти страница, которая не использовалась дольше всего. Такая стратегия 
  замещения страниц называется <b>LRU </b> (Least Recently Used — &laquo;менее 
  недавно&raquo;, то есть наиболее давно использовавшаяся страница).<br>
<dd> Хотя алгоритм LRU теоретически реализуем, он не является дешевым. Для полного 
  осуществления алгоритма LRU необходимо поддерживать связный список всех содержащихся 
  в памяти страниц, где последняя использовавшаяся страница находится в начале 
  списка, а та, к которой дольше всего не было обращений, — в конце. Сложность 
  заключается в том, что список должен обновляться при каждом обращении к памяти. 
  Поиск страницы, ее удаление, а затем вставка в начало списка — это операции, 
  поглощающие очень много времени, даже если они выполняются аппаратно (если предположить, 
  что необходимое оборудование можно сконструировать).<br>
<dd> Однако существуют другие способы реализации алгоритма LRU с помощью специального 
  оборудования. Для первого метода требуется оснащение компьютера 64-разрядным 
  аппаратным счетчиком <i>С,</i> который автоматически возрастает после каждой 
  команды. Кроме того, каждая запись в таблице страниц должна иметь поле, достаточно 
  большое для хранения значения счетчика. После каждого обращения к памяти текущая 
  величина счетчика С запоминается в записи таблицы, соответствующей той странице, 
  к которой произошла ссылка. А если возникает страничное прерывание, операционная 
  система проверяет все значения счетчиков в таблице страниц и ищет наименьшее. 
  Эта страница является не использовавшейся дольше всего.<br>
<dd> Теперь рассмотрим второй вариант аппаратной реализации алгоритма LRU. На 
  машине с <i>n</i> страничными блоками оборудование LRU может поддерживать матрицу 
  <i>n * n</i> бит, изначально равных нулю. Всякий раз, когда происходит обращение 
  к страничному блоку <i>k,</i> аппаратура сначала присваивает всем битам строки 
  <i>k</i> значение 1, затем приравнивает к нулю все биты столбца <i>k.</i> В 
  любой момент времени строка, двоичное значение которой наименьшее, является 
  не использовавшейся дольше всего. Работа этого алгоритма продемонстрирована 
  на рис. 4.17, где рассматриваются четыре страничных блока и следующий порядок 
  обращения к страницам:<br>
  <br>
<dd> <font face="Arial">0123210323</font><br>
  <br>
<dd> После ссылки на страницу 0 мы получаем ситуацию, показанную на рис. 4.17, 
  а; после обращения к странице 1 — рис. 4.17, <i>б</i> и т. д.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_17.jpg" alt="Алгоритм LRU, использующий матрицу"><br>
    <br>
    <b>Рис. 4.17.</b> Алгоритм LRU, использующий матрицу. Обращения к страницам<br>
    происходят в порядке: 0, 1, 2, 3, 2, 1, 0, 3, 2, 3<br>
  </center>
  <br>
  <br>
<a NAME="07"></a>
  <b><font size="4">Программное моделирование алгоритма LRU</font></b><br>
  <br>
  Хотя оба описанных выше алгоритма LRU в принципе осуществимы, очень мало (если 
  вообще такие есть) машин оснащено подобным оборудованием, поэтому разработчики 
  операционных систем для компьютеров, не имеющих такой аппаратуры, редко используют 
  эти алгоритмы. Вместо этого требуется программно реализуемое решение. Одна из 
  разновидностей схемы LRU называется алгоритмом NFU (Not Frequently Used — редко 
  использовавшаяся страница). Для него необходим программный счетчик, связанный 
  с каждой страницей в памяти, изначально равный нулю. Во время каждого прерывания 
  по таймеру операционная система исследует все страницы в памяти. Бит <i>R</i> 
  каждой страницы (он равен 0 или 1) прибавляется к счетчику. В сущности, счетчики 
  пытаются отследить, как часто происходило обращение к каждой странице. При страничном 
  прерывании для замещения выбирается страница с наименьшим значением счетчика.<br>
<dd> Основная проблема, возникающая при работе с алгоритмом NFU, заключается в 
  том, что он никогда ничего не забывает. Например, в многоходовом компиляторе 
  страницы, которые часто использовались во время первого прохода, могут все еще 
  иметь высокое значение счетчика при более поздних проходах. Фактически, если 
  случается так, что первый проход занимает самое долгое время выполнения из всех, 
  страницы, содержащие программный код для следующих проходов, могут всегда иметь 
  более низкое значение счетчика, чем страницы первого прохода. Следовательно, 
  операционная система удалит полезные страницы вместо тех, которые больше не 
  нужны.<br>
<dd> К счастью, небольшая доработка алгоритма NFU делает его способным моделировать 
  алгоритм LRU достаточно хорошо. Изменение состоит из двух частей. Во-первых, 
  каждый счетчик сдвигается вправо на один разряд перед прибавлением бита <i>R.</i> 
  Во-вторых, бит <i>R</i> добавляется в крайний слева, а не в крайний справа бит 
  счетчика.<br>
<dd> На рис. 4.18 продемонстрировано, как работает видоизмененный алгоритм, известный 
  под названием <b>&laquo;старение&raquo;</b> (aging). Предположим, что после 
  первого тика часов биты <i>R</i> для страниц от 0 до 5 имеют значения 1,0, 1,0, 
  1, 1 соотвественно (у страницы 0 бит <i>R </i> равен 1, у страницы 1 <i>R =</i> 
  0, у страницы 2 <i>R =</i> 1 и т. д.). Другими словами, между тиком 0 и тиком 
  1 произошло обращение к страницам 0, 2, 4 и 5, их биты <i>R</i> приняли значение 
  1, остальные сохранили значение 0. После того как шесть соответствующих счетчиков 
  сдвинулись на разряд и бит <i>R</i> занял крайнюю слева позицию, счетчики получили 
  значения, показанные на рис. 4.18, <i>а.</i> Остальные четыре колонки рисунка 
  изображают шесть счетчиков после следующих четырех тиков часов.<br>
<dd> Когда происходит страничное прерывание, удаляется та страница, чей счетчик 
  имеет наименьшую величину. Ясно, что счетчик страницы, к которой не было обращений, 
  скажем, за четыре тика, будет начинаться с четырех нулей и, таким образом, иметь 
  более низкое значение, чем счетчик страницы, на которую не ссылались в течение 
  только трех тиков часов.<br>
<dd> Эта схема отличается от алгоритма LRU в двух случаях. Рассмотрим страницы 
  3 и 5 на рис. 4.18, <i>д.</i> Ни к одной из них не было обращений за последние 
  два тика, к обеим было обращение за предшествующий этому тик. Следуя алгоритму 
  LRU, при удалении страницы из памяти мы должны выбрать одну из этих двух. Проблема 
  в том, что мы не знаем, к какой из них позже произошло обращение в интервале 
  времени между тиками 1 и 2. Записывая только один бит за промежуток времени, 
  мы теряем возможность отличить более ранние от более поздних обращений в этом 
  интервале времени. Все, что мы можем сделать — это выгрузить страницу 3, потому 
  что к странице 5 также обращались двумя тиками раньше, а к странице 3 — нет.<br>
<dd> Второе отличие между алгоритмами LRU и &laquo;старения&raquo; заключается 
  в том, что в последнем счетчик имеет конечное число разрядов, например 8. Предположим, 
  что каждая из двух страниц имеет значение счетчика, равное 0. В данной ситуации 
  мы только случайным образом можем выбрать одну из них. На самом деле может оказаться, 
  что к одной странице в последний раз обращались 9 тиков назад, а к другой — 
  1000. И мы не имеем возможности увидеть это. На практике, однако, обычно достаточно 
  8 битов при тике системных часов около 20 мс. Если к странице не обращались 
  в течение 160 мс, очень вероятно, что она не важна.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_18.jpg" alt="Алгоритм старения программно моделирует алгоритм LRU"> 
    <br>
    <br>
    <b>Рис. 4.18.</b> Алгоритм старения программно моделирует алгоритм LRU.<br>
    Здесь изображены шесть страниц после пяти тиков часов от (а) до (<i>д</i>)<br>
  </center>
  <br>
  <br>
<a NAME="08"></a>
  <b><font size="4">Алгоритм &laquo;рабочий набор&raquo;</font></b><br>
  <br>
  В простейшей схеме страничной подкачки в момент запуска процессов нужные им 
  страницы отсутствуют в памяти. Как только центральный процессор пытается выбрать 
  первую команду, он получает страничное прерывание, побуждающее операционную 
  систему перенести в память страницу, содержащую первую инструкцию. Обычно следом 
  быстро происходят страничные прерывания для глобальных переменных и стека. Через 
  некоторое время в памяти скапливается большинство необходимых процессу страниц, 
  и он приступает к работе с относительно небольшим количеством ошибок из-за отсутствия 
  страниц. Этот метод называется <b>замещением страниц по запросу</b> (demand 
  paging), потому что страницы загружаются в память по требованию, а не заранее.<br>
<dd> Конечно, достаточно легко написать тестовую программу, систематически читающую 
  все страницы в огромном адресном пространстве, вызывая так много страничных 
  прерываний, что будет не хватать памяти для их обработки, К счастью, большинство 
  процессов не работают таким образом. Они характеризуются <b>локальностью обращений,</b> 
  означающей, что во время выполнения любой фразы процесс обращается только к 
  сравнительно небольшой части своих страниц. Каждый проход многоходового компилятора, 
  например, обращается только к части от общего количества страниц, и каждый раз 
  к другой части.<br>
<dd> Множество страниц, которое процесс использует в данный момент, называется 
  <b>рабочим набором</b> ([89, 92]). Если рабочий набор целиком находится в памяти, 
  процесс будет работать, не вызывая большого количества ошибок, до тех пор пока 
  он не перейдет к другой фазе выполнения (то есть к следующему проходу компилятора) 
  . Если доступная память слишком мала для того, чтобы содержать полный рабочий 
  набор, процесс вызовет много страничных прерываний и будет работать медленнее, 
  так как выполнение инструкции занимает несколько наносекунд, а чтение страницы 
  с диска обычно требует 10 мс. При скорости одна или две команды за 10 мс для 
  завершения программы понадобятся века. Говорят, что программа, вызывающая страничное 
  прерывание каждые несколько команд, <b>пробуксовывает </b> (thrashing) [90].<br>
<dd> В многозадачных системах процессы часто перемещаются на диск (то есть все 
  их страницы удаляются из памяти), чтобы позволить другим процессам получить 
  доступ к центральному процессору. Возникает вопрос, что делать, когда процесс 
  снова загружается в память. С формальной точки зрения делать ничего не нужно. 
  Процесс будет вызывать одно за другим страничные прерывания до тех пор, пока 
  не загрузится в память весь его рабочий набор. Проблема в том, что наличие 20, 
  100 или даже 1000 страничных прерываний при каждой загрузке процесса сильно 
  замедляет работу системы и, кроме того, тратит впустую значительное количество 
  времени работы центрального процессора, так как обработка страничного прерывания 
  операционной системой требует нескольких миллисекунд работы процессора.<br>
<dd> Поэтому многие системы со страничной организацией пытаются отслеживать рабочий 
  набор каждого процесса и обеспечивают его нахождение в памяти до запуска процесса. 
  Такой подход носит название <b>модели рабочего набора</b> [91]. Он разработан 
  для того, чтобы значительно снизить процент страничных прерываний. Загрузка 
  страниц <i>перед</i> тем, как разрешить процессу работать, также называется 
  <b>опережающей подкачкой страниц</b> (prepaging). Заметьте, что рабочий набор 
  изменяется с течением времени.<br>
<dd> Давно известно, что большинство программ не обращаются к своему адресному 
  пространству равномерно; чаще всего ссылки группируются на небольшом количестве 
  страниц. Обращение к памяти может быть выборкой команды, данных или сохранением 
  данных. В любой момент времени <i>t </i> существует множество страниц, использовавшихся 
  за <i>k</i> последних обращений к памяти. Это множество <i>w(k, t)</i> и есть 
  рабочий набор. Так как все недавние обращения к памяти для <i>k &gt;</i> 1 обязательно 
  должны были обращаться ко всем страницам, использовавшимся для <i>k</i> = 1 
  обращения к памяти, то есть к последней и, возможно, еще к некоторым страницам, 
  <i>w(k, t)</i> является монотонно неубывающей функцией от <i>k.</i> Функция 
  <i>w(k, t)</i> ограничена для больших <i>k,</i> потому что программа не может 
  обращаться к большему количеству страниц, чем содержится в ее адресном пространстве, 
  кроме того, редкие программы обращаются ко всем страницам адресного пространства. 
  На рис. 4.19 изображена зависимость размера рабочего набора от <i>k.</i><br>
<dd> Тот факт, что большинство программ случайным образом обращается к небольшому 
  числу страниц, но это множество медленно изменяется во времени, объясняет быстрое 
  возрастание функции в начале и затем медленное увеличение для больших <i>k.</i> 
  Например, программа, которая выполняет цикл, затрагивающий две страницы и использующий 
  данные на четырех страницах, может обращаться ко всем шести страницам через 
  каждые 1000 инструкций, но самое последнее обращение к некоторым другим страницам 
  могло произойти миллионом команд раньше, во время начальной загрузки фазы. Вследствие 
  этого асимптотического характера содержимое рабочего набора не чувствительно 
  к выбранной величине <i>k.</i> Существует широкий диапазон значений <i>k,</i> 
  для которых рабочий набор постоянен. Поскольку рабочий набор медленно меняется 
  со временем, можно сделать разумное предположение, что те страницы, которые 
  будут нужны для возобновления работы программы, составляют основу рабочего набора 
  во время последней остановки процесса. Опережающая подкачка страниц заключается 
  в загрузке рабочего набора до того, как процессу разрешается возобновиться.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_19.jpg" alt="Рабочий набор — это множество страниц, используемых k последними обращениями к памяти. Функция w(k,t) представляет собой размер рабочего набора в момент времени t"><br>
    <br>
    <b>Рис.</b> 4.19. Рабочий набор — это множество страниц, используемых k последними 
    обращениями<br>
    к памяти. Функция w(k,t) представляет собой размер рабочего набора в момент 
    времени t<br>
  </center>
  <br>
<dd> Чтобы реализовать модель рабочего набора, необходимо, чтобы операционная 
  система отслеживала, какие страницы в нем находятся. Наличие этой информации 
  также немедленно приводит к возможному алгоритму замещения страниц: когда происходит 
  страничное прерывание, ищется и выгружается страница, не находящаяся в рабочем 
  наборе. Для реализации такого алгоритма нужен точный метод определения того, 
  какая страница находится в рабочем наборе, а какая в него не включена в любой 
  заданный момент времени.<br>
<dd> Как мы упоминали выше, рабочим набором является множество страниц, использовавшихся 
  в <i>k</i> последних обращениях к памяти (некоторые авторы используют <i>k</i> 
  последних страничных обращений, но выбор произволен). Для осуществления алгоритма 
  &laquo;рабочий набор&raquo; заранее нужно назначить значение <i>k.</i> Как только 
  некоторая величина выбрана, после каждого обращения к памяти набор страниц, 
  используемых за предыдущие <i>k </i> обращений, определяется единственным образом.<br>
<dd> Конечно, наличие действующего определения рабочего набора вовсе не означает, 
  что существует эффективный способ отслеживания его в реальном времени, то есть 
  во время выполнения программы. Можно было бы придумать сдвигающийся регистр 
  длины <i>k,</i> который смещается влево на одну позицию при каждом обращении 
  к памяти и записывает номер последней использовавшейся страницы в крайнюю правую 
  позицию. Все <i>k</i> номеров страниц в сдвигающемся регистре входили бы в рабочий 
  набор. Теоретически в момент страничного прерывания содержимое этого регистра 
  могло бы считываться и сохраняться. Затем удалялись бы дублирующиеся страницы. 
  В результате мы бы получали рабочий набор. Однако поддержка сдвигающегося регистра 
  и его обработка при страничном прерывании чрезвычайно дороги, поэтому данная 
  техника никогда не употребляется на деле.<br>
<dd> Вместо нее используются различные аппроксимации. Применяемый в большинстве 
  случаев подход заключается в том, чтобы оставить идею подсчета <i>k</i> последних 
  обращений к памяти и вместо этого использовать время выполнения программы. Например, 
  вместо определения рабочего набора как множества страниц, на которые ссылались 
  при предыдущих 10 млн обращений к памяти, мы можем определить его как множество 
  страниц, использовавшихся в течение последних 100 мс времени выполнения. На 
  практике это определение имеет тот же смысл, но намного упрощает реализацию 
  алгоритма. Заметим, что для каждого процесса считается только его собственное 
  время работы. Таким образом, если процесс стартовал во время <i>Т</i> и<i></i> 
  занял процессор на 40 мс за реальное время <i>Т</i> + 100 мс, для определения 
  рабочего набора его время равно 40 мс. Время работы процессора, которое фактически 
  использовал процесс с момента запуска, часто называется текущим виртуальным 
  временем. При таком приближении рабочий набор процесса — это множество страниц, 
  к которому он обращался за последние т секунд виртуального времени.<br>
<dd> Теперь рассмотрим алгоритм замещения страниц, основанный на рабочем наборе. 
  Его базовая идея заключается в том, чтобы найти страницу, не включенную в рабочий 
  набор, и выгрузить ее. На рис. 4.20 изображена часть таблицы страниц для некоторой 
  машины. Поскольку в качестве кандидатов на удаление рассматриваются только те 
  страницы, которые в настоящее время находятся в памяти, отсутствующие в памяти 
  страницы этим алгоритмом игнорируются. Каждая запись содержит (по крайней мере) 
  два элемента информации: приближенное время, в которое страница использовалась 
  в последний раз, и бит <i>R</i> (обращения). Пустые белые прямоугольники символизируют 
  другие поля, ненужные для данного алгоритма, такие как номер страничного блока, 
  биты защиты и бит <i>М</i> (изменения).<br>
<dd> Алгоритм работает следующим образом. Предполагается, что аппаратное обеспечение 
  устанавливает биты R и <i>М,</i> как мы описывали выше. Предполагается также, 
  что периодическое прерывание по таймеру вызывает запуск программы, очищающей 
  бит <i>R</i> при каждом тике часов. При каждом страничном прерывании исследуется 
  таблица страниц и ищется страница, подходящая для удаления из памяти.<br>
<dd> В процессе обработки каждой записи проверяется бит <i>R.</i> Если он равен 
  1, текущее виртуальное время записывается в поле <i>Время последнего использования 
  (Time of last use)</i> в таблице страниц, указывая, что страница использовалась 
  в тот момент, когда произошло прерывание. Так как к странице было обращение 
  в течение данного такта, ясно, что она находится в рабочем наборе и не является 
  кандидатом на удаление (предполагается, что т охватывает несколько тиков часов).<br>
<dd> Если бит <i>R</i> равен 0, это означает, что к странице не было обращений 
  в течение последнего тика часов и она может быть кандидатом на удаление. Чтобы 
  понять, нужно ли ее выгружать, вычисляется ее возраст, то есть текущее виртуальное 
  время минус ее <i>Время последнего использования, </i> и сравнивается с т. Если 
  возраст больше величины т, это означает, что страница более не находится в рабочем 
  наборе.<br>
<dd> Она стирается, а на ее место загружается новая страница. Однако сканирование 
  таблицы продолжается, обновляя остальные записи.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_20.jpg" alt="Алгоритм - рабочий набор"> 
    <br>
    <br>
    <b>Рис. 4.20.</b> Алгоритм &laquo;рабочий набор&raquo;<br>
  </center>
  <br>
<dd> Если же бит <i>R</i> равен 0, но возраст страницы меньше или равен времени 
  т, это значит, что страница до сих пор находится в рабочем наборе. Она временно 
  обходится, но страница с наибольшим возрастом запоминается (наименьшим значением 
  <i>Времени последнего использования).</i> Если проверена вся таблица, а кандидат 
  на удаление не найден, это означает, что все страницы входят в рабочий набор. 
  В этом случае, если были найдены одна или больше страниц с битом <i>R</i> = 
  0, удаляется та из них, которая имеет наибольший возраст. В худшем случае ко 
  всем страницам произошло обращение за время текущего такта часов (и, следовательно, 
  все они имеют бит <i>R</i> = 1), тогда для удаления случайным образом выбирается 
  одна из них, причем желательно чистая, если такая страница существует.<br>
  <br>
  <br>
<a NAME="09"></a>
  <b><font size="4">Алгоритм WSCIock</font></b><br>
  <br>
  Исходный алгоритм &laquo;рабочий набор&raquo; громоздок, так как при каждом 
  страничном прерывании следует проверять таблицу страниц до тех пор, пока не 
  определится местоположение подходящего кандидата. Усовершенствованный алгоритм, 
  основанный на часовом алгоритме, но также использующий информацию рабочего набора, 
  называется <b>WSCIock</b> [54]. Благодаря простоте реализации и хорошей производительности 
  этот алгоритм широко используется на практике.<br>
<dd> Для него необходима структура данных в виде кольцевого списка страничных 
  блоков, как в алгоритме &laquo;часы&raquo;, что изображено на рис. 4.21, <i>а.</i> 
  В исходном положении этот список пустой. Когда загружается первая страница, 
  она добавляется в список. По мере прихода страниц они поступают в список, формируя 
  кольцо.<br>
<dd> Каждая запись, кроме бита <i>R</i> (показан) и бита <i>М</i> (не показан), 
  содержит поле <i>&laquo;время последнего использования&raquo; </i> из базового 
  алгоритма &laquo;рабочий набор&raquo;.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_21.jpg" alt="Работа алгоритма WSCIock: пример того, что происходит при бите R = 1 (а) и (б); пример для бита R = 0 (в) и (г)"><br>
    <br>
    <b>Рис. 4.21.</b> Работа алгоритма WSCIock: пример того, что происходит при 
    бите R = 1 (а) и (б);<br>
    пример для бита R = 0 (<i>в</i>) и (<i>г</i>)<br>
  </center>
  <br>
<dd> Как и в случае алгоритма &laquo;часы&raquo;, при каждом страничном прерывании 
  первой проверяется та страница, на которую указывает стрелка. Если бит <i>R</i> 
  равен 1, это значит, что страница использовалась в течение последнего такта 
  часов, поэтому она не является идеальным кандидатом на удаление. Тогда бит <i>R</i> 
  устанавливается на 0, стрелка передвигается на следующую страницу и для нее 
  повторяется алгоритм. Состояние после такой последовательности действий продемонстрировано 
  на рис. 4.21, <i>б.</i><br>
<dd> Теперь рассмотрим, что происходит, если страница, на которую указывает стрелка, 
  имеет бит <i>R</i> = 0, как показано на рис. 4.21, <i>в.</i> Если возраст страницы 
  больше величины т и страница — чистая, то она не входит в рабочий набор и на 
  диске есть ее действительная копия. Тогда в данный страничный блок просто загружается 
  новая страница, как изображено на рис. 4.21, <i>г.</i> Если, напротив, страница 
  &laquo;грязная&raquo;, ее нельзя немедленно стереть, так как на диске нет ее 
  последней копии. Чтобы избежать переключения процессов, запись на диск включается 
  в график планирования, но стрелка сдвигается на позицию, и алгоритм продолжает 
  работу со следующей страницей. Несмотря на то что &laquo;грязная&raquo; страница 
  может быть старше, чистая находится ближе в ряду страниц, которые можно использовать 
  немедленно.<br>
<dd> Теоретически за один обход вокруг циферблата часов для всех страниц может 
  оказаться запланированным ввод-вывод с диска. Чтобы уменьшить поток обмена с 
  диском, можно установить предел, позволяющий быть записанными максимум <i>п</i> 
  страницам. После достижения этой границы новые операции записи перестают включаться 
  в график.<br>
<dd> Что происходит, если стрелка обходит целый круг и возвращается к начальной 
  точке? Существует два варианта:<br>
  <br>
<dd> 1. Запланирована, по крайней мере, одна операция записи на диск.<br>
<dd> 2. Ни одной операции записи не запланировано.<br>
  <br>
<dd> В первом случае стрелка продолжает движение, отыскивая чистую страницу. Так 
  как запланирована одна или больше операций записи на диск, со временем какая-нибудь 
  из них будет выполнена, и соответствующая страница будет помечена как чистая. 
  Выгружается первая попавшаяся чистая страница. Это не обязательно та страница, 
  запись которой запланирована первой, потому что драйвер диска может изменить 
  порядок работы с диском, чтобы оптимизировать его производительность.<br>
<dd> Во втором случае все страницы находятся в рабочем наборе, иначе планировалась 
  бы, по крайней мере, одна операция записи. За недостатком дополнительной информации 
  проще всего предъявить права на любую чистую страницу и использовать ее. Расположение 
  чистой страницы могло бы отслеживаться во время &laquo;чистки&raquo;. Если в 
  памяти нет чистых страниц, тогда выбирается текущая страница и переписывается 
  на диск.<br>
  <br>
  <br>
<a NAME="10"></a>
  <b><font size="4">Алгоритмы замещения страниц, резюме</font></b><br>
  <br>
  Мы рассмотрели множество различных алгоритмов замещения страниц. В этом разделе 
  мы кратко подведем итоги вышесказанного. Список обсужденных алгоритмов представлен 
  в табл. 4.2.<br>
<dd> Оптимальный алгоритм заменяет ту страницу, обращение к которой производилось 
  раньше других, находящихся в данный момент в памяти. К сожалению, не существует 
  способа определения того, какая страница будет последней, поэтому данный алгоритм 
  не может использоваться на практике. Но он полезен в качестве тестовой задачи, 
  относительно которой можно оценивать другие алгоритмы.<br>
<dd> Алгоритм NRU (не использовавшаяся в последнее время страница) делит страницы 
  на четыре класса в зависимости от состояния битов <i>R</i> и <i>М.</i> Выбирается 
  любая страница из класса с наименьшим номером. Этот алгоритм легко реализуется, 
  но он является очень грубым. Существуют лучшие схемы.<br>
  <br>
  <center>
    <b>Таблица 4.2.</b> Алгоритмы замещения страниц, описанные в тексте<br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="674" HEIGHT="23">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="center" VALIGN="center" WIDTH="237" HEIGHT="33"> <b>Алгоритм</b> 
        </TD>
        <TD ALIGN="center" VALIGN="center" WIDTH="437" HEIGHT="33"> <b>Комментарии</b> 
        </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="left" VALIGN="TOP" WIDTH="237" HEIGHT="14"> Оптимальный </TD>
        <TD ALIGN="left" VALIGN="TOP" WIDTH="437" HEIGHT="14"> Не осуществим, 
          но полезен в качестве тестовой задачи </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="left" VALIGN="TOP" WIDTH="237" HEIGHT="14"> NRU (не использовавшаяся 
          в последнее время страница) </TD>
        <TD ALIGN="left" VALIGN="TOP" WIDTH="437" HEIGHT="14"> Очень грубый </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="left" VALIGN="TOP" WIDTH="237" HEIGHT="14"> FIFO (первым прибыл, 
          первым обслужен) </TD>
        <TD ALIGN="left" VALIGN="TOP" WIDTH="437" HEIGHT="14"> Может выгрузить 
          важные страницы </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="left" VALIGN="TOP" WIDTH="237" HEIGHT="14"> Вторая попытка 
        </TD>
        <TD ALIGN="left" VALIGN="TOP" WIDTH="437" HEIGHT="14"> Значительное усовершенствование 
          FIFO </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="left" VALIGN="TOP" WIDTH="237" HEIGHT="14"> Часы </TD>
        <TD ALIGN="left" VALIGN="TOP" WIDTH="437" HEIGHT="14"> Реалистичный </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="left" VALIGN="TOP" WIDTH="237" HEIGHT="14"> LRU (страница, 
          не использовавшаяся дольше всего) </TD>
        <TD ALIGN="left" VALIGN="TOP" WIDTH="437" HEIGHT="14"> Отличный алгоритм, 
          но его сложно осуществить целиком </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="left" VALIGN="TOP" WIDTH="237" HEIGHT="14"> NFU (редко использовавшаяся 
          страница) </TD>
        <TD ALIGN="left" VALIGN="TOP" WIDTH="437" HEIGHT="14"> Довольно грубое 
          приближение алгоритма LRU </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="left" VALIGN="TOP" WIDTH="237" HEIGHT="14"> Старение </TD>
        <TD ALIGN="left" VALIGN="TOP" WIDTH="437" HEIGHT="14"> Эффективный алгоритм, 
          хорошо аппроксимирующий алгоритм LRU </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="left" VALIGN="TOP" WIDTH="237" HEIGHT="14"> Рабочий набор </TD>
        <TD ALIGN="left" VALIGN="TOP" WIDTH="437" HEIGHT="14"> Немного дорог для 
          реализации </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="left" VALIGN="TOP" WIDTH="237" HEIGHT="14"> WSCIock </TD>
        <TD ALIGN="left" VALIGN="TOP" WIDTH="437" HEIGHT="14"> Хороший рациональный 
          алгоритм </TD>
      </TR>
    </TABLE>
    <br>
  </center>
<dd> Алгоритм FIFO (первым прибыл — первым обслужен) отслеживает порядок загрузки 
  страниц в память, храня их в связном списке. При этом удаление старейшей страницы 
  становится тривиальным, но эта страница может использоваться в данный момент, 
  поэтому алгоритм FIFO представляет собой плохой выбор.<br>
<dd> Алгоритм &laquo;вторая попытка&raquo; — это модификация алгоритма FIFO, он 
  перед удалением страницы из памяти проверяет, используется ли она в данный момент. 
  Если да, то страница пропускается. Такое изменение сильно повышает производительность. 
  Алгоритм &laquo;часы&raquo; представляет собой всего лишь другое осуществление 
  алгоритма &laquo;второй попытки&raquo;. Он имеет те же самые характеристики 
  производительности, но требует немного меньше времени на выполнение алгоритма.<br>
<dd> Алгоритм LRU (страница, не использовавшаяся дольше всего) — это отличный 
  алгоритм, но его нельзя осуществить без специального аппаратного обеспечения. 
  Если подобное оборудование недоступно, алгоритм невозможно использовать. Алгоритм 
  NFU (редко использовавшаяся страница) представляет собой грубую попытку аппроксимации 
  алгоритма LRU. Он не очень хорош. Но существует алгоритм &laquo;старения&raquo;, 
  который намного лучше аппроксимирует алгоритм LRU и может быть эффективно реализован. 
  Это замечательный выбор.<br>
<dd> Последние два алгоритма используют рабочий набор. Алгоритм &laquo;рабочий 
  набор&raquo; обладает приемлемой производительностью, но дорог в реализации. 
  Алгоритм WSCIock — это вариант, который не только дает достойную производительность, 
  но его также достаточно просто реализовать.<br>
<dd> В итоге двумя наилучшими алгоритмами являются &laquo;старение&raquo; и WSCIock. 
  Они основаны на алгоритме LRU и понятии рабочего набора соответственно. Оба 
  обеспечивают хорошую постраничную подкачку и могут быть реализованы за разумную 
  цену. Существует еще несколько алгоритмов, но для практических целей эти два 
  являются, вероятно, наиболее важными.<br>
</BODY>
</HTML>
