<HTML>
<HEAD>
<TITLE>Сопутствующие вопросы</TITLE>
</HEAD>
<body>
  <b><font size="6"><center>Сопутствующие вопросы</center></font></b><br>
  <br>
  В этом разделе мы обсудим несколько разных вопросов, имеющих отношение к взаимоблокировкам. 
  Сюда входят двухфазовое блокирование, тупик без ресурсов и &laquo;голодание&raquo;.<br>
  <br>
  <br>
<a NAME="01"></a>
  <b><font size="4">Двухфазовое блокирование</font></b><br>
  <br>
  Хотя и избежание, и предотвращение блокировок в общем случае не являются многообещающими, 
  для отдельных прикладных задач известно немало прекрасных алгоритмов специального 
  назначения. Например, во многих системах баз данных очень часто выполняется 
  операция, которая просит заблокировать несколько записей и затем обновить все 
  заблокированные записи. Когда одновременно работает несколько процессов, появляется 
  реальная опасность взаимоблокировки.<br>
<dd> Часто используемый подход называется двухфазовым блокированием. В первой 
  фазе, то есть на первом этапе, процесс пытается заблокировать все требуемые 
  записи по одной за раз. Если операция успешна, процесс переходит ко второму 
  этапу, выполняя обновление и освобождение блокировок. Никакой настоящей работы 
  на первом этапе не совершается.<br>
<dd> Если во время первой фазы какая-либо необходимая запись оказывается уже заблокированной, 
  процесс просто освобождает все свои блокировки и начинает первую фазу заново. 
  В некотором смысле этот метод похож на схему, в которой запрос всех необходимых 
  ресурсов происходит заранее, или, по крайней мере, перед тем, как произойдет 
  что-то необратимое. В некоторых версиях двухфазового блокирования, если блокировка 
  встретилась во время первой фазы, не происходит возврата ресурсов и возобновления 
  процесса. В таких версиях может возникнуть тупиковая ситуация.<br>
<dd> Но эту стратегию нельзя обобщить. В системах реального времени и системах 
  контроля процессов, например, недопустимо частично завершить процесс из-за того, 
  что ресурс недоступен, а потом опять начинать все заново. Также недопустимо 
  перезапускать процесс, если он прочел или написал сообщение в сети, обновил 
  файлы и сделал что-нибудь еще, что не может быть безопасно повторено. Алгоритм 
  работает только в тех ситуациях, когда программист очень тщательно подготовил 
  все таким образом, что программу можно остановить в любой точке первой фазы 
  и запустить заново. Многие программы не могут быть структурированы таким образом.<br>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Тупики без ресурсов</font></b><br>
  <br>
  До сих пор все наши рассуждения были сконцентрированы на взаимоблокировках ресурсов. 
  Один процесс хочет получить что-то, что есть у другого процесса, и должен ждать, 
  пока тот не отдаст это что-то. Тем не менее взаимоблокировки также могут происходить 
  и в других ситуациях, включая те, в которых ресурсы вообще не участвуют.<br>
<dd> Например, может случиться, что два процесса заблокировали друг друга: каждый 
  ждет, когда другой выполнит некое действие. Такое часто случается с семафорами. 
  В главе 2 мы видели примеры, в которых процесс должен был выполнить системный 
  вызов down на двух семафорах, обычно на семафоре <i>mutex</i> и еще на одном. 
  Если эту операцию выполнить в неправильном порядке, то в результате получится 
  взаимоблокировка.<br>
  <br>
  <br>
<a NAME="03"></a>
  <b><font size="4">Голодание</font></b><br>
  <br>
  <b>&laquo;Голодание&raquo;</b> является проблемой, тесно связанной с взаимоблокировкой. 
  В динамических системах постоянно происходят запросы к ресурсам. Необходима 
  некоторая политика принятия решений о том, когда, кто и какой ресурс получит. 
  Эта политика хотя и кажется разумной, может привести к тому, что некоторые процессы 
  никогда не получат требуемое, хотя они и не будут заблокированы.<br>
<dd> Например, рассмотрим процесс предоставления принтера. Представим, что система 
  использует некоторый вид алгоритма, гарантирующий, что предоставление принтера 
  процессу не приводит к взаимоблокировке. Теперь предположим, что несколько процессов 
  одновременно хотят воспользоваться принтером. Какой из них должен получить этот 
  ресурс?<br>
<dd> Один возможный алгоритм предоставления ресурсов отдает принтер процессу с 
  наименьшим файлом для печати (предполагается, что подобная информация доступна). 
  Такой подход максимизирует количество счастливых обслуженных клиентов и кажется 
  прекрасным. Теперь рассмотрим, что произойдет в сильно загруженной системе, 
  когда один из процессов должен распечатать огромный файл. Каждый раз, когда 
  принтер освобождается, система выбирает процесс с наиболее коротким файлом. 
  Если в системе есть постоянный поток процессов с небольшими файлами, принтер 
  никогда не будет предоставлен процессу с огромным файлом. Процесс просто &laquo;умрет 
  от голода&raquo; (будет отложен на неопределенный срок, несмотря на то, что 
  даже не будет заблокирован).<br>
<dd> &laquo;Голодания&raquo; можно избежать, если использовать стратегию распределения 
  ресурсов по принципу &laquo;первым пришел — первым обслужен&raquo;. При таком 
  подходе процесс, ожидающий дольше всех, обслуживается следующим. В итоге любой 
  процесс в некоторый момент станет самым старшим в очереди и, таким образом, 
  получит необходимый ресурс.<br>
</BODY>
</HTML>
