<html>
<head>
<title text="#000011">Динамические разделы</title>
</head>
<body> 
<CENTER>

<H1>Динамические разделы</H1>
<FONT SIZE="3">
</CENTER>
<UL>
 <LI><a href="#Объединение свободных участков памяти">Объединение соседних свободных участков памяти</a><
 <LI><a href="#Уплотнение памяти">Уплотнение памяти</a> 
 <LI><a href="#Размещение информации в памяти ">Стратегии размещения информации в памяти </a>
</UL>
<HR SIZE="4">
      Анализируя проблемы, присущие мультипрограммированию с фиксированными 
разделами, разработчики операционных систем пришли к выводу, что явно лучше 
было бы позволить заданиям занимать столько места(в пределах всей физической 
памяти), сколько им требуется. Не нужно соблюдать никаких фиксированных границ - 
напротив, заданиям требуется предоставлять столько памяти, сколько им необходимо.
Такой подход называется мультипрограммированием с переменными разделами. Начальное 
разделение памяти при мультипрограммировании с переменными разделами показано на
рисунке 1.2.<A HREF="../literatura.html">[4]</a>
<center>
<IMG SRC="nat7_10.jpg" border=0 align=center  vspace=15> </A>

<p>
	Рисунок 1.2 Начальное распределение разделов при мультипрограммировании с 
переменными разделами.
</center><p>
      При мультипрограммировании с переменными разделами мы не делаем никаких 
предположений относительно величины заданий(если не считать того, что задания не 
должны превышать размер имеющейся основной памяти компьютера). Заданиям, когда они 
поступают и если механизмы планирования решают, что их необходимо выполнять, выделяется
такой объем памяти, который они требуют. Здесь не происходит никакого "перерасхода" памяти - 
раздел каждого задания полностью соответствует размеру этого задания.
<p>
      Однако любая схема организации памяти сопряжена с определенными потерями. В случае
мультипрограммирования с переменными разделами эти потери становятся очевидными только
тогда, когда задания начинают завершаться, а в основной памяти остаются свободные участки,
или "дыры", как показано на рисунке 1.3.Эти участки можно использовать для размещения других
заданий, однако, даже если это происходит, то все равно остаются "дыры" только меньшего
размера. Таким образом, и в мультипрогаммировании с переменными разделами без потерь
памяти не обойтись.
<p>
<center>
<IMG SRC="nat7_11.jpg" border=0 align=center  vspace=15> </A>

<p>
	Рисунок 1.3 Образование "дыр" в памяти при мультипрограммировании
с переменными разделами.
</center><p>
<p>
<P> 
<H2><A NAME="Объединение свободных участков памяти">Объединение соседних свободных участков памяти</a></H2>
<P>

      Когда в мультипрограммной системе с переменными разделами некоторое задание завершается, 
мы можем проверить, не соседствует ли освобожденный участок памяти с другими свободными
участками ("дырами"). Если соседствует, то мы можем в список свободной памяти занести либо (1)
новый свободный участок, либо (2) едины йсвободный участок, полученный объединением новой 
дыры с соседними.
<p>
      Процесс объединения сосоедних "дыр" с образованием единого большого свободного
участка называется слиянием и иллюстрируется рисунком 1.4. Благодаря объединению дыр,
мы формируем непрерывные блоки памяти максимально возможного размера.
<center>
<IMG SRC="nat7_12.jpg" border=0 align=center  vspace=15> </A>

<p>
	Рисунок 1.4 Объединение "дыр" в памяти при мультипрограммировании
с переменными разделами.
</center><p>
<P> 
<H2><A NAME="Уплотнение памяти">Уплотнение памяти</a></H2>
<P>

      Часто даже после объединения соседних свободных участков бывает так, чо во всей
основной памяти остаются разбросанными отдельные "дыры", составляющие в целом значиельный
объем памяти. Иногда очередное задание требует определенного объема основной памяти,
но оказывается , что нет ни одного индивидуального свободного участка, достаточно 
большого для размещения этого задания, несмотря на то что сумма всех свободных участков
превышает общий объем требуемой памяти.
<p>
      Эта проблема решается при помощи метода, называемого уплотнением памяти(рисунок 1.5)
и состоящего в перемещении всех занятых участков к одному или другому краю основной памяти.
А уж если вся свободная память представлена одним участком, то ожидающее задание может 
выполняться, если ему требуется память, не превышающая размера этого единого, полученного 
в результате уплотнения уастка. Иногда уплотнение памяти образно называют "утряской памяти",
а среди программистов бытует термин "сбор мусора".
<center>
<IMG SRC="nat7_13.jpg" border=0 align=center  vspace=15> </A>

<p>
	Рисунок 1.5 Уплотнение памяти при мультипрограммировании с переменными
разделами.
</center><p>
<br>
      Уплотнение памяти имеет свои недостатки:
<UL>
<LI type=disc>Она отнимает ресурсы системы, которые можно бало бы использовать продуктивно.
<LI>Во время уплотнения памяти система должна прекращать любые другие работы. Результатом этого 
могут стать непрогнозируемые времена ответа для пользователей диалогового режима, и это
может оказаться непримлемым для систем реального времени.
<LI>Уплотнение предполагает перемещение заданий в памяти. Это означает, что информация,связанная
с размещением программы и обычно теряющаяся после загрузки программы, теперь должна
сохраняться в легкодоступной форме.
<LI>В типичном случае быстро меняющейся смеси заданий возникает необходимость частого 
уплотнения памяти. Затрачиваемые на это системные ресурсы могут не оправдываться 
получаемыми при этом выгодами.<A HREF="../literatura.html">[4]</a>
</UL>
<P> 
<H2><a name="Размещение информации в памяти">Стратегии размещения информации в памяти</a></A></H2>
<P>
Те или иные стратегии размещения информации в памяти применяются для того, чтобы определить,
в какое место основной памяти следует помещать поступающие программы и данные. В технической
литературе чаще всего описываются три стратегии..
<UL>
<LI type=disc><B>Стратегия наиболее подходящего.</B> Поступающее задание помещается в тот свободный
участок основной памяти, в котором ему наиболее "тесно", так что остается минимально возможное
неиспользуемое пространство. для многих людей выбор наиболее подходящего кажется интуитивно самой
рациональной стратегией.
<LI><B>Стратегия первого подходящего.</B>Поступающее задание помещается в первый встретившийся
свободный участок основной памяти достаточного размера. Выбор первого подходящего по размеру
свободного участка также кажется интуитивно рациональным, поскольку он позволяет быстро принять
решение о размещении задания.
<LI><B>Стратегия наименее подходящего.</B> На первый взгляд данный подход кажется весьма странным.
Однако более тщательное рассмотрение показыват, что выбор наименее подхоящего по размеру тоже
имеет сильные интуитивные аргументы в свою пользу. Этот принцип говорит о том, что при помещении 
программы в основную память нужно занимать свободный участок, имеющий наиболее далекий размер, т.е.
максимально возможный свободный участок. Интуитивный аргумент в пользу такого подхода достаточно
прост: после помещения программы в большой свободный участок остающийся свободный участок зачастую
также оказывается большим и, таким образом, в нем можно разместить относительно большую новую
программу.
</UL>
</html>