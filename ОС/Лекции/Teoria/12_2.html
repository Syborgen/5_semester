<HTML>
<HEAD>
<TITLE>Принципы аппаратуры ввода-вывода</TITLE>
</HEAD>
<BODY>
  <b><font size="6"><center>Принципы аппаратуры ввода-вывода</center></font></b><br>
  <br>
  Разные специалисты рассматривают аппаратуру ввода-вывода с различных точек зрения. 
  Инженеры-электронщики видят в них микросхемы, провода, источники питания, двигатели 
  и прочие физические компоненты, из которых и состоит аппаратура. Программисты 
  в первую очередь обращают внимание на интерфейс, предоставляемый программному 
  обеспечению, — команды, принимаемые аппаратурой, выполняемые ею функции и ошибки, 
  о которых аппаратура может сообщить. В этой книге нас интересует именно программирование 
  устройств ввода-вывода, а не их проектирование, построение или поддержка. Поэтому 
  сфера наших интересов будет ограничена тем, как программировать аппаратуру, 
  и в нее не входят физические принципы работы аппаратуры. В то же время программирование 
  многих устройств ввода-вывода часто оказывается тесно связанным с их внутренним 
  функционированием. В следующих трех разделах мы кратко предоставим общие основы 
  знаний из области аппаратуры ввода-вывода, касающиеся программирования. Этот 
  материал можно рассматривать в качестве обзорного и продолжения темы раздела 
  &laquo;Обзор аппаратного обеспечения компьютера&raquo; главы 1.<br>
  <br>
  <br>
<a NAME="01"></a>
  <b><font size="4">Устройства ввода-вывода</font></b><br>
  <br>
  Устройства ввода-вывода можно грубо разделить на две категории: блочные устройства 
  и символьные устройства. Блочными называются устройства, хранящие информацию 
  в виде блоков фиксированного размера, причем у каждого блока имеется адрес. 
  Обычно размеры блоков варьируются от 521 до 32 768 байт. Важное свойство блочного 
  устройства состоит в том, что каждый его блок может быть прочитан независимо 
  от остальных блоков. Наиболее распространенными блочными устройствами являются 
  диски.<br>
<dd> Если приглядеться внимательнее, то окажется, что граница между блок-адресуе-мыми 
  устройствами и устройствами, к отдельным блокам которых нельзя адресоваться 
  напрямую, не определена строго. Все согласны с тем, что диск является блок-адресуемым 
  устройством, так как вне зависимости от текущего положения головки дисковода 
  всегда можно переместить ее на определенный цилиндр и затем считать или записать 
  отдельный блок с нужной дорожки. Рассмотрим теперь накопитель на магнитной ленте 
  (магнитофон), применяемый для хранения резервных копий диска. На ленте хранится 
  последовательность блоков. Если магнитофону дать команду прочитать блок <i>N,</i> 
  он всегда может перемотать ленту и начать читать блоки, пока не дойдет до запрашиваемого 
  блока <i>N.</i> Эта операция подобна поиску блока на диске с той лишь разницей, 
  что она занимает значительно больше времени. Кроме того, в зависимости от накопителя 
  и формата хранящихся на нем данных, может оказаться возможной или невозможной 
  запись отдельного произвольного блока в середине ленты. Даже если и было бы 
  возможно использовать магнитные ленты в качестве блочных устройств произвольного 
  доступа, это являлось бы в какой-то степени натяжкой: никто их не использует 
  таким образом.<br>
<dd> Другой тип устройств ввода-вывода — символьные устройства. Символьное устройство 
  принимает или предоставляет поток символов без какой-либо блочной структуры. 
  Оно не является адресуемым и не выполняет операцию поиска. Принтеры, сетевые 
  интерфейсные карты, мыши (для указания точки на экране), крысы (для лабораторных 
  экспериментов по психологии) и большинство других устройств, не похожих на диски, 
  можно рассматривать как символьные устройства.<br>
<dd> Такая схема классификации не совершенна. Некоторые устройства просто не попадают 
  ни в одну из категорий. Например, часы не являются блок-адресуемы-ми. Они также 
  не формируют и не принимают символьных потоков. Вся их работа состоит в инициировании 
  прерываний в строго определенные моменты времени. Экраны отображения памяти 
  также не втискиваются в рамки этой модели. И все же модель блочных и символьных 
  устройств является настолько общей, что может использоваться в качестве основы 
  для достижения независимости от устройств некоторого программного обеспечения 
  операционных систем, имеющего дело с вводом-выводом. Например, файловая система 
  имеет дело с абстрактными блочными устройствами, а зависимую от устройств часть 
  составляет программному обеспечению низкого уровня.<br>
<dd> Устройства ввода-вывода покрывают огромный диапазон скоростей, что создает 
  определенные трудности для программного обеспечения, которому приходится обеспечивать 
  хорошую производительность на скоростях передачи данных, различающихся несколькими 
  порядками. В табл. 5.1 приведены скорости данных для некоторых часто встречающихся 
  устройств. Со временем у многих устройств появляются все более быстрые новые 
  модели.<br>
  <br>
  <center>
    <b><font face="Arial">Таблица 5.1.</font></b><font face="Arial"> Скорости 
    данных типичных устройств</font><br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="571" HEIGHT="517">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="center" VALIGN="center" WIDTH="337" HEIGHT="35"> 
          <p align="center"> <b> Устройство</b> </p>
        </TD>
        <TD ALIGN="center" VALIGN="center" WIDTH="155" HEIGHT="35"> 
          <p align="center"> <b> Скорость данных</b> </p>
        </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> Клавиатура </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 10 байт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> Мышь </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 100 байт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> Модем 56 К </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 7 Кбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> Телефонная линия 
        </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 8 Кбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> Двойная линия ISDN 
        </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 16 Кбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> Лазерный принтер 
        </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 100 Кбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> Сканер </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 400 Кбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> Классическая сеть 
          Ethernet </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 1,25 Мбайт/с 
        </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> Шина USB (Universal 
          Serial Bus) </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 1,5 Мбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> Цифровая видеокамера 
        </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 4 Мбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> IDE-диск </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 5 Мбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> 40х CD-ROM </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 6 Мбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> Быстрая сеть Ethernet 
        </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 12, 5 Мбайт/с 
        </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> Шина ISA </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 16,7 Мбайт/с 
        </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> IDE-диск (АТА-2) 
        </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 16, 7 Мбайт/с 
        </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="21"> FireWire (IEEE 
          1394) </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="21"> 50 Мбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="22"> XGA-монитор </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="22"> 60 Мбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="22"> Сеть SONET ОС- 
          12 </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="22"> 78 Мбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="22"> Диск SCSI Ultra 
          2 </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="22"> 80 Мбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="22"> Гигабитная сеть 
          Ethernet </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="22"> 125 Мбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="22"> Лента Ultrium </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="22"> 320 Мбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="22"> Шина PCI </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="22"> 528 Мбайт/с </TD>
      </TR>
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="337" HEIGHT="22"> Объединительная 
          плата Sun Gigaplane XB </TD>
        <TD ALIGN="center" VALIGN="TOP" WIDTH="155" HEIGHT="22"> 20 Гбайт/с </TD>
      </TR>
    </TABLE>
  </center>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Контроллеры устройств</font></b><br>
  <br>
  Устройства ввода-вывода обычно состоят из механической части и электронной части. 
  Часто эти части можно разделить для придания модели более модульного и общего 
  вида. Электронный компонент устройства называется контроллером устройства или 
  адаптером. В персональных компьютерах он часто принимает форму печатной платы, 
  вставляемой в слот расширения. Механический компонент находится в самом устройстве. 
  Такая организация показана на рис. 1.5.<br>
<dd> Плата контроллера обычно снабжается разъемом, к которому может быть подключен 
  кабель, ведущий к самому устройству. Многие контроллеры способны управлять двумя, 
  четырьмя или даже восемью идентичными устройствами. Еслиинтерфейс между контроллером 
  и устройством является стандартным, то есть официальным стандартом ANSI, IEEE 
  или ISO либо фактическим стандартом, тогда различные компании могут выпускать 
  отдельно контроллеры и устройства, удовлетворяющие данному интерфейсу. Так, 
  многие компании производят жесткие диски, соответствующие интерфейсу IDE или 
  SCSI.<br>
<dd> Интерфейс между устройством и контроллером часто является интерфейсом очень 
  низкого уровня. Например, какой-нибудь жесткий диск может быть отформатирован 
  по 256 секторов на дорожку, с размером секторов по 512 байт. В действительности 
  с диска в контроллер поступает последовательный поток битов, начинающийся с 
  заголовка сектора (преамбулы), за которым следует 4096 бит в секторе, и, наконец, 
  контрольная сумма, также называемая кодом исправления ошибок (ЕСС, Error-Correcting 
  Code). Заголовок сектора записывается на диск во время форматирования. Он содержит 
  номера цилиндра и сектора, размер сектора, информацию синхронизации и т. п.<br>
<dd> Работа контроллера заключается в конвертировании последовательного потока 
  битов в блок байтов и выполнение коррекции ошибок, если это необходимо. Обычно 
  байтовый блок собирается бит за битом в буфере контроллера. Затем проверяется 
  контрольная сумма блока, и если она совпадает с указанной в заголовке сектора, 
  блок объявляется считанным без ошибок, после чего он копируется в оперативную 
  память.<br>
<dd> Контроллер монитора (видеоадаптер) также работает как бит-последовательное 
  устройство, на таком же низком уровне. Он считывает в памяти байты, содержащие 
  символы, которые следует отобразить, и формирует сигналы, используемые для модуляции 
  луча электронной трубки, заставляющие ее выводить изображение на экран. Видеоадаптер 
  также формирует сигналы, управляющие горизонтальным и вертикальным возвратом 
  электронного луча. Если бы ни контроллер, программисту пришлось бы управлять 
  перемещениями аналогового электронного луча. В действительности же операционная 
  система всего лишь инициализирует контроллер, задавая небольшое число параметров, 
  таких как количество символов или пикселов в строке и число строк на экране, 
  а всю тяжелую работу по управлению передвижениями электронного луча по экрану 
  выполняет контроллер.<br>
  <br>
  <br>
<a NAME="03"></a>
  <b><font size="4">Отображаемый на адресное пространство памяти ввод-вывод</font></b><br>
  <br>
  У каждого контроллера есть несколько регистров, с помощью которых с ним может 
  общаться центральный процессор. При помощи записи в эти регистры операционная 
  система велит устройству предоставить данные, принять данные, включиться или 
  выключиться и т. п. Читая из этих регистров, операционная система может узнать 
  состояние устройства, например готово ли оно к приему новой команды и т. д.<br>
<dd> Помимо управляющих регистров, у многих устройств есть буфер данных, из которого 
  операционная система может читать данные, а также писать данные в него. Например, 
  для отображения пикселов на экране данные обычно помещаются в видеопамять, являющуюся, 
  по сути, буфером данных, доступным операционной системе и другим программам 
  для чтения и записи.<br>
<dd> Существует два альтернативных способа реализации доступа к управляющим регистрам 
  и буферам данных устройств ввода-вывода. Первый вариант заключается в том, что 
  каждому управляющему регистру назначается номер <b>порта ввода-вывода,</b> 8- 
  или 16-разрядное целое число. При помощи такой специальной команды процессора, 
  как<br>
  <br>
<dd> <font face="Arial">IN REG,PORT</font><br>
  <br>
<dd> центральный процессор может прочитать управляющий регистр устройства из порта 
  PORT в регистр процессора REG. Аналогично с помощью команды<br>
  <br>
<dd> <font face="Arial">OUT PORT,REG</font><br>
  <br>
<dd> центральный процессор может записать содержимое своего регистра REG в управляющий 
  регистр устройства через порт PORT. Подобным образом работали самые древние 
  компьютеры, включая почти все мэйнфреймы, такие как IBM 360 и его преемники.<br>
<dd> При такой схеме адресные пространства оперативной памяти и устройств ввода-вывода 
  не пересекаются, как видно из рис. 5.1, <i>а.</i> Команды<br>
  <br>
<dd> <font face="Arial">IN R0,4</font><br>
  <br>
<dd> И<br>
  <br>
<dd> <font face="Arial">MOV R0,4</font><br>
  <br>
<dd> выполняют принципиально различные действия. Первая команда читает содержимое 
  порта ввода-вывода 4 в регистр R0, тогда как вторая читает в этот же регистр 
  содержимое слова памяти по адресу 4. Таким образом, четверки в этих командах 
  означают различные адреса из непересекающихся адресных пространств.<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_1.jpg" alt="Раздельные адресные пространства (а); отображаемый на адресное пространство памяти ввод-вывод (б); гибрид (в)"><br>
    <br>
    <b><font face="Arial">Рис. 5.1.</font></b><font face="Arial"> Раздельные адресные 
    пространства (а); отображаемый на адресное пространство<br>
    памяти ввод-вывод (б); гибрид (в)<br>
    </font><br>
  </center>
<dd> Второй подход, впервые реализованный в компьютере PDP-11, состоял в отображении 
  всех управляющих регистров периферийных устройств на адресное пространство памяти, 
  как показано на рис. <i>5.1, б</i>. Каждому управляющему регистру назначался 
  уникальный адрес в памяти. Такая система называется <b>отображаемым на адресное 
  пространство памяти вводом-выводом</b>. Обычно для регистров устройств отводятся 
  адреса на вершине адресного пространства. Также существуют различные гибридные 
  схемы, с отображаемыми на адресное пространство памяти буферами данных и отдельными 
  портами ввода-вывода (рис. 5.1, в). Эта схема довольно широко применяется, например, 
  в совместимых с IBM PC компьютерах на базе процессоров х86 и Pentium, в которых, 
  помимо портов ввода-вывода с номерами от 0 до 64 К, адресное пространство оперативной 
  памяти от 640 К до 1 М зарезервировано под буферы данных устройств ввода-вывода.<br>
<dd> Как работают все эти схемы? Во всех случаях, когда центральный процессор 
  хочет прочитать слово данных либо из памяти, либо из порта ввода-вывода, он 
  выставляет нужный адрес на адресную шину, после чего выставляет сигнал READ 
  на управляющую шину. Вторая сигнальная линия позволяет отличить обращение к 
  памяти от обращения к порту. В зависимости от состояния этой линии шины управления 
  на запрос процессора реагирует устройство (контроллер) ввода-вывода или память. 
  Если пространство адресов общее (как на рис. <i>5.1, б</i>), то каждый модуль 
  памяти и каждое устройство ввода-вывода сравнивает выставленный на шину адрес 
  с обслуживаемым им диапазоном адресов. Если выставленный на шину адрес попадает 
  в этот диапазон, то соответствующе устройство реагирует на запрос процессора. 
  Поскольку выделенные внешним устройствам адреса удаляются из памяти, память 
  не реагирует на них и конфликта адресов не происходит.<br>
<dd> Обе схемы обращения к контроллерам имеют свои сильные и слабые стороны. Начнем 
  с достоинств отображаемого на адресное пространство памяти ввода-вывода. Во-первых, 
  при такой схеме для обращения к устройствам ввода-вывода не требуются специальные 
  команды процессора, такие как IN и OUT. В результате программу, общающуюся с 
  таким устройством, можно написать целиком на языке С или C++, без вставок на 
  ассемблере или обращений к подпрограммам, написанным на ассемблере, то есть 
  без дополнительных накладных расходов.<br>
<dd> Во-вторых, при отображении регистров ввода-вывода на память не требуется 
  специального механизма защиты от пользовательских процессов, пытающихся обращаться 
  к внешним устройствам. Все, что нужно сделать операционной системе, — это исключить 
  ту часть адресного пространства, на которую отображаются управляющие регистры 
  устройств ввода-вывода из адресного пространства пользователей. Более того, 
  если управляющие регистры различных устройств ввода-вывода отображаются на различные 
  страницы памяти, операционная система может предоставить доступ к различным 
  страницам различным пользователям, таким образом предоставляя пользователям 
  доступ к одним устройствам и запрещая доступ к другим. Для этого нужно всего 
  лишь включить номер соответствующей страницы памяти в карту памяти нужного пользователя. 
  В результате такая схема позволяет разместить драйверы различных устройств в 
  различных адресных пространствах, тем самым не только уменьшая размер ядра, 
  но и удерживая драйверы от вмешательства в дела друг друга.<br>
<dd> В-третьих, при отображении регистров ввода-вывода на память каждая команда 
  процессора, обращающаяся к памяти, может с тем же успехом обращаться к управляющим 
  регистрам устройства. Например, если у процессора есть в наборе команд инструкция 
  TEST, проверяющая содержимое некоего слова в памяти на равенство 0, она может 
  с тем же успехом применяться и при обращении к управляющему регистру устройства 
  ввода-вывода. Управляющий регистр, равный 0, будет означать, например, готовность 
  данного устройства к приему новой команды. Программа на ассемблере может выглядеть 
  следующим образом:<br>
  <br>
<font face="Arial"> 
<dd> LOOP: TEST PORT_4 // сравнить содержимое порта 4 с нулем<br>
<dd> BEQ READY // если он равен 0, идти на метку READY<br>
<dd> BRANCH LOOP // в противном случае продолжать опрос порта<br>
</font> 
<dd><font face="Arial"> READY:<br>
  </font><br>
<dd> Если отображения регистров ввода-вывода на память нет, управляющий регистр 
  устройства должен быть сначала считан в регистр процессора, а уже затем сравнен 
  с 0, что требует двух команд процессора вместо одной. Для приведенного выше 
  цикла добавление четвертой команды может слегка снизить (все зависит от конкретных 
  процессоров, конечно) скорость реакции драйвера на появление признака готовности 
  устройства.<br>
<dd> В разработке компьютеров практически у любого решения есть как положительные, 
  так и отрицательные стороны. Отображение регистров ввода-вывода на память также 
  обладает недостатками. Во-первых, в большинстве современных компьютеров применяется 
  кэширование памяти. Кэширование управляющих регистров привело бы просто к катастрофе. 
  Поясним это утверждение на уже приведенном выше примере программы, опрашивающей 
  в цикле порт PORT_4. При первом обращении к этому порту считалось бы верное 
  значение порта, но это значение сохранилось бы в кэше. Все последующие обращения 
  к порту PORT_4 на следующих итерациях цикла просто читали бы значение, сохраненное 
  в кэше, и никогда не обращались бы к реальному устройству. Таким образом, программа 
  никогда не вышла бы из цикла ожидания готовности, так как при кэшировании регистров 
  устройств она просто не смогла бы узнать об изменении управляющего регистра.<br>
<dd> Чтобы не допустить такой ситуации, необходима специальная аппаратура, способная 
  выборочно запрещать кэширование, например, в зависимости от номера страницы 
  памяти, к которой обращается процессор. Таким образом, отображение регистров 
  ввода-вывода на память увеличивает сложность аппаратуры и операционной системы, 
  которой приходится управлять избирательным кэшированием.<br>
<dd> Во-вторых, при едином адресном пространстве все модули памяти и все устройства 
  ввода-вывода должны изучать все обращения процессора к памяти, чтобы определить, 
  на которые им следует реагировать. Если у компьютера одна общая шина (рис 5.2, 
  <i>а</i>), реализовать подобный просмотр всех обращений к памяти всеми устройствами 
  несложно.<br>
<dd> Однако в конструкции современных персональных компьютеров наблюдается тенденция 
  в сторону использования выделенной высокоскоростной шины (рис 5.2, <i>б</i>), 
  архитектурной особенности, кстати, уже давно применявшейся в мэйнфреймах. Эта 
  шина предназначена для увеличения скорости обмена данными между процессором 
  и памятью, чему в архитектуре общей шины сильно мешали медленные устройства 
  ввода-вывода. В компьютерах на базе процессора Pentium таких внешних шин целых 
  три (шина памяти, PCI и ISA), как было показано на рис. 1.11.<br>
<dd> Сложность применения выделенной шины памяти на машинах с отображением регистров 
  ввода-вывода на память состоит в том, что у устройств ввода-вывода нет способа 
  увидеть адреса памяти, выставляемые процессором на эту шину, следовательно, 
  они не могут реагировать на такие адреса. Поэтому, чтобы отображение регистров 
  ввода-вывода могло работать на системах с несколькими шинами, необходимы специальные 
  меры. Один способ решения этой проблемы состоит в том, что сначала все обращения 
  к памяти посылаются процессором по выделенной быстрой шине напрямую памяти (чтобы 
  не снижать производительности). Если память не может ответить на эти запросы, 
  процессор пытается сделать это еще раз по другим шинам. Такое решение работоспособно, 
  но требует дополнительного увеличения сложности аппаратуры.<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_2.jpg" alt="Архитектура с одной шиной (а); архитектура памяти с двумя шинами (б)"> 
    <br>
    <br>
    <b><font face="Arial">Рис. 5.2.</font></b><font face="Arial"> Архитектура 
    с одной шиной (а); архитектура памяти с двумя шинами (б)</font><br>
    <br>
  </center>
<dd> Второе возможное решение заключается в установке на шину памяти специального 
  следящего устройства, передающего все адреса потенциально заинтересованным устройствам 
  ввода-вывода. Проблема, однако, в том, что устройства ввода-вывода могут просто 
  не успеть обработать эти запросы с той же скоростью, что и память.<br>
<dd> Третье решение, используемое в компьютерах на базе процессора Pentium (рис. 
  1.11), состоит в фильтрации адресов микросхемой моста PCI. Эта микросхема содержит 
  регистры диапазона, заполняемые во время загрузки компьютера. Например, диапазон 
  адресов от 640 К до 1 М может быть помечен как не относящийся к памяти. Все 
  адреса, попадающие в подобный диапазон, передаются не памяти, а на шину PCI. 
  Недостаток этой схемы состоит в необходимости принятия во время загрузки решения 
  о том, какие адреса не являются адресами памяти. Итак, у каждой схемы есть свои 
  достоинства и недостатки, так что компромиссы и уступки неизбежны.<br>
  <br>
  <br>
<a NAME="04"></a>
  <b><font size="4">Прямой доступ к памяти (DMA)</font></b><br>
  <br>
  Независимо от того, отображаются ли регистры или буферы ввода-вывода на память 
  или нет, центральному процессору необходимо как-то адресоваться к контроллерам 
  устройств для обмена данными с ними. Центральный процессор может запрашивать 
  данные от контроллера ввода-вывода по одному байту, но подобная организация 
  обмена данными крайне неэффективна, так как расходует огромное количество процессорного 
  времени. Поэтому на практике часто применяется другая схема, называемая прямым 
  доступом к памяти (DMA, direct memory access).<br>
<dd> Операционная система может воспользоваться прямым доступом к памяти только 
  при наличии аппаратного DMA-контроллера, который есть у большинства систем. 
  Иногда DMA-контроллер интегрируется в другие контроллеры, например в дисковый 
  контроллер, но такой дизайн требует оснащения DMA-контроллерами каждого периферийного 
  устройства. Как правило, DMA-контроллер, устанавливаемый на материнской плате, 
  обслуживает запросы по передаче данных нескольких различных устройств ввода-вывода, 
  часто на конкурентной основе.<br>
<dd> Где бы он ни располагался физически, DMA-контроллер может получать доступ 
  к системной шине независимо от центрального процессора, как показано на рис. 
  5.3. Он содержит несколько регистров, доступных центральному процессору для 
  чтения и записи. К ним относятся регистр адреса памяти, счетчик байтов и один 
  или более управляющих регистров. Управляющие регистры задают, какой порт ввода-вывода 
  должен быть использован, направление переноса данных (чтение из устройства ввода-вывода 
  или запись в него), единицу переноса (осуществлять перенос данных побайтно или 
  пословно), а также число байтов, которые следует перенести за одну операцию.<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_3.jpg" alt="Работа DMA-контроллера"><br>
    <br>
    <b><font face="Arial">Рис. 5.3.</font></b><font face="Arial"> Работа DMA-контроллера</font><br>
    <br>
  </center>
<dd> Чтобы понять, как работает DMA, познакомимся сначала с тем, как происходит 
  чтение с диска при отсутствии DMA. Сначала контроллер считывает с диска блок 
  (один или несколько секторов) последовательно, бит за битом, пока весь блок 
  не окажется во внутреннем буфере контроллера. Затем контроллер проверяет контрольную 
  сумму, чтобы убедиться, что при чтении не произошло ошибки. После этого контроллер 
  инициирует прерывание. Когда операционная система начинает работу, она может 
  прочитать блок диска побайтно или пословно, в цикле сохраняя считанное слово 
  или байт в оперативной памяти.<br>
<dd> При использовании DMA процедура совершенно другая. Сначала центральный процессор 
  программирует DMA-котроллер, устанавливая его регистры и указывая таким образом, 
  какие данные и куда следует переместить (шаг <i>1</i> на рис. 5.3).<br>
<dd> Затем процессор дает команду дисковому контроллеру прочитать данные во внутренний 
  буфер и проверить контрольную сумму. Когда данные получены и проверены контроллером 
  диска, DMA может начинать работу.<br>
<dd> DMA-контроллер начинает перенос данных, посылая дисковому контроллеру по 
  шине запрос чтения (шаг 2). Этот запрос чтения выглядит как обычный запрос чтения, 
  так что контроллер диска даже не знает, пришел ли он от центрального процессора 
  или от контроллера DMA. Обычно адрес памяти уже находится на адресной шине, 
  так что контроллер диска всегда знает, куда следует переслать следующее слово 
  из своего внутреннего буфера. Запись в память является еще одним стандартным 
  циклом шины (шаг <i>3).</i> Когда запись закончена, контроллер диска также по 
  шине посылает сигнал подтверждения контроллеру DMA (шаг <i>4).</i> Затем контроллер 
  DMA увеличивает используемый адрес памяти и уменьшает значение счетчика байтов. 
  После этого шаги со 2-го по <i>4-й</i> повторяются, пока значение счетчика не 
  станет равно нулю. По завершении цикла копирования контроллер DMA инициирует 
  прерывание процессора, сообщая ему таким образом, что перенос данных завершен. 
  Операционной системе не нужно копировать блок диска в память. Он уже находится 
  там.<br>
<dd> Контроллеры DMA значительно различаются по степени своей сложности. Самые 
  простые из них за один раз выполняют одну операцию переноса данных, как описывалось 
  выше. Более сложные контроллеры могут выполнять сразу несколько подобных операций. 
  У таких контроллеров несколько каналов, каждый из которых управляется своим 
  набором внутренних регистров. Центральный процессор начинает с того, что загружает 
  в эти регистры соответствующие параметры. Все операции переноса данных должны 
  выполняться с различными устройствами ввода-вывода. После переноса каждого слова 
  данных (шаги <i>2-4</i> на рис. 5.3) контроллер DMA решает, какое устройство 
  будет им обслужено следующим. Этот выбор может производиться циклически или 
  при помощи приоритетной схемы, предоставляющей одним устройствам преимущество 
  по сравнению с другими. Одновременно несколько запросов могут дожидаться исполнения, 
  при условии, что существует способ однозначно отличить подтверждения различных 
  устройств. Часто с этой целью для каждого канала DMA используются различные 
  линии подтверждения.<br>
<dd> Многие шины могут работать в двух режимах: в пословном и поблочном. Некоторые 
  контроллеры DMA также могут функционировать в обоих режимах. В пословном режиме 
  процедура выглядит так, как описывалось выше: контроллер DMA выставляет запрос 
  на перенос одного слова и получает его. Если центральному процессору также нужна 
  эта шина, ему приходится подождать. Этот механизм называется захватом цикла 
  (cycle stealing), потому что контроллер устройства периодически &laquo;подкрадывается&raquo; 
  и забирает случайный цикл шины у центрального процессора, слегка его тормозя. 
  В блочном режиме контроллер DMA велит устройству занять шину, сделать серию 
  пересылок и отпустить шину. Такой способ действий называется пакетным режимом. 
  Он более эффективен, чем захват цикла, поскольку занятие шины требует времени, 
  а в пакетном режиме эта процедура выполняется всего один раз для передачи целого 
  блока данных. Недостатком этого метода является то, что при переносе большого 
  блока данных он может заблокировать центральный процессор и другие устройства 
  на существенный промежуток времени.<br>
<dd> В обсуждавшейся нами модели, иногда называемой <b>сквозным режимом,</b> контроллер 
  DMA велит контроллеру устройства переслать данные напрямую в оперативную память. 
  В некоторых DMA-контроллерах используется также режим, при котором контроллер 
  устройства посылает слово данных контроллеру DMA, который затем выставляет на 
  шину еще один запрос для передачи этого слова туда, куда его нужно передать. 
  При такой схеме требуется лишний цикл шины на передачу каждого слова, зато такая 
  схема обладает большей гибкостью, так как также позволяет выполнять копирование 
  с устройства на устройство, минуя память, и даже из памяти в память. (Для этого 
  нужно сначала дать команду чтения из памяти, а затем команду записи в память, 
  но по другому адресу.)<br>
<dd> Большинство контроллеров DMA используют для передачи данных физические адреса 
  памяти. Чтобы использовать физические адреса памяти, операционная система должна 
  преобразовать виртуальный адрес буфера памяти в физический и записать этот физический 
  адрес в адресный регистр контроллера DMA. В некоторых контроллерах DMA применяется 
  альтернативная схема, при которой в контроллер DMA записывается сразу виртуальный 
  адрес. В этом случае контроллер DMA должен использовать менеджер памяти MMU 
  для преобразования адреса. Виртуальный адрес может быть выставлен на адресную 
  шину только в том случае, когда MMU является частью памяти (что возможно, но 
  редко), а не частью центрального процессора.<br>
<dd> Как мы уже упоминали, до начала операции DMA диск сначала считывает данные 
  в свой внутренний буфер. Возможно, вы задаетесь вопросом, почему контроллер 
  не помещает данные прямо в оперативную память, по мере получения их с диска. 
  Другими словами, зачем ему нужен внутренний буфер? Тому есть две причины. Во-первых, 
  при помощи внутренней буферизации контроллер диска может проверить контрольную 
  сумму до начала переноса данных в память. Если контрольные суммы не совпадают, 
  формируется сигнал об ошибке и перенос данных не производится.<br>
<dd> Во-вторых, дело в том, что как только началась операция чтения с диска, биты 
  начинают поступать с постоянной скоростью, независимо от того, готов контроллер 
  диска их принимать или нет. Если контроллер диска попытается писать эти данные 
  напрямую в память, ему придется делать это по системной шине. Если при передаче 
  очередного слова шина окажется занятой каким-либо другим устройством (например, 
  использующим ее в пакетном режиме), контроллеру диска придется ждать. Если следующее 
  слово с диска прибудет раньше, чем контроллер успеет сохранить предыдущее, контроллер 
  либо потеряет предыдущее слово, либо ему придется сохранять его где-либо еще. 
  Таким образом, необходимость внутреннего буферирования становится очевидной. 
  При наличии внутреннего буфера контроллеру диска шина не нужна до тех пор, пока 
  не начнется операция DMA. В результате устройство контроллера диска оказывается 
  проще, так как при операции DMA пересылки данных параметр времени не является 
  критичным. (Некоторые древние контроллеры действительно напрямую обращались 
  к памяти, обладая внутренним буфером небольшого размера, что часто приводило 
  к ошибкам перегрузки при занятости шины.)<br>
<dd> DMA используется не во всех компьютерах. Главный аргумент против использования 
  DMA состоит в том, что центральный процессор обычно значительно превосходит 
  DMA-контроллер по скорости и может выполнить ту же работу значительно быстрее 
  (если только скорость ограничена не быстродействием устройства ввода-вывода). 
  При отсутствии другой работы у центрального процессора заставлять быстрый центральный 
  процессор ждать, пока медленный контроллер DMA выполнит свою работу, бессмысленно. 
  Кроме того, компьютер без контроллера DMA, с центральным процессором, выполняющим 
  всю работу программно, оказывается дешевле, что крайне важно в производстве 
  компьютеров нижней ценовой категории (например, встроенных).<br>
  <br>
  <br>
<a NAME="05"></a>
  <b><font size="4">Еще раз о прерываниях</font></b><br>
  <br>
  Мы кратко упомянули прерывания в разделе &laquo;Устройства ввода-вывода&raquo; 
  главы 1, но о них следует сказать еще несколько слов. Структура прерываний типичной 
  персональной компьютерной системы проиллюстрирована на рис. 5.4. На аппаратном 
  уровне прерывания работают следующим образом. Когда устройство ввода-вывода 
  заканчивает свою работу, оно инициирует прерывание (при условии, что прерывания 
  разрешены операционной системой). Для этого устройство выставляет сигнал на 
  выделенную устройству специальную линию шины. Этот сигнал распознается микросхемой 
  контроллера прерываний, расположенной на материнской плате. Контроллер прерываний 
  принимает решение о дальнейших действиях.<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_4.jpg" alt="Схема прерываний в компьютере"> 
    <br>
    <br>
    <font face="Arial"><b>Рис. 5.4.</b> Схема прерываний в компьютере. Соединения 
    между устройствами<br>
    и контроллером прерываний в действительности являются специальными линиями 
    шины, а не выделенными проводами<br>
    </font> <br>
  </center>
<dd> При отсутствии других необработанных запросов прерывания контроллер прерываний 
  обрабатывает прерывание немедленно. Если прерывание уже обрабатывается, и в 
  это время приходит запрос от другого устройства по линии с более низким приоритетом, 
  то новый запрос просто игнорируется. В этом случае устройство продолжает удерживать 
  сигнал прерывания на шине до тех пор, пока оно не будет обслужено центральным 
  процессором.<br>
<dd> Для обработки прерывания контроллер выставляет на адресную шину номер устройства, 
  требующего к себе внимания, и устанавливает сигнал прерывания на соответствующий 
  контакт процессора.<br>
<dd> Этот сигнал заставляет процессор приостановить текущую работу и начать выполнять 
  обработку прерывания. Номер, выставленный на адресную шину, используется в качестве 
  индекса в таблице, называемой вектором прерываний, из которой извлекается новое 
  значение счетчика команд. Новый счетчик команд указывает на начало соответствующей 
  процедуры обработки прерывания. Обычно с этого места аппаратные и эмулированные 
  прерывания используют один и тот же механизм и часто пользуются одним и тем 
  же вектором. Расположение вектора может быть либо жестко прошито на аппаратном 
  уровне, либо, наоборот, располагаться в произвольном месте памяти, на которое 
  указывает специальный регистр процессора, загружаемый операционной системой.<br>
<dd> Вскоре после начала своей работы процедура обработки прерываний подтверждает 
  получение прерывания, записывая определенное значение в порт контроллера прерываний. 
  Это подтверждение разрешает контроллеру издавать новые прерывания. Благодаря 
  тому, что центральный процессор откладывает выдачу подтверждения до момента, 
  когда он уже готов к обработке нового прерывания, удается избежать ситуации 
  состязаний при появлении почти одновременных прерываний от нескольких устройств. 
  Следует упомянуть, что на некоторых старых компьютерах нет микросхемы, централизованного 
  контроллера прерываний, поэтому контроллер каждого устройства выставляет свое 
  собственное прерывание.<br>
<dd> Аппаратура всегда, прежде чем начать процедуру обработки прерывания, сохраняет 
  определенную информацию. Сохраняемая информация и место ее хранения широко варьируются 
  в зависимости от центрального процессора. Как минимум сохраняется счетчик команд, 
  что позволяет продолжить выполнение прерванного процесса. Другая крайность представляет 
  собой сохранение всех программно доступных регистров и большого количества внутренних 
  регистров центрального процессора.<br>
<dd> Место сохранения этой информации также оказывается проблемой. Один из вариантов 
  состоит в том, чтобы сохранять эти данные в неких внутренних регистрах, доступных 
  операционной системе. Недостаток такого подхода — до тех пор, пока вся сохраненная 
  информация не будет считана обработчиком прерываний, новые прерывания будет 
  нельзя разрешать. В противном случае любое новое прерывание просто стерло бы 
  всю сохраненную таким образом информацию, записав поверх нее новые данные. В 
  результате прерывания оказываются запрещенными в течение довольно длительных 
  интервалов времени, что приводит к возможному игнорированию некоторых сигналов 
  прерывания от устройств и, соответственно, к возможной потере данных.<br>
<dd> Поэтому большинство центральных процессоров сохраняют информацию в стеке. 
  Однако у этого подхода также имеются недостатки. Во-первых, в чьем стеке следует 
  сохранять данные? Если использовать текущий стек, он может оказаться стеком 
  процесса пользователя. При этом может даже выясниться, что пользователь использует 
  указатель стека в своей программе весьма нестандартно, то есть стек может указывать 
  на область памяти, в которой нельзя сохранять данные. Попытка записать несколько 
  слов в стек в таком случае может привести к неисправимой ошибке. Также указатель 
  стека может указывать на конец страницы памяти. После нескольких обращений к 
  стеку указатель может достичь конца страницы памяти и вызвать соответствующую 
  ошибку. Если во время обработки аппаратного прерывания произойдет обращение 
  к отсутствующей странице, это станет еще большей проблемой: где сохранить состояние 
  процедуры обработки прерывания для обработки данной ошибки?<br>
<dd> Использовать стек ядра гораздо проще, так как при этом больше шансов, что 
  указатель стека указывает на область памяти, в которой можно сохранять данные. 
  Однако переключение в режим ядра может потребовать изменения контекста MMU и, 
  возможно, обесценит большую часть содержимого кэша и TLB (Translation Lookaside 
  Buffer — буфер быстрого преобразования адреса). Перегрузка всех этих кэшей статически 
  или динамически увеличит время обработки прерывания и вызовет растрату процессорного 
  времени.<br>
<dd> Другая проблема вызвана тем фактом, что большинство современных центральных 
  процессоров широко используют конвейеры и часто являются суперскалярными (внутренне 
  параллельными). В более старых системах после выполнения каждой команды процессора 
  микропрограмма или аппаратура проверяли, нет ли прерывания, ждущего обработки. 
  Если таковое было, счетчик команд и слово состояния процессора (PSW) сохранялись 
  в стеке и начиналась обработка прерывания. По завершении работы обработчика 
  прерывания происходила обратная процедура: старые значения PSW и счетчика команд 
  извлекались из стека, и прерванный процесс возобновлялся.<br>
<dd> Такая модель явно предполагает, что к приходу прерывания все команды процессора 
  до этого момента выполнены полностью и ни одна команда процессора после последней 
  выполненной команды не начала выполняться. На старых машинах такое предположение 
  было оправдано. Однако на современных компьютерах это не всегда так.<br>
<dd> Для начала рассмотрим модель конвейера на рис. 1.6, <i>а.</i> Что произойдет, 
  если прерывание придет, когда конвейер полон (вполне обычный случай)? Различные 
  команды окажутся на разных стадиях выполнения. К приходу прерывания значение 
  счетчика команд может не отражать истинной границы между уже выполненными и 
  еще не выполненными командами. Скорее всего, он будет указывать на адрес очередной 
  команды, которую следует выбрать из памяти и поместить в конвейер, а не на адрес 
  команды, только что обработанной исполнительным блоком.<br>
<dd> В результате даже при наличии строго очерченной границы между уже выполненными 
  и еще не выполненными командами может оказаться, что аппаратура просто не знает, 
  где она проходит. Соответственно, при возврате из прерывания операционная система 
  не может просто начать заполнять конвейер с адреса, содержащегося в счетчике 
  команд. Она должна сначала узнать, какая команда была выполнена последней, что 
  часто является довольно сложной задачей, требующей серьезного анализа состояния 
  процессора.<br>
<dd> Хотя эта ситуация и неприятна, однако прерывания на суперскалярной машине 
  (рис. 1.6, <i>б</i>) значительно хуже. Поскольку команды процессора могут выполняться 
  не в порядке их расположения в памяти, строго очерченной границы между уже выполненными 
  и еще не выполненными командами может вообще не оказаться. Может, например, 
  случиться, что команды 1, 2, 3, 5 и 8 уже выполнены, а команды 4, 6, 7, 9 и 
  10 — еще нет. Более того, счетчик команд теперь может указывать, например, на 
  команды 9, 10 или 11.<br>
<dd> Прерывание, оставляющее машину в строго определенном состоянии, называется 
  точным прерыванием [353]. У такого прерывания четыре следующих свойства:<br>
  <br>
<dd> 1. Счетчик команд (PC, Program Counter) сохраняется в известном месте.<br>
<dd> 2. Все команды до той, на которую указывает счетчик команд, выполнены полностью.<br>
<dd> 3. Ни одна команда после той, на которую указывает счетчик команд, не была 
  выполнена.<br>
<dd> 4. Состояние команды, на которую указывает счетчик команд, известно.<br>
  <br>
<dd> Обратите внимание, что здесь не накладывается запрета на начало выполнения 
  команд после той, на которую указывает счетчик команд. Утверждается лишь, что 
  все изменения с памятью и регистрами процессора, произведенные благодаря началу 
  выполнения этих инструкций, должны быть отменены прежде, чем начнется обработка 
  сигнала прерывания процессором. Разрешается выполнение команды, на которую указывает 
  счетчик команд. Также допускается ее невыполнение. Однако должно быть известно, 
  выполнена она или нет. Часто случается, если прерывание пришло от устройства 
  ввода-вывода, что выполнение команды, на которую указывает счетчик команд, еще 
  и не начиналось. Однако если прерывание было эмулировано или вызвано обращением 
  к отсутствующей странице, тогда счетчик команд обычно указывает на команду, 
  вызвавшую прерывание.<br>
<dd> Прерывание, не удовлетворяющее данным требованиям, называется неточным прерыванием. 
  Такое прерывание крайне портит жизнь программистам, пишущим операционную систему, 
  которым приходится в таком случае выяснять, что случилось и чему еще предстоит 
  случиться. Машины с неточным прерыванием обычно в случае прерывания выгружают 
  в стек огромное количество данных, чтобы дать операционной системе возможность 
  определить, что происходило в этот момент. Сохранение больших объемов данных 
  в памяти при каждом прерывании сильно замедляет вход в процедуру обработки прерывания, 
  а восстановление после прерывания усложняется еще больше. Все это приводит к 
  нелепой ситуации, в которой сверхбыстрый суперскалярный центральный процессор 
  оказывается непригоден для задач реального времени из-за своих страшно медленных 
  прерываний.<br>
<dd> Некоторые компьютеры спроектированы таким образом, что одни типы прерываний 
  (аппаратных и эмулированных) оказываются точными, тогда как другие — неточными. 
  Например, совсем не плохо, если прерывания от устройств ввода-вывода будут точными, 
  а эмулированные прерывания и прерывания, вызванные программными ошибками, будут 
  неточными, так как последние не требуют возобновления прерванных процессов. 
  В некоторых машинах имеется специальный бит, установив который можно все прерывания 
  сделать точными. Недостатком установки такого бита является то, что он вынуждает 
  процессор тщательно регистрировать свои действия и сохранять значения регистров 
  в специальных теневых регистрах, обеспечивая, таким образом, возможность произвести 
  точное прерывание в любой момент времени. Естественно, все эти накладные расходы 
  заметно снижают производительность.<br>
<dd> Некоторые суперскалярные процессоры, такие как Pentium Pro и все его преемники, 
  поддерживают точные прерывания для корректной работы на них программ, написанных 
  для старых процессоров 386, 486 и Pentium I. (Первым суперскалярным процессором 
  серии Intel x86 был процессор Pentium Pro; у процессора Pentium I было просто 
  два конвейера.) Ценой за точные прерывания оказывается крайне сложная внутрипроцессорная 
  логика прерываний. Эта логика должна гарантировать, что в случае прихода сигнала 
  прерывания от контроллера прерываний все команды вплоть до определенной точки 
  могли быть завершены и ни одна команда после последней выполненной не должна 
  была оказать заметного эффекта на состояние машины. В данном случае ценой, которую 
  приходилось платить за возможность точных прерываний на суперскалярном процессоре, 
  являлось не время обработки прерывания, а сложность самого процессора и его 
  разработки. Если бы можно было отказаться от необходимости поддержки точных 
  прерываний, что делалось для обратной совместимости, сэкономленное место на 
  кристалле можно было бы отдать под кэш, а это ускорило бы процессор. С другой 
  стороны, наличие неточных прерываний значительно усложняет и замедляет операционную 
  систему, так что трудно сказать, какой подход на самом деле лучше.<br>
</BODY>
</HTML>
