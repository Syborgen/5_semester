<HTML>
<HEAD>
<TITLE>Каталоги</TITLE>
</HEAD>
<BODY>
<CENTER>
<H1>Каталоги</H1>
<FONT SIZE="3">
</CENTER>
  <br>
  В файловых системах файлы обычно организуются в <b>каталоги или папки,</b> которые, 
  в свою очередь, в большинстве операционных систем также являются файлами. В 
  данном разделе мы рассмотрим каталоги, их организацию, свойства и действия, 
  которые могут быть выполнены с ними.<br>
  <br>
  <br>
<a NAME="01"></a>
  <b><font size="4">Одноуровневые каталоговые системы</font></b><br>
  <br>
  Простейшая форма системы каталогов состоит в том, что имеется один каталог, 
  в котором содержатся все файлы. Иногда его называют <b>корневым каталогом,</b> 
  но поскольку он в таких системах единственный, его название не имеет значение. 
  Такая система была весьма распространена на ранних персональных компьютерах, 
  в частности потому, что у них было всего по одному пользователю. Первый в мире 
  суперкомпьютер <a href="comment.html#17">CDC 6600</a> также имел всего один 
  каталог для всех файлов, несмотря на то, что на нем одновременно работало много 
  пользователей. Это решение было принято для сохранения простоты программного 
  обеспечения.<br>
<dd> Схематично однокаталоговая система показана на рис. 6.4. В данном примере 
  каталог состоит из четырех файлов. На рисунке буквами <i>A, В и С</i> показаны 
  не имена файлов, а их <i>владельцы</i> (так как именно наличие нескольких пользователей 
  в такой системе создает проблемы). Преимуществом такой схемы является ее простота 
  и способность быстро находить файлы, так как они могут располагаться только 
  в одном месте.<br>
  <br>
  <center>
    <img src="04/Tanenbaum_6_4.jpg" alt="Однокаталоговая система, содержащая четыре файла"><br>
    <br>
    <b><font face="Arial">Рис. 6.4.</font></b><font face="Arial"> Однокаталоговая 
    система, содержащая четыре файла</font><br>
  </center>
  <br>
<dd> Недостаток системы с одним каталогом и несколькими пользователями состоит 
  в том, что различные пользователи могут случайно использовать для своих файлов 
  одинаковые имена. Например, если пользователь <i>А</i> создаст файл <i>mailbox, 
  а</i> затем пользователь <i>В</i> также создаст файл <i>mailbox,</i> то файл, 
  созданный пользователем <i>В,</i> запишется поверх файла, созданного пользователем 
  <i>А.</i> Поэтому такая схема более не используется в многопользовательских 
  системах, но может применяться в небольших встроенных системах, например автомобильной 
  системе, предназначенной для хранения профилей пользователей для небольшого 
  количества водителей.<br>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Двухуровневая система каталогов</font></b><br>
  <br>
  Первым этапом в деле решения проблемы одинаковых имен файлов, созданных различными 
  пользователями, можно считать систему, в которой каждому пользователю выделяется 
  один каталог. При этом имена файлов, созданных одним пользователем, не конфликтуют 
  с именами файлов другого пользователя. Схематично такая двухуровневая каталоговая 
  система проиллюстрирована на рис. 6.5. Буквы обозначают владельцев каталогов 
  и файлов. Такая организация могла, например, использоваться на многопользовательском 
  компьютере или в простой сети персональных компьютеров, соединенных с общим 
  файловым сервером локальной сетью.<br>
  <br>
  <br>
  <center>
    <img src="04/Tanenbaum_6_5.jpg" alt="Двухуровневая каталоговая система"><br>
    <br>
    <font face="Arial"><b>Рис. 6.5.</b> Двухуровневая каталоговая система<br>
    </font> 
  </center>
  <br>
<dd> Когда при такой схеме пользователь пытается открыть файл, система знает, 
  что это за пользователь, и ищет файл в соответствующем каталоге. Следовательно, 
  для работы в такой системе требуется начальная регистрация пользователя, при 
  которой пользователь указывает свое имя или идентификатор. В одноуровневой ката-логовой 
  системе такая процедура не требовалась.<br>
<dd> При реализации такой системы в ее базовой форме пользователи могут получать 
  доступ только к файлам в своем собственном каталоге. Однако небольшая модификация 
  основной схемы позволяет пользователям получать доступ к файлам других пользователей. 
  Для этого им нужно указать идентификатор владельца файла. Например, команда<br>
  <br>
<dd> <font face="Arial">ореn(&quot;х&quot;)</font><br>
  <br>
<dd> может быть вызовом для открытия файла <i>х</i> в каталоге пользователя, а 
  команда<br>
  <br>
<dd> <font face="Arial">open(&quot;nancy/x&quot;)</font><br>
  <br>
<dd> может быть вызовом для открытия файла <i>х</i> в каталоге другого пользователя, 
  Нэнси. Одна из ситуаций, в которой пользователям может понадобиться получить 
  доступ к файлам, не находящимся в их каталогах, — это выполнение системных двоичных 
  программ. Копирование всех системных программ во все пользовательские каталоги 
  крайне неэффективно. Таким образом, возникает необходимость в создании по крайней 
  мере одного системного каталога, содержащего все исполнимые двоичные системные 
  файлы.<br>
  <br>
  <br>
<a NAME="03"></a>
  <b><font size="4">Иерархические каталоговые системы</font></b><br>
  <br>
  Благодаря двухуровневой иерархии исчезают конфликты имен файлов между различными 
  пользователями, но ее недостаточно для пользователей с большим числом файлов. 
  Обычно пользователям бывает необходимо логически группировать свои файлы. Например, 
  у профессора может быть набор файлов, образующих книгу, которую он пишет для 
  одного курса, другое множество файлов, содержащее программы студентов для иного 
  курса. Третий набор файлов может содержать исходные тексты разрабатываемого 
  им нового компилятора, четвертая группа файлов — предложения различных грантов, 
  а также электронную почту, расписание собраний, статьи, игры и т. д. Требуется 
  некий гибкий способ, позволяющий объединять эти файлы в группы.<br>
<dd> Следовательно, нужна некая общая иерархия (то есть дерево каталогов). При 
  таком подходе каждый пользователь может сам создать себе столько каталогов, 
  сколько ему нужно, группируя свои файлы естественным образом. Этот подход проиллюстрирован 
  на рис. 6.6. Здесь каталоги <i>А, В</i> и <i>С,</i> содержащиеся в корневом 
  каталоге, принадлежат различным пользователям, два из которых создали подкаталоги 
  для проектов, над которыми они работают.<br>
  <br>
  <center>
    <img src="04/Tanenbaum_6_6.jpg" alt="Иерархическая каталоговая система"><br>
    <br>
    <font face="Arial"><b>Рис. 6.6.</b> Иерархическая каталоговая система<br>
    </font> 
  </center>
  <br>
<dd> Возможность создавать произвольное количество подкаталогов является мощным 
  структурирующим инструментом, позволяющим пользователям организовать свою работу. 
  По этой причине почти все современные файловые системы организованы подобным 
  образом.<br>
  <br>
  <br>
<a NAME="04"></a>
  <b><font size="4">Имя пути</font></b><br>
  <br>
  При организации файловой системы в виде дерева каталогов требуется некоторый 
  способ указания файла. Для этого обычно используются два различных метода. В 
  первом случае каждому файлу дается <b>абсолютное имя пути</b>, состоящее из 
  имен всех каталогов от корневого до того, в котором содержится файл, и имени 
  самого файла. Например, путь <i>/usr/ast/mailbox</i> означает, что корневой 
  каталог содержит подкаталог <i>usr,</i> который, в свою очередь, содержит подкаталог 
  <i>ast,</i> где находится файл <i>mailbox.</i> Абсолютные имена путей всегда 
  начинаются от корневого каталога и являются уникальными. В системе UNIX компоненты 
  пути разделяются косой чертой /. В Windows в качестве разделителя используется 
  обратная косая черта \. В системе MULTICS использовался символ &gt;. Таким образом, 
  одно и то же имя пути в этих трех операционных системах будет выглядеть следующим 
  образом:<br>
  <br>
<dd> <font face="Arial">Windows \usr\ast\mailbox UNIX /usr/ast/mailbox MULTICS 
  &gt;usr&gt;ast&gt;mailbox</font><br>
  <br>
<dd> Если первой буквой имени пути был разделитель, это означало, независимо от 
  используемого в качестве разделителя символа, что путь абсолютный.<br>
<dd> Применяется и <b>относительное имя пути.</b> Оно используется вместе с концепцией 
  <b>рабочего каталога</b> (также называемого <b>текущим каталогом).</b> Пользователь 
  может назначить один из каталогов текущим рабочим каталогом. В этом случае все 
  имена путей, не начинающиеся с символа разделителя, считаются относительными 
  и отсчитываются относительно текущего каталога. Например, если текущим каталогом 
  является <i>/usr/ast,</i> тогда к файлу с абсолютным путем <i>/usr/ast/mailbox</i> 
  можно обратиться просто как к <i>mailbox.</i> Другими словами, команда UNIX<br>
  <br>
<dd> <font face="Arial">ср /usr/ast/mailbox /usr/ast/mailbox.bak</font><br>
  <br>
<dd> и команда<br>
  <br>
<dd> <font face="Arial">ср mailbox mailbox.bak</font><br>
  <br>
<dd> выполнят одно и то же действие, если рабочим каталогом является <i>/usr/ast.</i> 
  Относительная форма часто оказывается более удобной, но она выполняет то же 
  самое, что и абсолютная.<br>
<dd> Некоторым программам бывает нужно получить доступ к файлам независимо от 
  того, какой каталог является в данный момент текущим. В этом случае они всегда 
  должны использовать абсолютные имена. Например, программе проверки правописания 
  может понадобиться для выполнения работы прочитать файл <i>/usr/lib/ dictionary.</i> 
  В этом случае она должна использовать полное, абсолютное имя файла, так как 
  она не знает, каким будет рабочий каталог при ее вызове. Абсолютное имя файла 
  будет работать всегда, независимо от того, какой каталог является текущим в 
  данный момент.<br>
<dd> Если программе проверки правописания понадобится большое количество файлов 
  из каталога <i>/usr/lib,</i> она может, обратившись к операционной системе, 
  поменять рабочий каталог на <i>/usr/lib, </i> после чего использовать просто 
  имя <i>dictionary</i> для первого параметра системного вызова open. Явно указав 
  свой рабочий каталог, программа может использовать в дальнейшем относительные 
  имена, так как точно знает, где она находится в дереве каталогов.<br>
<dd> У каждого процесса есть свой рабочий каталог, поэтому, когда процесс меняет 
  свой рабочий каталог и потом завершает работу, это не влияет на работу других 
  процессов, и в файловой системе не остается никаких следов от подобных изменений 
  рабочих каталогов. Таким образом, процесс может спокойно менять свой рабочий 
  каталог, когда это ему удобно. С другой стороны, если <i>библиотечная процедура</i> 
  поменяет свой рабочий каталог и не восстановит его при возврате управления, 
  программа, вызвавшая ее, может оказаться не в состоянии продолжать свою работу, 
  так как ее предположения о текущем каталоге окажутся неверными. По этой причине 
  библиотечные процедуры редко меняют свои рабочие каталоги, а когда все-таки 
  меняют, то обязательно восстанавливают рабочий каталог перед возвратом.<br>
  <br>
  <center>
    <img src="04/Tanenbaum_6_7.jpg" alt="Дерево каталогов UNIX"><br>
    <br>
    <font face="Arial"><b>Рис. 6.7.</b> Дерево каталогов UNIX<br>
    </font> 
  </center>
  <br>
<dd> Большинство операционных систем, поддерживающих иерархические каталоги, имеют 
  специальные элементы в каждом каталоге. Это &laquo;.&raquo; и &laquo;..&raquo;, 
  означающие текущий каталог и родительский каталог. Чтобы продемонстрировать, 
  как это работает, обратимся к дереву каталогов системы UNIX, показанному на 
  рис. 6.7. Для некоторого процесса каталог <i>/usr/ast </i> является рабочим. 
  Чтобы переместиться вверх по дереву, он может использовать обозначение &laquo;..&raquo;. 
  Например, он может копировать файл <i>/usr/lib/dictionary </i> в свой собственный 
  каталог при помощи команды<br>
  <br>
<dd> <font face="Arial">ср ../lib/dictionary .</font><br>
  <br>
<dd> Две точки являются инструкцией системе подняться вверх (в каталог <i>usr).</i> 
  После этого нужно открыть каталог <i>lib </i> и найти в нем файл <i>dictionary.</i><br>
<dd> Одиночная точка означает текущий каталог. Когда команда <i>ср</i> в качестве 
  второго аргумента получает точку, она интерпретирует ее как текущий каталог 
  и копирует все файлы туда. Конечно, ту же команду можно было задать и так:<br>
  <br>
<dd> <font face="Arial">ср /usr/lib/dictionary .</font><br>
  <br>
<dd> Здесь использование точки позволяет сэкономить время, затрачиваемое пользователем 
  на набор слова <i>dictionary</i> второй раз. Тем не менее команда<br>
  <br>
<dd> <font face="Arial">ср /usr/lib/dictionary dictionary</font><br>
  <br>
<dd> также прекрасно работает и делает то же самое, что и команда<br>
  <br>
<dd> <font face="Arial">ср /usr/lib/dictionary /usr/ast/dictionary</font><br>
  <br>
<dd> Все эти команды выполняют одни и те же действия.<br>
  <br>
  <br>
<a NAME="05"></a>
  <b><font size="4">Операции с каталогами</font></b><br>
  <br>
  Системные вызовы, управляющие каталогами, значительно менее схожи в различных 
  системах, чем системные вызовы для работы с файлами. Чтобы дать представление 
  о том, что они собой представляют и как работают, приведем следующий пример 
  (взятый из UNIX).<br>
  <br>
<dd> 1. Create. Создать каталог. Только что созданный каталог пуст и не содержит 
  других <a href="comment.html#18">элементов</a>, кроме &laquo;.&raquo; и &laquo;..&raquo;, 
  автоматически помещаемых в каталог операционной системой<sup>1</sup>.<br>
<dd> 2. Delete. Удалить каталог. Может быть удален только пустой каталог. Элементы 
  &laquo;.&raquo; и &laquo;..&raquo; файлами не являются и удалены быть не могут.<br>
<dd> 3. Opendiг. Открыть каталог. После этой операции каталог может быть прочитан. 
  Например, для распечатки всех файлов, содержащихся в каталоге, программа, создающая 
  листинг, открывает каталог, чтобы прочитать имена всех содержащихся в нем файлов. 
  Прежде чем каталог может быть прочитан, его следует открыть, подобно открытию 
  и чтению файла.<br>
<dd> 4. Closediг. Закрыть каталог. Когда каталог прочитан, его следует закрыть, 
  чтобы освободить место во внутренней таблице.<br>
<dd> 5. Readdir. Прочитать следующий элемент открытого каталога. В прежние времена 
  было возможно читать каталоги с помощью обычного системного вызова read, но 
  такой подход был небезопасен, так как требовал от программиста<br>
<dd> умения работать с внутренней структурой каталогов. Поэтому был создан отдельный 
  системный вызов readdi <i>г,</i> всегда возвращающий одну запись каталога стандартного 
  формата независимо от используемой структуры каталогов.<br>
<dd> 6. Rename. Переименование каталога. Во многих отношениях каталоги аналогичны 
  файлам и могут переименовываться так же, как и файлы.<br>
<dd> 7. Link. Связывание представляет собой технику, позволяющую файлу появляться 
  сразу в нескольких каталогах. Этот системный вызов принимает в качестве входных 
  параметров имя файла и имя пути и создает связь между ними. Таким образом, один 
  и тот же файл может появляться сразу в нескольких каталогах. Подобная связь, 
  увеличивающая на единицу счетчик i-узла файла (для учета количества каталогов 
  со ссылками на этот файл), иногда называется жесткой связью.<br>
<dd> 8. Unlink. Удаление ссылки на файл из каталога. Если файл присутствует только 
  в одном каталоге, то данный системный вызов удалит его из файловой системы. 
  Если существует несколько ссылок на этот файл, то будет удалена только указанная 
  ссылка, а остальные останутся. Этот системный вызов применяется для удаления 
  файла в операционной системе UNIX.<br>
  <br>
<dd> Приведенный выше список содержит наиболее важные системные вызовы, но существует 
  также множество других, например для управления защитой информации.<br>
  <br>
</BODY>
</HTML>
