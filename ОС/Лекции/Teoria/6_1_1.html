<HTML>
<HEAD>
<TITLE>Процессы</TITLE>
</HEAD>
<body>
<h1 align="center"><b>Процессы</b></h1>
<p>
Все современные компьютеры могут делать одновременно несколько дел. Например, 
одновременно с запущенной пользователем программой может выполняться чтение с 
диска и вывод текста на экран монитора или на принтер. В многозадачной системе 
процессор переключается между программами, предоставляя каждой от десятков до 
сотен миллисекунд. При этом в каждый конкретный момент времени процессор занят 
только одной программой, но за секунду он успевает поработать с несколькими программами, 
создавая у пользователей иллюзию параллельной работы со всеми программами. Иногда 
в этом контексте говорят о псевдопараллелизме, в отличие от настоящего параллелизма 
в многопроцессорных системах (в которых установлено два и более процессора, разделяющих 
между собой общую физическую память). Следить за работой параллельно идущих процессов 
достаточно трудно, поэтому со временем разработчики операционных систем разработали 
концептуальную модель последовательных процессов, упрощающую эту работу. Темой 
данной главы будет содержание и применение этой модели, а также некоторые результаты 
ее применения.<BR>
<br>
<br>
<a NAME="01"></a>
<B><font size="4">Модель процесса</font></B><BR>
<br>
В этой модели все функционирующее на компьютере программное обеспечение, иногда 
включая собственно операционную систему, организовано в виде набора <b>последовательных 
процессов, </b>или, для краткости, просто <b>процессов. </b>Процессом является 
выполняемая программа, включая текущие значения счетчика команд, регистров и переменных. 
С позиций данной абстрактной модели, у каждого процесса есть собственный виртуальный 
центральный процессор. На самом деле, разумеется, реальный процессор переключается 
с процесса на процесс, но для лучшего понимания системы значительно проще рассматривать 
набор процессов, идущих параллельно (псевдопараллельно), чем пытаться представить 
себе процессор, переключающийся от программы к программе. Как мы уже знаем из 
первой главы, это переключение и называется многозадачностью или мультипрограммированием. 
На рис. 2.1, <I>а </I>представлена схема компьютера, работающего с четырьмя программами. 
На рис. 2.1, <I>б </I>представлены четыре процесса, каждый со своей управляющей 
логикой (то есть логическим счетчиком команд), идущие независимо друг от друга. 
Разумеется, на самом деле существует только один физический счетчик команд, в 
который загружается логический счетчик команд текущего процесса. Когда время, 
отведенное текущему процессу, заканчивается, физический счетчик команд сохраняется 
в логическом счетчике команд процесса в памяти. На рис. 2.1, <I>в</I> видно, что 
за достаточно большой промежуток времени изменилось состояние всех четырех процессов, 
но в каждый конкретный момент в действительности работает только один процесс.<BR>
<br>
</p>
<center>
  <img src="06/Tanenbaum_2_1.jpg" alt="Четыре программы в многозадачном режиме"><br>
  <br>
  <font face="Arial"><B>Рис. 2.1.</B> Четыре программы в многозадачном режиме 
  (а); принципиальная модель четырех<BR>
  независимых последовательных процессов (б); в каждый момент времени активна<BR>
  только одна программа (в)</font><BR>
</center>
<br>
<p>Поскольку процессор переключается между программами, скорость, с которой процессор 
  производит свои вычисления, будет непостоянной и, возможно, даже будет отличной 
  при каждом новом запуске процесса. Поэтому не следует программировать процессы, 
  исходя из каких-либо жестко заданных временных предположений. Представьте себе, 
  например, процесс ввода-вывода, запускающий накопитель на магнитной ленте для 
  восстановления заархивированных файлов. Процесс выполняет холостой цикл задержки 
  10 000 раз, чтобы дать время накопителю разогнаться, а затем дает команду считать 
  первый сектор. Если во время холостого цикла процессор решит переключиться на 
  другую задачу, может случиться так, что работающий с магнитофоном процесс запустится 
  снова уже после того, как считывающая головка пройдет первую запись. Если у 
  процесса есть критические временные рамки такого рода, то есть отдельные события 
  должны укладываться в заданное количество миллисекунд, необходимы специальные 
  меры, чтобы <I>удостовериться в завершенности события. Однако обычно многозадачный 
  режим </I>процессора, а также относительные скорости различных процессов не 
  влияют на работу большинства процессов.<BR>
</p>
<p>Различие между процессом и программой трудноуловимо и тем не менее имеет принципиальное 
  значение. Воспользуемся следующей аналогией: представьте себе программиста, 
  разбирающегося в кулинарии и пекущего торт на день рождения своей дочери. В 
  его распоряжении есть рецепт торта, кухня, оборудованная всем необходимым, и 
  ингредиенты для торта: мука, яйца, сахар, ванилин и т. п. Согласно этой аналогии, 
  рецепт — это программа (то есть алгоритм, записанный в заданном виде), программист 
  исполняет роль процессора, а ингредиенты торта являются входными данными. Процессом 
  является следующая последовательность действий: программист читает рецепт, смешивает 
  продукты и печет торт.<BR>
</p>
<p>Теперь представьте, что на кухню прибегает плачущий сын программиста и кричит, 
  что его ужалила пчела. Программист отмечает, на чем он остановился (сохраняет 
  текущее состояние процесса), находит справочник по оказанию первой помощи и 
  действует в соответствии с инструкцией. Таким образом, наш процессор переключился 
  с одного процесса (выпечка торта) на другой, с большим приоритетом (оказание 
  первой помощи), и у каждого процесса есть своя программа (рецепт торта и справочник 
  по оказанию первой помощи). После проведения всех необходимых процедур по борьбе 
  с укусом пчелы программист возвращается к торту, продолжая с той операции, на 
  которой он прервался.<BR>
</p>
<p>Мы привели эту аналогию с целью показать, что процесс — это активность некоторого 
  рода. У него есть программа, входные и выходные данные, а также состояние. Один 
  процессор может переключаться между различными процессами, используя некий алгоритм 
  планирования для определения момента переключения от одного процесса к другому.<BR>
  <br>
  <br>
<a NAME="02"></a>
  <B><font size="4">Создание процесса</font></B><BR>
  <br>
  Операционной системе необходим способ, позволяющий удостовериться в наличии 
  всех необходимых процессов. В простейших системах, а также системах, разработанных 
  для выполнения одного-единственного приложения (например, контроллер микроволновой 
  печи), можно реализовать такую ситуацию, в которой все процессы, которые когда-либо 
  могут понадобиться, присутствуют в системе при ее загрузке. В универсальных 
  системах необходим способ создания и прерывания процессов по мере необходимости. 
  В этом разделе мы рассмотрим некоторые из возможных способов решения этой проблемы. 
  Ниже перечислены четыре основных события, приводящие к созданию процессов.<BR>
  <br>
</p>
<p>1. Инициализация системы.<BR>
</p>
<p>2. Выполнение изданного работающим процессом системного запроса на создание 
  процесса.<BR>
</p>
<p>3. Запрос пользователя на создание процесса.<BR>
</p>
<p>4. Инициирование пакетного задания.<BR>
  <br>
</p>
<p>Обычно при загрузке операционной системы создаются несколько процессов. Некоторые 
  из них являются высокоприоритетными процессами, то есть обеспечивающими взаимодействие 
  с пользователем и выполняющими заданную работу. Остальные процессы являются 
  фоновыми, они не связаны с конкретными пользователями, но выполняют особые функции. 
  Например, один фоновый процесс может быть предназначен для обработки приходящей 
  на компьютер почты, активизируясь только по мере появления писем. Другой фоновый 
  процесс может обрабатывать запросы к web-страницам, расположенным на компьютере, 
  и активизироваться для обслуживания полученного запроса. Фоновые процессы, связанные 
  с электронной почтой, web-страницами, новостями, выводом на печать и т. п., 
  называются <b>демонами.</b> В больших системах насчитываются десятки демонов. 
  В UNIX для вывода списка запущенных процессов используется программа ps. В Windows 
  95/98/Ме достаточно нажать CTRL-ALT-DEL, а в Windows 2000 можно воспользоваться 
  диспетчером задач, вызываемым этой же комбинацией трех клавиш.<BR>
</p>
<p>Процессы могут создаваться не только в момент загрузки системы, но и позже. 
  Например, новый процесс (или несколько) может быть создан по просьбе текущего 
  процесса. Создание новых процессов особенно полезно в тех случаях, когда выполняемую 
  задачу проще всего сформировать как набор связанных, но тем не менее независимых 
  взаимодействующих процессов. Если необходимо организовать выборку большого количества 
  данных из сети для дальнейшей обработки, удобно создать один процесс для выборки 
  данных и размещения их в совместно используемом буфере, в то время как второй 
  процесс будет считывать данные из буфера и обрабатывать их. Эта схема даже ускорит 
  обработку данных, если каждый процесс запустить на отдельном процессоре в случае 
  многопроцессорной системы.<BR>
</p>
<p>В интерактивных системах пользователь может запустить программу, набрав на 
  клавиатуре команду или дважды щелкнув на значке программы. В обоих случаях результатом 
  будет создание нового процесса и запуск в нем программы. Когда на UNIX работает 
  X Windows, новый процесс получает то окно, в котором был запущен. В Microsoft 
  Windows процесс не имеет собственного окна при запуске, но он может (и должен) 
  создать одно или несколько окон. В обеих системах пользователь может одновременно 
  открыть несколько окон, каждому из которых соответствует свой процесс. Пользователь 
  может переключаться между окнами с помощью мыши и взаимодействовать с процессом, 
  например, вводя данные по мере необходимости.<BR>
</p>
<p>Последнее событие, приводящее к созданию нового процесса, связано с системами 
  пакетной обработки на больших компьютерах. Пользователи посылают пакетное задание 
  (возможно, с использованием удаленного доступа), а операционная система создает 
  новый процесс и запускает следующее задание из очереди в тот момент, когда освобождаются 
  необходимые ресурсы.<BR>
</p>
<p>С технической точки зрения во всех перечисленных случаях новый процесс формируется 
  одинаково: текущий процесс выполняет системный запрос на создание нового процесса. 
  В роли текущего процесса может выступать процесс, запущенный пользователем, 
  системный процесс, инициированный клавиатурой или мышью, а также процесс, управляющий 
  пакетами. В любом случае этот процесс всего лишь выполняет системный запрос 
  и создает новый процесс. Системный запрос заставляет операционную систему создать 
  новый процесс, а также прямо или косвенно содержит информацию о программе, которую 
  нужно запустить в этом процессе.<BR>
</p>
<p>В UNIX существует только один системный запрос, направленный на создание нового 
  процесса: fork <I>(ветвление </I>или <I>вилка). </I>Этот запрос создает дубликат 
  вызываемого процесса. После выполнения запроса fork двум процессам — родительскому 
  и дочернему — соответствуют одинаковые образы памяти, строки окружения и одни 
  и те же открытые файлы. Обычно дочерний процесс выполняет системный вызов execve 
  (или похожий) для изменения своего образа памяти и запуска новой программы. 
  Так, когда пользователь набирает на клавиатуре команду <I>sort, </I>оболочка 
  создает путем ветвления дочерний процесс, который и выполняет программу <I>sort. 
  </I>Смысл этого двухступенчатого процесса заключается в том, что дочерний процесс 
  успевает обработать описания файлов после fork, но до execve, чтобы выполнить 
  перенаправление стандартных устройств ввода и вывода и потока сообщений об ошибках.<BR>
</p>
<p>В Windows же вызов всего одной функции CreateProcess интерфейса Win32 управляет 
  и созданием процесса, и запуском в нем нужной программы. У этой функции 10 параметров: 
  программа, которую нужно запустить, параметры командной строки этой программы, 
  различные атрибуты защиты, биты, управляющие наследованием открытых файлов, 
  приоритеты, спецификация окна, которое следует открыть для процесса, и указатель 
  на структуру, в которой информация о созданном процессе возвращается вызывающей 
  программе. Кроме CreateProcess в Win32 есть около 100 функций для управления 
  процессами и их синхронизации.<BR>
  И в UNIX, и в Windows после создания нового процесса родительский и дочерний 
  процессы имеют собственные различные адресные пространства. При изменении любым 
  процессом слова в адресном пространстве это изменение незаметно для других процессов. 
  В UNIX начальное адресное пространство дочернего процесса является <I>копией 
  </I>родительского, но сами адресные пространства различны, и перезаписываемая 
  память совместно не используется (некоторые приложения UNIX совместно используют 
  текст программы, поскольку его нельзя модифицировать). В то же время созданный 
  процесс может использовать совместно с родительским процессом некоторые другие 
  ресурсы, например открытые файлы. В Windows адресные пространства родительского 
  и дочернего процессов отличаются с самого начала.<BR>
  <br>
  <br>
<a NAME="03"></a>
  <B><font size="4">Завершение процесса</font></B><BR>
  <br>
  После того как процесс создан, он начинает выполнять свою работу. Но ничто не 
  длится вечно, даже процесс — рано или поздно он завершится, чаще всего благодаря 
  одному из следующих событий:<BR>
  <br>
</p>
<p>1. Обычный выход (преднамеренно).<BR>
</p>
<p>2. Выход по ошибке (преднамеренно).<BR>
</p>
<p>3. Выход по неисправимой ошибке (непреднамеренно).<BR>
</p>
<p>4. Уничтожение другим процессом (непреднамеренно).<BR>
  <br>
</p>
<p>В основном процессы завершаются по мере выполнения своей работы. После окончания 
  компиляции программы компилятор выполняет системный запрос, чтобы сообщить операционной 
  системе об окончании работы. В UNIX этот системный запрос — exit, а в Windows 
  — ExitProcess. Программы, рассчитанные на работу с экраном, также поддерживают 
  преднамеренное завершение. В текстовых редакторах, браузерах и других программах 
  такого типа обычно есть кнопка или пункт меню, щелкнув на котором можно удалить 
  все временные файлы, открытые процессом, и затем завершить процесс.<BR>
</p>
<p>Второй причиной завершения процесса может стать неустранимая ошибка. Например, 
  если пользователь набрал на клавиатуре команду<BR>
  <br>
  <font face="Arial">cc foo.c</font><BR>
  <br>
  для компиляции программы <I>foo.c</I>, а соответствующего файла не существует, 
  компилятор просто закончит работу. Интерактивные процессы, рассчитанные на работу 
  с экраном, обычно не завершают работу при получении неверных параметров, вместо 
  этого выводя на экран диалоговое окно и прося пользователя ввести правильные 
  параметры.<BR>
</p>
<p>Третьей причиной завершения процесса является ошибка, вызванная самим процессом, 
  чаще всего связанная с ошибкой в программе. В качестве примера можно привести 
  выполнение недопустимой команды, обращение к несуществующей области памяти и 
  деление на ноль. В некоторых системах (например, в UNIX) процесс может информировать 
  операционную систему о том, что он сам обработает некоторые ошибки, и в этом 
  случае процессу посылается сигнал (процесс прерывается, а не завершается) при 
  появлении ошибки.<BR>
</p>
<p>Четвертой причиной завершения процесса может служить выполнение другим процессом 
  системного запроса на уничтожение процесса. В UNIX такой системный запрос — 
  kill, а соответствующая функция Win32 — TerminateProcess. В обоих случаях &laquo;киллер&raquo; 
  должен обладать соответствующими полномочиями по отношению к &laquo;убиваемому&raquo; 
  процессу. В некоторых системах при завершении процесса (преднамеренно или нет) 
  все процессы, созданные процессом, также завершаются. Впрочем, это не относится 
  ни к UNIX, ни к Windows.<BR>
  <br>
  <br>
<a NAME="04"></a>
  <B><font size="4">Иерархия процессов</font></B><BR>
  <br>
  В некоторых системах родительский и дочерний процессы остаются связанными между 
  собой определенным образом. Дочерний процесс также может, в свою очередь, создавать 
  процессы, формируя <I>иерархию </I>процессов. Следует отметить, что в отличие 
  от животного мира у процесса может быть лишь один родитель и сколько угодно 
  &laquo;детей&raquo;.<BR>
</p>
<p>В UNIX процесс, все его &laquo;дети&raquo; и дальнейшие потомки образуют <I>группу 
  процессов. </I>Сигнал, посылаемый пользователем с клавиатуры, доставляется всем 
  членам группы, взаимодействующим с клавиатурой в данный момент (обычно это все 
  активные процессы, созданные в текущем окне). Каждый из процессов может перехватить 
  сигнал, игнорировать его или выполнить другое действие, предусмотренное по умолчанию.<BR>
</p>
<p>Рассмотрим в качестве еще одного примера иерархии процессов инициализацию 
  UNIX при запуске. В образе загрузки присутствует специальный процесс <I>nut. 
  </I>При запуске этот процесс считывает файл, в котором находится информация 
  о количестве терминалов. Затем процесс разветвляется таким образом, чтобы каждому 
  терминалу соответствовал один процесс. Процессы ждут, пока какой-нибудь пользователь 
  не войдет в систему. Если пароль правильный, процесс входа в систему запускает 
  оболочку для обработки команд пользователя, которые, в свою очередь, могут запускать 
  процессы. Таким образом, все процессы в системе принадлежат к единому дереву, 
  начинающемуся с процесса <I>init. </I>Напротив, в Windows не существует понятия 
  иерархии процессов, и все процессы равноправны. Единственное, в чем проявляется 
  что-то вроде иерархии процессов — создание процесса, в котором родительский 
  процесс получает специальный маркер (так называемый <b>дескриптор), </b>позволяющий 
  контролировать дочерний процесс. Но маркер можно передать другому процессу, 
  нарушая иерархию. В UNIX это невозможно.<BR>
  <br>
  <br>
<a NAME="05"></a>
  <B><font size="4">Состояния процессов</font></B><BR>
  <br>
  Несмотря на то что процесс является независимым объектом, со своим счетчиком 
  команд и внутренним состоянием, существует необходимость взаимодействия с другими 
  процессами. Например, выходные данные одного процесса могут служить входными 
  данными для другого процесса. В команде оболочки<BR>
  <br>
  <font face="Arial">cat chapter1 chapter2 chapter3 | grep tree</font><BR>
  <br>
  первый процесс, исполняющий файл cat, объединяет и выводит три файла. Второй 
  процесс, исполняющий файл grep, отбирает все строки, содержащие слово &laquo;tree&raquo;. 
  В зависимости от относительных скоростей процессов (скорости зависят от относительной 
  сложности программ и процессорного времени, предоставляемого каждому процессу), 
  может получиться, что grep уже готов к запуску, но входных данных для этого 
  процесса еще нет. В этом случае процесс блокируется до поступления входных данных.<BR>
</p>
<p>Процесс блокируется, поскольку с точки зрения логики он не может продолжать 
  свою работу (обычно это связано с отсутствием входных данных, ожидаемых процессом). 
  Также возможна ситуация, когда процесс, готовый и способный работать, останавливается, 
  поскольку операционная система решила предоставить на время процессор другому 
  процессу. Эти ситуации являются принципиально разными. В первом случае приостановка 
  выполнения является внутренней проблемой (поскольку невозможно обработать командную 
  строку пользователя до того, как она была введена). Во втором случае проблема 
  является технической (нехватка процессоров для каждого процесса). На рис. 2.2 
  представлена диаграмма состояний, показывающая три возможных состояния процесса:<BR>
  <br>
</p>
<p>1. Работающий (в этот конкретный момент использующий процессор).<BR>
</p>
<p>2. Готовый к работе (процесс временно приостановлен, чтобы позволить выполняться 
  другому процессу).<BR>
</p>
<p>3. Заблокированный (процесс не может быть запущен прежде, чем произойдет некое 
  внешнее событие).<BR>
  <br>
  
</p>
<center>
    <img src="06/Tanenbaum_2_2.jpg" alt="Состояния процесса"><br>
    <br>
    <font face="Arial"><B>Рис. 2.2.</B> Процесс может находиться в рабочем, готовом 
    и заблокированном состоянии.<br>
    Стрелками показаны возможные переходы между состояниями</font><BR>
  </center>
  <br>
<p>С точки зрения логики первые два состояния одинаковы. В обоих случаях процесс 
  может быть запущен, только во втором случае недоступен процессор. Третье состояние 
  отличается тем, что запустить процесс невозможно, независимо от загруженности 
  процессора.<BR>
</p>
<p>Как показано на рис. 2.2, между этими тремя состояниями возможны четыре перехода. 
  Переход <I>1 </I>происходит, когда процесс обнаруживает, что продолжение работы 
  невозможно. В некоторых системах процесс должен выполнить системный запрос, 
  например block или pause, чтобы оказаться в заблокированном состоянии. В других 
  системах, как в UNIX, процесс автоматически блокируется, если при считывании 
  из канала или специального файла (предположим, терминала) входные данные не 
  были обнаружены.<BR>
</p>
<p>Переходы <I>2 </I>и <I>3 </I>вызываются частью операционной системы, называемой 
  планировщиком процессов, так что сами процессы даже не знают о существовании 
  этих переходов. Переход <I>2 </I>происходит, если планировщик решил, что пора 
  предоставить процессор следующему процессу. Переход <I>3 </I>происходит, когда 
  все остальные процессы уже исчерпали свое процессорное время, и процессор снова 
  возвращается к первому процессу. Вопрос планирования (когда следует запустить 
  очередной процесс и на какое время) сам по себе достаточно важен, и мы вернемся 
  к нему позже в этой главе. Было разработано множество алгоритмов с целью сбалансировать 
  требования эффективности для системы в целом и для каждого процесса в отдельности. 
  Мы также рассмотрим некоторые из них ниже в этой главе.<BR>
</p>
<p>Переход <I>4 </I>происходит с появлением внешнего события, ожидавшегося процессом 
  (например, прибытие входных данных). Если в этот момент не запущен какой-либо 
  другой процесс, то срабатывает переход <I>3, </I>и процесс запускается. В противном 
  случае процессу придется некоторое время находиться в состоянии готовности, 
  пока не освободится процессор.<BR>
</p>
<p>Модель процессов упрощает представление о внутреннем поведении системы. Некоторые 
  процессы запускают программы, выполняющие команды, введенные с клавиатуры пользователем. 
  Другие процессы являются частью системы и обрабатывают такие задачи, как выполнение 
  запросов файловой службы, управление запуском диска или магнитного накопителя. 
  В случае дискового прерывания система останавливает текущий процесс и запускает 
  дисковый процесс, который был заблокирован в ожидании этого прерывания. Вместо 
  прерываний мы можем представлять себе дисковые процессы, процессы пользователя, 
  терминала и т. п., блокирующиеся на время ожидания событий. Когда событие произошло 
  (информация прочитана с диска или клавиатуры), блокировка снимается и процесс 
  может быть запущен.<BR>
</p>
<p>Рассмотренный подход описывается моделью, представленной на рис. 2.3. Нижний 
  уровень операционной системы — это планировщик, на верхних уровнях расположено 
  множество процессов. Вся обработка прерываний и детали, связанные с остановкой 
  и запуском процессов, спрятаны в том, что мы назвали планировщиком, являющимся, 
  по сути, совсем небольшой программой. Вся остальная часть операционной системы 
  удобно структурирована в виде набора процессов. Очень немногие существующие 
  системы структурированы столь удобно.<BR>
  <br>
  
</p>
<center>
    Процессы<BR>
    <img src="06/Tanenbaum_2_3.jpg" alt="Уровни операционной системы"> 
    <br>
    <font face="Arial"><B>Рис. 2.3.</B> Нижний уровень операционной системы отвечает 
    за прерывания и планирование.<br>
    Выше расположены последовательные процессы</font><BR>
    <br>
  </center>
  <br>
<a NAME="06"></a>
  <B><font size="4">Реализация процессов</font></B><BR>
  <br>
  Для реализации модели процессов операционная система содержит таблицу (массив 
  структур), называемую таблицей процессов, с одним элементом для каждого процесса. 
  (Некоторые авторы называют эти элементы блоками управления процессом.) Элемент 
  таблицы содержит информацию о состоянии процесса, счетчике команд, указателе 
  стека, распределении памяти, состоянии открытых файлов, об использовании и распределении 
  ресурсов, а также всю остальную информацию, которую необходимо сохранять при 
  переключении в состояние <I>готовности </I>или <I>блокировки </I>для последующего 
  запуска — как если бы процесс не останавливался.<BR>
<p>В табл. 2.1 представлены некоторые наиболее важные поля типичной системы. 
  Поля в первой колонке относятся к управлению процессом. Остальные колонки описывают 
  управление памятью и файлами. Необходимо отметить, что от конкретной системы 
  очень сильно зависит, какие именно поля будут в таблице процессов, но табл. 
  2.1 дает общее представление о необходимой информации.<BR>
</p>
<p>Теперь, после знакомства с таблицей процессов, можно сказать еще несколько 
  слов о том, как поддерживается иллюзия нескольких последовательных процессов 
  на машине с одним процессором и несколькими устройствами ввода-вывода. С каждым 
  классом устройств ввода-вывода (гибкий диск, жесткий диск, таймер, терминал) 
  связана область памяти (обычно расположенная в нижних адресах), называемая вектором 
  прерываний. Вектор прерываний содержит адрес процедуры обработки прерываний. 
  Представьте, что в момент прерывания диска работал пользовательский процесс 
  3. Содержимое счетчика команд процесса, слово состояния программы и, возможно, 
  один или несколько регистров записываются в (текущий) стек аппаратными средствами 
  прерывания. Затем происходит переход по адресу, указанному в векторе прерывания 
  диска. Вот и все, что делают аппаратные средства прерывания. С этого момента 
  вся остальная обработка прерывания производится программным обеспечением, например 
  процедурой обработки прерываний.<BR>
</p>
<p>Все прерывания начинаются с сохранения регистров, часто в блоке управления 
  текущим процессом в таблице процессов. Затем информация, помещенная в стек прерыванием, 
  удаляется, и указатель стека переставляется на временный стек, используемый 
  программой обработки процесса. Такие действия, как сохранение регистров и установка 
  указателя стека, невозможно даже выразить на языке высокого уровня (например, 
  на С). Поэтому они выполняются небольшой программой на ассемблере, обычно одинаковой 
  для всех прерываний, поскольку процедура сохранения регистров не зависит от 
  причины возникновения прерывания.<BR>
  <br>
  
</p>
<center>
    <font face="Arial"><B>Таблица 2.1. </B>Некоторые поля типичного элемента таблицы 
    процессов</font><BR>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="863" HEIGHT="25">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="863" HEIGHT="25">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="321" HEIGHT="22"><b>Управление 
                процессом </b></TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="22"> <b>Управление 
                памятью </b></TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="257" HEIGHT="22"><b>Управление 
                файлами </b></TD>
            </TR>
          </TABLE>
          <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="863" HEIGHT="189">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="22">Регистры</TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="22">Указатель 
                на текстовый сегмент </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="22">Корневой каталог 
              </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="22">Счетчик команд</TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="22">Указатель 
                на сегмент данных </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="22">Рабочий каталог 
              </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="20">Слово состояния 
                программы </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="20">Указатель 
                на сегмент стека </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="20">Дескрипторы 
                файла </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="20">Указатель 
                стека </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="20"> </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="20">Идентификатор 
                пользователя</TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="20"> </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="20"> </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="20">Идентификатор 
                группы </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="19">Состояние 
                процесса </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="19"> </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="19"> </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="21">Приоритет 
              </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="21"> </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="21"> </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="21">Параметры 
                планирования </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="21"> </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="21"> </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="20">Идентификатор 
                процесса </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="20"> </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="20"> </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="20">Родительский 
                процесс </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="20"> </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="20"> </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="20">Группа процесса 
              </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="20"> </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="20"> </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="20">Сигналы </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="20"> </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="20"> </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="20">Время начала 
                процесса </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="20"> </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="20"> </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="23">Использованное 
                процессорное время </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="23"> </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="23"> </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="20">Процессорное 
                время дочернего процесса </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="20"> </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="20"> </TD>
            </TR>
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD ALIGN="left" VALIGN="TOP" WIDTH="321" HEIGHT="20">Время следующего 
                аварийного сигнала </TD>
              <TD ALIGN="LEFT" VALIGN="TOP" WIDTH="285" HEIGHT="20"> </TD>
              <TD ALIGN="left" VALIGN="TOP" WIDTH="257" HEIGHT="20"> </TD>
            </TR>
          </TABLE>
        </TD>
      </TR>
    </TABLE>
  </center>
  <br>
<p>По завершении своей работы эта программа вызывает процедуру на языке С, которая 
  выполняет все остальные действия, связанные с конкретным прерыванием. (Мы предполагаем, 
  что операционная система написана на С, что является стандартным решением для 
  всех существующих операционных систем.) Когда процедура завершает свою работу 
  (в результате чего, возможно, некоторые процессы переходят в состояние готовности), 
  вызывается планировщик для выбора следующего процесса. После этого управление 
  возвращается к программе на ассемблере, загружающей регистры и карту памяти 
  для текущего процесса и запускающей его. Управление прерыванием и работа планировщика 
  представлены в табл. 2.2. Следует отметить, что отдельные детали могут несколько 
  варьироваться от системы к системе.<BR>
  <br>
  
</p>
<center>
    <font face="Arial"><B>Таблица 2.2. </B>Схема обработки прерывания нижним уровнем 
    операционной системы</font><BR>
    <table BORDER="1" CELLSPACING="0" CELLPADDING="0" width="797">
      <tr> 
        <td height="156"> 1. Аппаратное обеспечение сохраняет в стеке счетчик 
          команд и т. п.<BR>
          2. Аппаратное обеспечение загружает новый счетчик команд из вектора 
          прерываний<BR>
          3. Процедура на ассемблере сохраняет регистры<BR>
          4. Процедура на ассемблере устанавливает новый стек<BR>
          5. Запускается программа обработки прерываний на С. (Она обычно считывает 
          и буферизирует входные данные)<BR>
          6. Планировщик выбирает следующий процесс<BR>
          7. Программа на С передает управление процедуре на ассемблере<BR>
          8. Процедура на ассемблере запускает новый процесс</td>
      </tr>
    </table>
  </center>
</BODY>
</HTML>
