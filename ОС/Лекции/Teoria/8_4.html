<HTML>
<HEAD>
<TITLE>Страусовый алгоритм</TITLE>
</HEAD>
<body>
  <b><font size="6"><center>Страусовый алгоритм</center></font></b><br>
  <br>
  Самым простым подходом является &laquo;страусовый алгоритм&raquo;: воткните 
  голову в песок и притворитесь, что проблема вообще не существует. Различные 
  люди отзываются об этой стратегии по-разному. Математики считают ее полностью 
  неприемлемой и говорят, что взаимоблокировки нужно предотвращать любой ценой. 
  Инженеры спрашивают, как часто встает подобная проблема, как часто система попадает 
  в аварийные ситуации по другим причинам и насколько серьезны последствия взаимоблокировок. 
  Если взаимоблокировки случаются в среднем один раз в пять лет, а сбои операционной 
  системы, ошибки компилятора и поломки компьютера из-за неисправности аппаратуры 
  происходят раз в неделю, то большинство инженеров не захотят добровольно уступать 
  в производительности и удобстве для того, чтобы ликвидировать возможность взаимоблокировок.<br>
<dd> Для усиления контраста между этими подходами добавим, что большинство операционных 
  систем потенциально страдают от взаимоблокировок, которые даже не обнаруживаются, 
  не говоря уже об автоматическом выходе из тупика. Суммарное количество процессов 
  в системе определяется количеством записей в таблице процесса. Таким образом, 
  ячейки таблицы процесса являются ограниченным ресурсом. Если системный вызов 
  fork получает отказ, потому что таблица целиком заполнена, разумно будет, что 
  программа, вызывающая fork, подождет какое-то время и повторит попытку.<br>
<dd> Теперь предположим, что система UNIX имеет 100 ячеек процессов. Работают 
  десять программ, каждой необходимо создать 12 (под)процессов. После образования 
  каждым процессом девяти процессов 10 исходных и 90 новых процессов заполнят 
  таблицу целиком. Теперь каждый из десяти исходных процессов попадает в бесконечный 
  цикл, состоящий из попыток разветвления и отказов, то есть возникает взаимоблокировка. 
  Вероятность того, что произойдет подобное, минимальна, но это <i>могло бы</i> 
  случиться. Должны ли мы отказаться от процессов и вызова fork, чтобы устранить 
  данную проблему?<br>
<dd> Максимальное количество открытых файлов также ограниченно размером таблицы 
  i-узлов, следовательно, когда таблица заполняется целиком, возникает та же самая 
  проблема. Пространство для подкачки файлов на диск является еще одним ограниченным 
  ресурсом. Фактически почти каждая таблица в операционной системе представляет 
  собой ресурс, имеющий пределы. Должны ли мы упразднить их все из-за того, что 
  может произойти ситуация, когда в группе из <i>п</i> процессов каждый может 
  потребовать 1 / n от целого, а затем попытаться получить еще часть?<br>
<dd> Большая часть операционных систем, включая UNIX и Windows, игнорируют эту 
  проблему. Они исходят из предположения, что большинство пользователей скорее 
  предпочтут иметь дело со случающимися время от времени взаимоблокировками, чем 
  с правилом, по которому всем пользователям разрешается только один процесс, 
  один открытый файл и т. д. Если бы можно было легко устранить взаимоблокировки, 
  не возникло бы столько разговоров на эту тему. Сложность заключается в том, 
  что цена достаточно высока, и в основном она, как мы вскоре увидим, исчисляется 
  в наложении неудобных ограничений на процессы. Таким образом, мы столкнулись 
  с неприятным выбором между удобством и корректностью и множеством дискуссий 
  о том, что более важно и для кого. При всех этих условиях трудно найти верное 
  решение.<br>
</BODY>
</HTML>
