<html>
<head>
<TITLE>"Сон" и пробуждение процесса</TITLE>
</HEAD>
<BODY>

<CENTER>
<H1>"Сон" и пробуждение процесса</H1>
</CENTER>
<font  size="3">
Процесс, выполняющийся в режиме ядра, имеет значительную степень автономии  
в  решении того, как ему следует реагировать на возникновение системных
событий. Процессы могут общаться между собой и "предлагать"  различные  
альтернативы,  но  при этом окончательное решение они принимают самостоятельно.
Мы еще увидим, что существует набор правил,  которым  подчиняется  поведение
процессов  в  различных  обстоятельствах, но каждый процесс в конечном итоге
следует этим правилам по своей собственной инициативе. Например,  если  процесс 
должен временно приостановить выполнение ("перейти ко сну"), он это делает  
по своей доброй воле. Следовательно, программа обработки прерываний не
может приостановить свое выполнение, ибо если это случится, прерванный  процесс 
должен был бы "перейти ко сну" по умолчанию.<BR><p>
    Процессы  приостанавливают  свое выполнение, потому что они ожидают 
возникновения некоторого события, например, завершения ввода-вывода на  
периферийном  устройстве,  выхода, выделения системных ресурсов и т.д. 
Когда говорят, что процесс приостановился по событию, то имеется  ввиду,  что  
процесс находится в состоянии "сна" до наступления события, после чего он 
пробудится и  перейдет в состояние "готовности к выполнению". Одновременно могут 
приостановиться по событию много процессов; когда событие наступает, все  процессы, 
приостановленные  по событию, пробуждаются, поскольку значение условия,
связанного с событием, больше не является "истинным". Когда процесс  
пробуждается,  он  переходит из состояния "сна" в состояние "готовности к выполне-
нию", находясь в котором он уже может быть выбран планировщиком; следует обратить 
внимание на то, что он не  выполняется  немедленно.  Приостановленные
процессы не занимают центральный процессор. Ядру системы нет надобности постоянно 
проверять то, что процесс все еще приостановлен, т.к. ожидает наступления 
события, и затем будить его.<BR><p>
Например,  процесс, выполняемый в режиме ядра, должен иногда блокировать
структуру данных на случай приостановки в будущем; процессы, пытающиеся  об-
ратиться к заблокированной структуре, обязаны проверить наличие блокировки и
приостановить  свое  выполнение, если структура заблокирована другим процес-
сом. 
Рассмотрим процесс блокировки такого рода ядром на примере ОС UNIX:<BR><p>

    while (условие "истинно")<BR>
          sleep (событие: условие принимает значение "ложь");<BR>
    set condition true;<BR>
то есть:<BR>
    пока (условие "истинно")<BR>
         приостановиться (до наступления события,  при котором<BR>
                          условие принимает значение "ложь");<BR>
    присвоить условию значение "истина";<BR><p>

    Ядро снимает  блокировку и "будит" все процессы,  приостановленные из-за 
этой блокировки, следующим образом:<BR><p>

    set condition false;<BR>
    wakeup (событие: условие "ложно");<BR>
то есть:<BR>
    присвоить условию значение "ложь";<BR>
    перезапуститься (при наступлении события, при котором условие<BR>
                     принимает значение "ложь");<BR><p>
    Например,  процесс, выполняемый в режиме ядра, должен иногда блокировать
структуру данных на случай приостановки в будущем; процессы, пытающиеся  
обратиться к заблокированной структуре, обязаны проверить наличие блокировки и
приостановить  свое  выполнение, если структура заблокирована другим процессом.<BR><p> 
    Ядро снимает  блокировку и "будит" все процессы,  приостановленные из-за 
этой блокировки.<BR>
</body>
</html>

