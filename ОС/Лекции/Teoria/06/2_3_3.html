<html>
<head>
<title>Клинчи</title>
</head>
<body>
<CENTER>
<H1>Клинчи</H1>
<FONT SIZE="3">
</CENTER>
<UL>
 <LI><A HREF="#Предварительное распределение">Предварительное распределение всех совместно используемых ресурсов </A>
 <LI><A HREF="#Контроль">Контроль над расределением для предотвращения клинчей</A>
 <LI><A HREF="#Восстановление">Обнаружение и восстановление</A>
 <LI><A HREF="#Исследования">Исследования в области обработки клинчей</A>
</UL>
<HR SIZE="4">
<p>
Клинчем называется ситуация, при которой два соперничающих процесса блокируют друг друга,
так как каждый пытается получить доступ к ресурсу, монопольно занятому другим процессом.
Рассмотрим процессы, изображенные на рисунке 2.1.
<center>
<IMG SRC="ris2_1.jpg" border=0 align=center  vspace=15> </A>

<p>
	Рисунок 2.1. Cитуация клинча.
</center><p>
Процессы A и B  желают совместно использовать печатающее устройство и устройство чтения
перфокарт, упорядочивая свои взаимоотношения посредством знакомых нам операций 
ЗАНЯТЬ и ОСВОБОДИТЬ. Вследствие независимости планирования процессов последовательность
поступления запросов на ресурсы и их освобождений предсказать невозможно. В зависимости
от временных соотношений мы можем получить совершенно различные последовательности, например:
<pre>
      (1) Ar1,Ar2,Ar3,Ar4,Br1,Br2,Br3,Br4;
      (2) Br1,Br2,Br3,Br4,Ar1,Ar2,Ar3,Ar4;
      (3) Ar1,Ar2,Br1,Ar3,Ar4,Br2,Br3,Br4/
</pre>
<p>
Отметим, что в последовательности (3) процесс B временно блокируется событием Br1 до тех пор,
пока процесс A не выполнит Ar4.
<p>
Рассмотрим последовательность, начинающуюся с запросов Ar1 (печатающее устройство
для процесса A) и Br1 (устройство чтения перфокарт для процесса B). Как же пойдет работа
дальше? Если последует запрс Ar2 (устройство чтения перфокарт для A), то процесс А
должен перейти в состояние ожидания, так как этот ресурс в настоящий момент принадлежит
другому процессу. Управление получит процесс В и, выдав запрос Br2 (печатающее устройство
для B), также перейдет в состояние ожидания, так как печатающим устройством в 
настоящий момент монопольно владеет процесс А. Ни один из них не в силах стронуться 
с этой точки; они попали в ситуацию, похожую на обоюдный шахматный пат, взаимно блокируя
друг друга.
<p>
В системах с мультипрограммированием клинчи могут оказаться весьма частым явлением,
особенно при совместном использовании несколькими процессами  общих управляющих таблиц.
<p>
Мы рассмотрим следующие способы борьбы с клинчами:
<OL>
<LI>Предварительное распределение всех совместно используемых ресурсов.
<LI>Контроль над распределением:
    <UL>
    <LI>регулируемое распределение; 
    <LI>стандартная последовательность распределения.	
    </UL>
<LI>Обнаружение и востановление.
</OL>
<p>
<h2><a name="Предварительное распределение">Предварительное распределение всех совместно используемых ресурсов</a></h2>
<p>
Надежным и простым методом предотвращения клинчей является требование предварительного
объявление пользователем <I><B>всех</I></B> необходимых егозаданию ресурсов еще на стадии
представления задания. В этом случае планировщик заданий просто не пропускаетзадание 
на обработку до тех пор, пока все затребованные ресурсы не станут доступными.
Ресурсы закрепляются за заданием на все времяего выполнения. Метод имеет определенные
недостатки:
<ol>
<LI>Пользователь не всегда может определить, какие устройства (ресурсы) потребуются
его заданию на стадии выполнения.
<LI>Задание вынуждено ждать освобождения всех ресурсов,хотя некоторые из них
могут понадобиться ему значительно позже,например при его завершении, которое
наступит лишь несколько часов спустя.
<LI>Если известно, что вероятность использования заданием определенного устройства
невелика, постоянное закрепление такого устройства за заданием является непозволительным
расточительством. например, выдача на печать содержимого памяти может потребоваться
только в случае возникновения ошибок в работе программы, тем не менее печатающее устройство
будет монопольно закреплено за этим заданием.
<LI>Каждое конкретное задание не использует непрерывно все устройства в течение 
всегопериода выполнения, следовательно, эти устройства могли бы освобождаться и 
предоставляться другим заданиям в системе с мультипрогаммированием.
</ol>
<p>
<h2><a name="Контроль">Контроль над распределением для предотвращения клинчей</a></h2>
<p>
<I><B>Регулируемое распределение<A HREF="../../literatura.html">[3]</a></I></B>
<p>
ПОльзователь заранее объявляет все необходимые ресурсы, однако выполнение задания
начинается, не дожидаясь освобождения всех этих ресурсов. Суть метода состоит в том,
чтобы избегать назначения ресурса заданию, если вседствие этого появляется возможность
возникновения клинча. Например рассмотрим истему с девятью накопителями на магнитной
ленте и два задания, каждому из которых необходимо до шести накопителей. Известно,
что задания будут использовать накопители не все время, а будут запрашивать их по мере 
надобности динамически во время выполнения. При использовании регулируемого распределения
можно запустить оба задания и выполнять их до тех пор, пока не возникнет ситуация,
изображенная на рисунке 2.2.
<center>
<IMG SRC="ris2_2.jpg" border=0 align=center  vspace=15> </A>

<p>
	Рисунок 2.2. Пример регулируемого распределения.
</center>
<p>
Если во время своего выполнения оба задания перйдут в область , ограниченную 
двойной линией, появится возможность возникновения клинча. При использовании описываемого
метода одному из заданий разрешается пересечь линию; если второе задание попробует
также пересечь ее, оно будет заблокировано до освобождения необходимого ему количества
накопителей.
<p>
Если мы назначим четыре накопителя заданию 1 и пять накопителей заданию 2, ни одно
задание не сможет завершится. Следовательно, такая ситуация недопустима. Заметим,
что если задание 1 завершится до того, как задание 2 запросит третий накопитель,
либо если задание 2 успеет освободить три накопителя еще до того, как задание 1
запросит первый накопитель, то ни одному заданию не придется ждать.
<p>Таким образом, для реализации метода регулируемого распределения необходимо выполнять
следующие правила:
<OL>
<LI>Заранее объявлять все необходимые заданию ресурсы.
<LI>Перед назначением ресурса осуществлять проверку на возможность возникновения 
клинчей; если эта возможность исключена, то ресурс можно назначать.
</OL>
<p>
Основной трудностью при использовании регулируемого распределения является необходимость
знать заранее все ресурсы, которые могут потребоваться заданию во время его выполнения.
Кроме того, этот алгоритм несколько "консервативен". Переход в "опасную" область
отнюдь не свидетельствует о том, что все запрошенные устройства действительно будут
использованы, и некоторые задания могут напрасно терять свое время в ожидании,
тогда как, если бы их выполнение было продолжено, ситуация клинча могла бы и не возникнуть.
<p>
<I><B>Стандартная последовательность распределения</I></B>
<p>
Существует еще одна форма контроля над распределением ресурсов, а именно стандартная
последовательность распределения. Согласно этому методу, каждому ресурсу приписывается
определенный номер (например, устройству чтения перфокарт - 1, печати - 2, перфорации - 3,
НМЛ - 4, НМД - 5 и т.д.). Все запросы должны быть  упорядочены по возрастанию этих
номеров. Например, последовательность запросов < устройство чтения (1), перфоратор (3),
НМЛ (4)> будет правильной, а последовательность <устройство чтения (1), НМЛ (4), перфоратор (3)>
будет неверной. если запросы следуют в порядке возрастания номеров, то они удовлетворяются
по мере того, как ресурсы становятся доступными. В противном случае процесс вынужден ждать.
<p>
Этот метод гарантирует отсутствие клинчей. Отметим, что нам также необязательно знать
максимальную потребность в ресурсах. Однако и у него есть свои недостатки. Стандартная
последовательность может отличаться от порядка, в котором прцессу в действительности
могут потребоваться ресурсы. Если, например, задание использует сначала НМЛ, а печатающее
устройство значительно позже, ему все равно придется сначала заказать печатающее устройство.
<p>
Однако разумное назначение номеров может сделать эти неудобства гораздо менее заметными.
<p>
Надо сказать, что этот метод в основном используется внутренними программами операционных
систем. 
<p>
<h2><a name="Восстановление">Обнаружение и восстановление</a></h2>
<p>
Все вышеописанные методы гарантируют отсутствие ситуаций клинча за счет весма осторожной
политики. Метод обнаружения и восстановления действует гораздо более решительно.
Не препятствуя возникновению клинча, метод предполагает его обнаружение и <I>восстановление</I>
прерваной им нормальной работы. Обнаружить клинч теоретически можно всегда, однако на 
практике это реализуется достаточно сложно. один из методов обнаружения клинчей описан ниже:
<OL>
<LI>Произвольно занумеровать все ресурсы и процессы в системе.
<LI>Разрешить процессам пользоваться программными блокировками при обращениях к ресурсам.
<LI>Создать таблицы, в которых собиралась бы вся информация о назначении ресурсов 
процессам и о процессах, блокированнных при попытке обрвщения к ресурсу.
<LI>Заносить в эти таблицы соответствующую информацию при всяком назначении или
освобождении ресурса.
<LI>В момент обработки запроса на уже занятый ресурс проверить наличие клинча, используя
алгоритм обнаружения клинча, представленный на рисунке 2.3<A HREF="../../literatura.html">[3]</a>.
</OL>
<center>
<IMG SRC="ris2_3.jpg" border=0 align=center  vspace=15> </A>

<p>
	Рисунок 2.3. Алгоритм распознавания клинчей.
</center>
<p>
Для иллюстрации описываемого метода обнаружения рассмотрим следующую последовательность
событий (Pj - процессы, li - ресурсы):
<OL>
<LI>P1 занимает l1.
<LI>P2 занимает l3.
<LI>P3 занимает l2.
<LI>P2 занимает l4.
<LI>P1 занимает l5.
<LI>P1 пытается обратиться к l3; так как l3 занят, необходима проверка по алгоритму (рисунок 2.3);
J=1; I=3; K=2;
Процесс K-> не ждет никакого ресурса I'-> блокировать P1;
<LI>P2 пытается обратиться к l2;
J=2; l=2; K=3; нет I'-> блокировать P2.
<LI>P3 пытается обратиться к l5;
J=3; l=5; k=1;
I'=3; K'=2;
2<>J, следовательно, взять K=2;
I'=2; K'=3; K'=J!->КЛИНЧ;
сохранить состояние процесса P3 для последующей попытки восстановления. 
</OL>
<p>
Применение этого метода избавляет от необходимости упорядочивать запросы на ресурсы.
Освобождение ресурсов может осуществляться под управлением регулировщика операционной
системы, перераспределение устройств производиться по мере возникновения запросов,
при этом лишь следует вносить изменения в таблицы RATBL и PWTBL.
<p>
Для правильного определения J каждый запрос к занятому ресурсу должен проверяться на 
клинч; во время этой проверки таблицы RATBL и PWTBL должны использоваться монопольно,
любые другие попытки доступа к ним должны быть заблокированы (что , разумеется требует 
уточнения рассмотренного алгоритма). После завершения проверки можно обрабатывать 
следующий запрос. Если не проводить блокирования доступа к таблицам, обработка
следующего запроса J' может внести в таблицы изменения еще во время  обработки предыдущего
запроса J. Это может привести , например, к идентификации клинча с результирующей
блокировкой процесса J вместо процесса J'. Необходимость такого упорядочивания запросов
приводит к возрастанию затрат времени, расходуемого супервизором на обработку запросов.
<p>
После обнаружения клинча необходимо восстановить нормальную работу системы. В принципе,
для того, чтобы выйти из клинча, одно из заданий должно освободить некоторые из
принадлежащих ему ресурсов. Общего решения этой проблемы не существует. Для того чтобы
корректно освободить ресурс, задание должно "вернуться" к точке, предшествующей
выдаче запроса на ресурс. Обычно такое "возвращения" является сложной задачей.
Для этого используют следующие методы:
<OL>
<LI>Для каждой программы подготавливается специальный <I><B>алгоритм возврата</I></B>, 
производящий обратные вычисления  и инвертирующий состояние процесса. 
<LI>Посредством выполнения операции КОНТРОЛЬНАЯ ТОЧКА, имеющейся в некоторых
операционных системах, производится "снимок" состояния процесса в момент, предшествющий
запросу на ресурс. "Снимок" используется для последующего восстановления этого
состояния.
</OL>
<p>
Метод контрольной точки широко применяется в системах реального времени и при обработке
данных очень большого объема для повышения нажежности, так как он необходим при 
восстановлении после сбоев оборудования.
<p>
С методом обнаружения и восстановления связан ряд проблем. Хотя обнаружение в принципе
всегда возможно, восстановление (возврат) не всегда представляется возможным или
экономически оправданным. Даже если оно возможно, его обычно трудно реализовать.
<p>
<h2><a name="Исследования">Исследования в области обработки клинчей</a></h2>
<p>
С расширением использования сложных мультипрограммных систем проблемы обработки 
клинчей привлекли к себе большое внимание. Это привело к появлению ряда исследовательских
работ (Кофман, 1971; Истон, 1971; Фонтао, 1971; Хаберман, 1969; Хавендер, 1968;
Холт, 1972; Мерфи, 1968; Нидхем, 1969)<A HREF="../../literatura.html">[3]</a>.
</html>