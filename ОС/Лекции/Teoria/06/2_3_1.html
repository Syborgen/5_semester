<html>
<head>
<title>Состязания</title>
</head>
<body>
<CENTER>
<H1>Состязания</H1>
<FONT SIZE="3">
</CENTER>
<I><B>Условие состязаний</B></I>, или гонок, возникает в случаях, когда параллельно
выполняемые процессы настолько "чувствительны" к порядку их обслуживания, что это
может отразиться на результатах их выполнения. Состязания являются следствием
совместного использования одного и того же ресурса двумя или большим числом прцессов.
<p> 
Допустим мультипрогаммно выполняются два процесса. Время от времени каждый из них
требует печати строки на одном и том же печатающем устройстве. В зависимости от принятого
алгоритма обслуживания может получится так, что вся выдача процесса 1 будет предшествовать 
выдаче процесса 2. Может получится и наоборот. Однако наиболее вероятно, что строки
выдачи обоих процессов будут перемешаны, что полностью лишает выдачу какого-либо 
смысла.
<p>
Один из способов избежать подобных недоразумений - потребовать, чтобы процессы явно выдавали
запросы на монопольное владение совместно используемым ресурсом (в данном случае печатающим
устройством). Ресурс может быть освобожден после того, как его использование процессом
полностью закончится. Операции <I>занять</I> и <I>освободить</I> обычно являются стандартными
функциями операционной системы, управляемыми регулировщиком. Если процесс обращается
к ресурсу, который уже занят, обслуживание процесса автоматически блокируется. Когда
ресурс освобождается и становится доступным, блокированный ранее процесс получает 
этот ресурс в свое распоряжение, и обслуживание процесса возобновляется.
<p>
Условия состязания могут возникнуть не только при распределении устройств, но и при
совместном других ресурсов, например общих таблиц в основной памяти, требующих аналогичных
методов синхронизации процессов.
<p>
Опишем планирование в однопроцессорной системе. Когда текущий процесс завершается 
или блокируется,необходимо<A HREF="../../literatura.html">[3]</a>:
<OL>
<LI>Найти текущий в очереди готовых процессов.
<LI>Пометить его "завершенным" или "отложенным".
<LI>Выбрать номер "следующего" процесса (17).
<LI>Найти процесс 17 в очереди готовых процессов.
<LI>Поместить процесс 17 "выполняющимся".
<LI>Поместить новый номер "следующего" процесса (18).
</OL>
<p>
Эти функции выполняются планировщиком процессов. Приведенный алгоритм хорошо работает
с одним процессором, но в системах с несколькими процессорами его использование приводит
к определенным трудностям.
<p>
 Пусть два процессора обслуживают каждый свой процесс и эти процессы примерно в одно
и то же время блокируются по вводу-выводу. Выполнив процедуру сохранения состояния 
прерванных процессов, каждый процессор выбирает себе следующий процесс для обслуживания.
Поскольку оба процессора применяют при этом один и тот же алгоритм независимо друг от
друга, они выберут в качестве следующего один и тот же процесс. Кроме этой ошибки, при 
обработке очереди готовых процессов возможны и другие ошибки. Например, может быть 
пропущен процесс, который следовало обслужить.
<p>
Опишем планирование в мультипроцессорной системе. Представим себе, что оба 
процессора завершили обработку своих текущих процессов одновременно:
<OL>
<LI>Процессор 1 находит свой текущий процесс в очереди готовых.
<LI>Процессор 2 находит свой текущий процесс в очереди готовых.
<LI>Процессор 1 помечает свой текущий процесс.
<LI>Процессор 2 помечает свой текущий процесс.
<LI>Процессор 1 выбирает номер "следующего" (17).
<LI>Процессор 2 выбирает номер "следующего" (17).
<LI>Процессор 1 находит процесс 17 в очереди и помечает его.
<LI>Процессор 2 находит процесс 17 в очереди и помечает его.
<LI>Процессор 1 помещает номер "следующего" (18).
<LI>Процессор 2 перемещает номер "следующего" (19)
</OL>
<p>
Теперь оба процессора параллельно обслуживают один и тот же процесс 17 (двойная работа),
а процесс 18 "потерян".
<p>
Подобные явления являются прямым  следствием асинхронного использования данных несколькими
процессорами. В операционных системах обычно имеется множество подобных данных,
например различные управляющие таблицы, используемые для распределения основной и 
внешней страничной памяти, очереди запросов на ввод-вывод и т. п.
<p>
Для разрешения описанной выше проблемы следует ввести синхронизацию независимо
работающих процессоров с учетом использования ими общих областей данных.
<p>
Перед обращением к очереди готовых процессов каждый процессор должен проверить 
состояние специального "бита блокировки". Если этот бит не включен, значит, в настоящий
момент данные, отображающие состояние процессов в очереди, не используются никаким
другим процессором. В этом случае "ищущий" процессор включает бит блокировки и
приступает к работе с очередью. После завершения обработки процессор должен вернуть
бит в состояние "выключен".Если второй процессор во время этой обработки попробует
получить доступ к очереди, то он найдет бит блокировки включенным и будет ожидать снятия 
блокировки. В таких условиях второй процессор как бы приостанавливается (не может
выполнять полезной работы). Эта ситуация называется<I><B> программной блокировкой процессора</I></B>.
То же самое может случится не только со вторым, но и стретьим и четвертым процессорами
или даже с любым числом процессоров одновременно.
<p>
Отметим, что в конфликтных ситуациях важна не только координация, но и кооперация 
процессов. Если процесс "забудет" освободить назначенный ему ресурс, этот ресурс уже 
никогда не будет доступендля использования никакими другими процессами. На практике
реализуют принудительное освобождение ресурсов при его завершении.
</html>