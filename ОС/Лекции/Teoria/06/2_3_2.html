<html>
<head>
<title>Механизмы синхронизации</title>
</head>
<body>
<CENTER>
<H1>Механизмы синхронизации</H1>
<FONT SIZE="3">
</CENTER>
<UL>
 <LI><A HREF="#КПУ">Команда ПРОВЕРИТЬ и УСТАНОВИТЬ </A>
 <LI><A HREF="#ОЖИДАНИЕ">Механизмы ОЖИДАНИЕ и ОПОВЕЩЕНИЕ</A>
 <LI><A HREF="#PV">Операции P и V над считающими семафорами</A>
 <LI><A HREF="#СООБЩЕНИЯ">Синхронизация посредством сообщений</A>
</UL>
<HR SIZE="4">
<p>
Для обеспечения координации и связи между процессами используются различные механизмы
синхронизации. В этом разделе мы коротко рассмотрим наиболее распространенные из них.
<p>
<h2><a name="КПУ">Команда ПРОВЕРИТЬ и УСТАНОВИТЬ</a></h2>
<p>
В большинстве случаев для целей синхронизации с ресурсом связывают некоторый объект, 
являющийся как бы замком к ресурсу. Такой объект чаще всего называют <I><B>байтом блокировки</I></B> или <I><B>семафором.</I></B> 
Для каждого ресурса (будь то устройство или данные ) должен сущестовать свой байт 
блокировки. Договоримся, что значение байта блокировки 0 соответствует доступности
ресурса; если же он равен 1, то ресурс занят. Перед обращением к ресурсу процесс должен
выполнить следующие шаги<A HREF="../../literatura.html">[3]</a>:
<OL>
<LI>Проверить значение байта блокировки (0 или 1).
<LI>Установить байт блокировки в 1.
<LI>Если первоначальное значение байта блокировки было равно 1, вернуться к шагу 1.
</OL>
<p>
После завершения использования ресурса процесс должен установить байт блокировки в 0.
<p>
Обратите внимание на то, что ни один из других процессов не должен иметь возможности
изменить значения байта блокировки в промежутке между шагами 1 и 2.
<p>
<h2><a name="ОЖИДАНИЕ">Механизмы ОЖИДАНИЕ и ОПОВЕЩЕНИЕ</a></h2>
<p>
Рассмотренный выше метод обеспечивает синхронизацию процессов, но является весьма неэффективным
с точки зрения использования процессоров. Для того, чтобы не пропустить момента снятия 
блокировки, процессор выеужден циклиться на проверке байта блокировки до тех пор, пока
этот байт не будет переведен в нулевое состояние, и тем самым не может использоваться
для выполнения какой бы то ни было "полезной" работы. Неразумно тратить такой важный
ресурс, как процессор, на обслуживание заблокированного процесса. Можно модифицировать
механизмы захвата и освобождения следующим образом:
<p>
ЗАНЯТЬ(X):
<OL>
<LI>Проверить значение байта блокировки (0 или 1).
<LI>Установить байт блокировки в 1.
<LI>Если первоначально значение байта блокировки было равно равно 1, выполнить 
функцию ОЖИДАНИЕ(X).                              
</OL>
ОСВОБОДИТЬ(X):
<OL>
<LI>Установить байт блокировки в 0.
<LI>Выполнить функцию ОПОВЕЩЕНИЕ(X).
</OL>
<p>
Операции ОЖИДАНИЕ (WAIT) и ОПОВЕЩЕНИЕ (SIGNAL) являются примитивами регулировщика 
операционной системы. ОЖИДАНИЕ(X) блокирует обслуживание процесса, делает отметку
об этом в PCB и связывает его с байтом блокировки(X). Планировщик процессов находит
другой готовый процесс и переводит освободившийся процессор на обслуживание этого
нового процесса. ОПОВЕЩЕНИЕ(X) просматривает связанный с байтом X список блокированных
процессов. Если в списке есть процессы, ожидающие освобождения ресурса X, один из
них переводится в состояние готовности, а в его PCB делается соответствующая отметка.
С этого момента "пробудившийся" процесс вновь становится доступным для выборки его
планировщиком процессов, т. е. равноправным претендентом на получение процессорного
времени.
<p>
ОЖИДАНИЕ и ОПОВЕЩЕНИЕ могут служить и для иных целей, таких, как синхронизация с
процессами ввода-вывода. После выдачи запроса на ввод-вывод  процесс может "подождать"
завершения обмена, используя опреацию ОЖИДАНИЕ(X), где Х - байт состояния устройства
Прерывание, свидетельствующее о завершении ввода-вывода, вызывает выполнение системой
операции ОПОВЕЩЕНИЕ(X).
<p>
<h2><a name="PV">Операции P и V над считающими семафорами</a></h2>
<p>
В 1968 г. Дейкстра предложил более общую форму механизма захвата/освобождения<A HREF="../../literatura.html"0>[3]</a>, которую
он назвал операциями P и V над <I><B>считающими семафорами.</I></B> Считающим семафором
называют целочисленную переменную, выполняющую те же функции, что и байт блокировки,
но в отличие от него могущую принимать другие положительные значения, а не только 0 или 1.
Операции могут быть определены следующим образом:
<p>
P(S):
<OL>
<LI>Уменьшить значение S на 1(S:=S-1). 
<LI>Если S меньше 0, выполнить ОЖИДАНИЕ(S).
</OL>
V(S):
<OL>
<LI>Увеличить значение S на 1 (S:=S+1).
<LI>Если S больше либо равно 0, выполнить ОПОВЕЩЕНИЕ(S)
</OL>
<p>
В зависимости от начального значения и количества используемых значений и количества
используемых семафоров операции P и V могут применяться для различных целей. В
случае использования одного семафора с начальным значением 0 функции P(S) и V(S)
эквивалентны операциям ОЖИДАНИЕ(S) и ОПОВЕЩЕНИЕ(S) соответственно.
<p>
Большой интерес вызывает использование этого алгоритма при решении задачи "производства\потребления"
(Дейкстра,1968; Деннинг,1971). Производитель помещает изготовленные единицы некой 
продукции в хранилище, откуда затем потребитель извлекает их для использования.
<p>
Максимальная вместимость хранилища - n единиц. Производитель не должен переполнять его,
а потребитель не должен пытаться брать продукцию из пустого хранилища. Используя два
семафора с начальными значениями S1=n и S2=0, можно следующим образом организовать
синхронизацию процессов производства и потребления<A HREF="../../literatura.html">[3]<a>:
<pre>
    ПРОЦЕСС ПРОИЗВОДСТВА Pпр                ПРОЦЕСС ПОТРЕБЛЕНИЯ Pпотр
    PRODUCE:                                CONSUME:
         . (изготовить   		        P(S2)
         . единицу			        .(взять из хранилища
         .продукции)				. единицу
      P(S1)					. товара)
	 .(поместить единицу			V(S1)
         .  в хранилище)			. (использовать
	 .					.  единицу)
      V(S2)					.
      GO TO PRODUCE				GO TO CONSUME

</pre>
<p>
Этот алгоритм можно применить также и для координации взаимодействия нескольких 
потребиителей.
<p>
<h2><a name="СООБЩЕНИЯ">Синхронизация посредством сообщений</a></h2>
<p>
Рассмотренные механизмы синхронизации обеспечивают косвенную связь между ними
посредством совместно используемых буферов или семафоров. В случаях, аналогичных
задаче производсва/потребления, проблема также может быть решена путем непосредственного
обмена сообщениями между процессами. Для этого используются операции ПОСЛАТЬ(Pr, M)
и ПРИНЯТЬ (Ps, M), где Pr и Ps - идентификаторы процессов, а M - собщение (некая строка
символов).
<p>
ПОСЛАТЬ (Pr, M) посылает сообщение M в адрес процесса Pr; сообщение будет храниться
в системе до тех пор, пока принимающий процесс не получит его. ПРИНЯТЬ (Ps, M) предоставляет
порожденное процессом Ps сообщение M (если такое существует в данный момент) в распоряжение
процесса, выполняющего эту операцию. Если для процесса, выдавшего запрос, сообщений нет,
он блокируется до тех пор, пока нужное сообщение не будет послано. Буферизация 
сообщений и синхронизация авоматически обеспечиваются примитивами ПОСЛАТЬ и ПРИНЯТЬ.
</html>

