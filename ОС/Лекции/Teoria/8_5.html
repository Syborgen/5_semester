<HTML>
<HEAD>
<TITLE>Обнаружение и устранение взаимоблокировок</TITLE>
</HEAD>
<body>
  <b><font size="6"><center>Обнаружение и устранение взаимоблокировок</center></font></b><br>
  <br>
  Вторая техника представляет собой обнаружение и восстановление. При использовании 
  этого метода система не пытается предотвратить попадание в тупиковые ситуации. 
  Вместо этого она позволяет взаимоблокировке произойти, старается определить, 
  когда это случилось, и затем совершает некие действия к возврату системы к состоянию, 
  имевшему место до того, как система попала в тупик. В этом разделе мы рассмотрим 
  некоторые из способов обнаружения тупиковых ситуаций и выхода из них.<br>
  <br>
  <br>
<a NAME="01"></a>
  <b><font size="4">Обнаружение взаимоблокировки при наличии одного ресурса каждого 
  типа</font></b><br>
  <br>
  Начнем с самого простого варианта: в системе существует только один ресурс каждого 
  типа. Подобная система могла бы иметь один сканер, одно устройство для записи 
  компакт-дисков, один плоттер и один накопитель на магнитной ленте, то есть не 
  более чем по одному представителю каждого класса. Другими словами, мы исключаем 
  из рассмотрения системы с двумя одновременно подключенными принтерами. Мы обратимся 
  к ним позже и будем использовать другой метод.<br>
<dd> Для такой системы можно сконструировать граф ресурсов вида, продемонстрированного 
  на рис. 3.3. Если этот граф содержит один или больше циклов, значит, произошла 
  взаимоблокировка и блокирован любой процесс, являющийся частью цикла. Если в 
  графе нет циклов, система не попала в тупик.<br>
<dd> В качестве примера более сложной системы, чем те, которые мы рассматривали 
  до сих пор, обсудим систему с семью процессами, обозначенными буквами от <i>А</i> 
  до <i>G,</i> и шестью ресурсами, обозначенными буквами от <i>R</i> до <i>W.</i> 
  Состояние системы, то есть то, какой процесс владеет каким ресурсом и какой 
  ресурс запрашивается процессом в данный момент, соответствует следующему списку:<br>
  <br>
<dd> 1. Процесс <i>А</i> занимает ресурс <i>R</i> и хочет получить ресурс <i>S.</i><br>
<dd> 2.<i></i> Процесс В<i></i> ничего не использует, но хочет получить ресурс 
  <i>Т.</i><br>
<dd> 3. Процесс С ничего не использует, но хочет получить ресурс <i>S</i>.<br>
<dd> 4. Процесс <i>D</i> занимает ресурс <i>U</i> и хочет получить ресурсы <i>S</i> 
  и <i>T</i>.<br>
<dd> 5. Процесс E занимает ресурс <i>Т</i> и хочет получить ресурс <i>V.</i><br>
<dd> 6. Процесс F<i></i> занимает ресурс W и хочет получить ресурс <i>S</i>.<br>
<dd> 7. Процесс <i>G</i> занимает ресурс <i>V</i> и хочет получить ресурс <i>U.</i><br>
  <br>
<dd> Вопрос: &laquo;Заблокирована ли эта система и если да, то какие процессы 
  в этом участвуют?&raquo;<br>
  <br>
<dd> Чтобы ответить на этот вопрос, мы можем составить граф ресурсов (рис. 3.3, 
  <i>а).</i> Этот граф содержит один цикл, который виден при визуальном обследовании. 
  Цикл показан на рис. 3.3, <i>б.</i> Изучая его, можно заметить, что процессы 
  Д, E и G заблокированы. Процессы <i>А, С</i> и <i>F</i> не попали в тупик, потому 
  что любому из них можно предоставить ресурс S, после чего процесс, получивший 
  ресурс, закончит свою работу и вернет ресурс. Затем два других процесса по очереди 
  могут получить ресурс и также успешно выполнить свою работу.<br>
  <center>
    <br>
    <img src="08/Tanenbaum_3_3.jpg" alt="Граф ресурсов (а); цикл, извлеченный из а (б)"><br>
    <br>
    <b><font face="Arial">Рис. 3.3.</font></b><font face="Arial"> Граф ресурсов 
    (а); цикл, извлеченный из а (б)</font><br>
  </center>
  <br>
<dd> Несмотря на то что в простом графе относительно легко зрительно различить 
  взаимоблокировку процессов, для использования такой схемы в настоящей системе 
  нам необходим формальный алгоритм, выявляющий тупики. Известно множество алгоритмов, 
  обнаруживающих циклы в направленных графах. Ниже мы рассмотрим простой алгоритм, 
  который изучает граф и завершается или когда находит цикл, или когда показывает, 
  что циклов в этом графе не существует. Он использует одну структуру данных — 
  список узлов <i>L.</i> Во время работы алгоритма на ребрах графа будет ставиться 
  метка, говорящая о том, что их уже проверили, это делается во избежание повторной 
  проверки.<br>
<dd> Алгоритм работает, осуществляя пять перечисленных ниже шагов.<br>
  <br>
<dd> 1. Для каждого узла <i>N</i> в<i></i> графе выполняются следующие пять шагов, 
  где <i>N</i> явля<i></i>ется начальным узлом.<br>
<dd> 2. Задаем начальные условия: <i>L</i> — пустой список, все ребра не маркированы.<br>
<dd> 3. Текущий узел добавляем в конец списка <i>L</i> и проверяем количество 
  появлений узла в списке. Если узел присутствует в двух местах, граф содержит 
  цикл (записанный в список <i>L</i>) и работа алгоритма завершается.<br>
<dd> 4. Для заданного узла смотрим, выходит ли из него хотя бы одно немаркированное 
  ребро. Если да, то переходим к шагу 5, если нет, то переходим к шагу 6.<br>
<dd> 5. Случайным образом выбираем любое немаркированное исходящее ребро и отмечаем 
  его. Затем по нему переходим к новому текущему узлу и возвращаемся к шагу 3.<br>
<dd> 6. Теперь мы зашли в тупик. Удаляем последний узел из списка и возвращаемся 
  к предыдущему узлу, то есть тому, который был текущим перед тупиковым узлом. 
  Обозначаем его текущим узлом и возвращаемся к шагу 3. Если это первоначальный 
  узел, граф не содержит циклов и алгоритм завершается.<br>
  <br>
<dd> Этот алгоритм по очереди берет каждый узел в качестве корня того, что, как 
  он надеется, окажется деревом, и выполняет в дереве поиск в глубину. Если в 
  процессе обхода алгоритм возвращается к уже встречавшемуся узлу, то он нашел 
  цикл. Если алгоритм обходит все ребра из какого-нибудь заданного узла, то он 
  возвращается к предыдущему узлу. Если он возвращается к корню и не может идти 
  дальше, то подграф текущего узла не содержит циклов. Если данное свойство сохраняется 
  для всех узлов, значит, полный граф не содержит циклов, а система не заблокирована.<br>
<dd> Чтобы увидеть, как работает описанный алгоритм на практике, воспользуемся 
  графом на рис. 3.3, <i>а.</i> Порядок обработки узлов произвольный, поэтому 
  будем исследовать их слева направо и сверху вниз. Тогда алгоритм начнет поиск 
  с узла <i>R,</i> затем последовательно с узлов <i>А, В, С, S, D, Т, Е, F</i> 
  и т. д. Если мы натолкнемся на цикл, алгоритм остановится.<br>
<dd> Мы начинаем с узла <i>R</i> и инициализируем <i>L</i> как пустой список. 
  Затем добавляем узел <i>R</i> в список, переходим к единственно возможному узлу 
  <i>А,</i> и его также добавляем к списку <i>L, </i> получая <i>L</i> = <i>[R, 
  А].</i> Из узла <i>А</i> следуем к узлу <i>S, </i> получая <i>L</i> = <i>[R, 
  A, S].</i> Узел <i>S</i> не имеет исходящих ребер, следовательно, это тупик, 
  который заставляет нас вернуться к узлу <i>А.</i> Так как у узла <i>А</i> тоже 
  нет немаркированных исходящих ребер, мы возвращаемся к узлу <i>R,</i> завершая, 
  таким образом, его исследование.<br>
<dd> Теперь снова начнем поиск, стартуя с узла <i>А</i> и предварительно вернув 
  список <i>L</i> в исходное состояние. Эта часть алгоритма тоже быстро остановится, 
  поэтому выполним процесс заново, начиная с узла <i>В.</i> Из узла <i>В</i> алгоритм 
  будет следовать исходящим ребрам до тех пор, пока не достигнет узла <i>D;</i> 
  в это время список будет<br>
<dd> таким: <i>L = [В, Т, Е, V, G, U, D]. </i> Теперь мы должны сделать (случайный) 
  выбор. Если выбрать узел 5, мы попадаем в тупик и возвращаемся к узлу <i>D.</i> 
  Во второй раз выбираем узел <i>Т</i> и получаем измененный список <i>L</i> = 
  <i>[В, Т, Е, V, G, U, D, Т];</i> в этот момент мы обнаруживаем цикл и останавливаем 
  алгоритм.<br>
<dd> Этот алгоритм далек от оптимального. Лучшая схема описана в [112]. Тем не 
  менее он демонстрирует существование алгоритма для обнаружения взаимоблокировок.<br>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Обнаружение взаимоблокировок при наличии нескольких ресурсов 
  каждого типа</font></b><br>
  <br>
  Когда в системе существует несколько экземпляров некоторых из ресурсов, для 
  обнаружения взаимоблокировок необходим другой метод. Сейчас мы расскажем об 
  основанном на матрицах алгоритме, обнаруживающем тупики среди <i>п</i> процессов, 
  от <i>Р</i><sub>1</sub> до <i>Р</i><sub>n</sub><i>. </i> Пусть <i>т —</i> это 
  число классов ресурсов, причем в системе E<sub>1</sub>, ресурсов класса 1, <i>Е<sub>2</sub></i> 
  ресурсов класса 2 и, в общем, E<i><sub>i</sub></i>, ресурсов класса <i>i</i> 
  (где 1 <b>&lt;=</b><i>i<b>&lt;=</b> т). Е —</i> это <b>вектор существующих ресурсов.</b> 
  Он передает общее количество имеющихся в наличии экземпляров каждого ресурса. 
  Например, если класс 1 представляет собой накопители на магнитных лентах, то 
  E<sub>1</sub> = 2 означает, что в системе есть два магнитофона.<br>
<dd> В любой момент времени некоторые из ресурсов могут оказаться занятыми и, 
  соответственно, недоступны. Пусть <i>А </i> будет <b>вектором доступных ресурсов,</b> 
  где <i>A<sub>i</sub></i> равно количеству экземпляров ресурса <i>i,</i> доступных 
  в текущий момент (то есть не использующихся). Если оба накопителя на магнитной 
  ленте заняты, <i>A</i><sub>1</sub><i> </i> будет равно 0.<br>
<dd> Теперь нам нужны два массива: <b><i>С —</i> матрица текущего распределения</b> 
  и <b><i>R —</i> матрица запросов,</b> <i>i</i>-я строка в матрице <i>С</i> говорит 
  о том, сколько представителей каждого класса ресурсов в данный момент использует 
  процесс Р<i><sub>i</sub></i>. Таким образом, <i>С<sub>ij</sub> —</i> это количество 
  экземпляров ресурса <i>j</i>, которое занимает процесс <i>i</i>. Аналогично, 
  <i>R<sub>ij</sub> —</i> это количество экземпляров ресурса <i>j</i>, которые 
  хочет получить процесс Р<i><sub>i</sub></i>. Эти четыре структуры показаны на 
  рис. 3.4.<br>
  <center>
    <br>
    <img src="08/Tanenbaum_3_4.jpg" alt="Четыре структуры данных, необходимые для алгоритма обнаружения тупиков"><br>
    <br>
    <font face="Arial"><b>Рис. 3.4.</b> Четыре структуры данных, необходимые для 
    алгоритма обнаружения тупиков</font><br>
  </center>
  <br>
<dd> Для этих четырех структур данных существует важный инвариант. В принципе 
  каждый ресурс или занят, или свободен. Это наблюдение означает, что<br>
  <center>
    <img src="08/Tanenbaum_3_5.jpg"><br>
  </center>
  <br>
<dd> Другими словами, если сложить все экземпляры ресурса <i>j</i>, предоставленные 
  процессам и доступные в данный момент, то в результате мы получим существующее 
  в системе количество экземпляров этого класса ресурсов.<br>
<dd> Алгоритм обнаружения взаимоблокировок основан на сравнении векторов. Определим, 
  что для двух векторов <i>А</i> и <i>В </i> отношение <i>А &lt;= В</i> означает, 
  что каждый элемент вектора <i>А</i> меньше или равен соответствующему элементу 
  вектора <i>В.</i> Математически это запишется так: <i>А &lt;= В</i> тогда и 
  только тогда, когда <i>А<sub>i</sub> &lt;= В<sub>i</sub> </i> для 1 &lt;= <i>i 
  </i>&lt;= <i>т.</i><br>
<dd> Пусть в исходном положении все процессы не маркированы. По мере продвижения 
  алгоритма на процессы будет ставиться отметка, служащая признаком того, что 
  они могут закончить свою работу и, следовательно, не находятся в тупике. После 
  завершения алгоритма известно, что любой немаркированный процесс находится в 
  тупиковой ситуации.<br>
<dd> Алгоритм обнаружения тупиков состоит из следующих шагов:<br>
  <br>
<dd> 1. Ищем немаркированный процесс <i>Р<sub>i</sub>, </i> для которого <i>i-я</i> 
  строка матрицы <i>R</i> меньше вектора <i>А</i> или равна ему.<br>
<dd> 2. Если такой процесс найден, прибавляем <i>i</i>-ю строку матрицы <i>С к</i> 
  вектору <i>А,</i> маркируем процесс и возвращаемся к шагу 1.<br>
<dd> 3. Если таких процессов не существует, работа алгоритма заканчивается.<br>
  <br>
<dd> Завершение алгоритма означает, что все немаркированные процессы, если такие 
  есть, попали в тупик.<br>
  <br>
<dd> На первом шаге алгоритм ищет процесс, который может доработать до конца. 
  Такой процесс характеризуется тем, что все требуемые для него ресурсы должны 
  находиться среди доступных в данный момент ресурсов. Тогда выбранный процесс 
  проработает до своего завершения и после этого вернет ресурсы, которые он занимал, 
  в общий фонд доступных ресурсов. Затем процесс маркируется как законченный. 
  Если окажется, что все процессы могут работать, тогда ни один из них в данный 
  момент не заблокирован. Если некоторые из них никогда не смогут запуститься, 
  значит, они попали в тупик. Несмотря на то что алгоритм не является детерминированным 
  (поскольку он может просматривать процессы в любом допустимом порядке), результат 
  всегда одинаков.<br>
<dd> Для иллюстрации работы алгоритма обнаружения тупиков рассмотрим рис. 3.5. 
  Здесь у нас есть три процесса и четыре класса ресурсов, которые мы произвольно 
  назвали так: накопители на магнитной ленте, плоттеры, сканеры и устройство для 
  чтения компакт-дисков. Процесс 1 использует один сканер. Процесс 2 занял два 
  накопителя на магнитной ленте и устройство для чтения компакт-дисков. Процесс 
  3 занимает плоттер и два сканера. Каждый процесс нуждается в дополнительном 
  устройстве, как показывает матрица <i>R.</i><br>
<dd> Работая с алгоритмом обнаружения взаимоблокировок, мы ищем процесс, чей запрос 
  ресурсов может быть удовлетворен в данной системе. Требования первого процесса 
  нельзя выполнить, потому что в системе нет доступного устройства для чтения 
  компакт-дисков. Второй запрос также нельзя удовлетворить, так как нет<br>
<dd> свободных сканеров. К счастью, третий процесс может получить все желаемое, 
  следовательно, он работает, завершается и возвращает все свои ресурсы, давая:<br>
  <center>
    <font face="Arial">А = (2 2 2 0)</font>.<br>
  </center>
  <br>
<dd> С этого момента может выполняться процесс 2, по окончании возвращая свои 
  ресурсы в систему. Мы получим:<br>
  <br>
  <center>
    <font face="Arial">А = (4 2 2 1)</font>.<br>
  </center>
  <br>
<dd> Теперь может работать оставшийся процесс. В этой системе не возникает взаимоблокировки.<br>
  <center>
    <br>
    <img src="08/Tanenbaum_3_6.jpg" alt="Пример использования алгоритма обнаружения тупиков"><br>
    <br>
    <font face="Arial"><b>Рис. 3.5.</b> Пример использования алгоритма обнаружения 
    тупиков</font><br>
  </center>
  <br>
<dd> Теперь обсудим немного измененный вариант ситуации на рис. 3.5. Предположим, 
  что процесс 3, кроме двух накопителей на магнитной ленте и плоттера, нуждается 
  также и в устройстве для чтения компакт-дисков. Тогда ни один из запросов не 
  может быть удовлетворен, значит, вся система находится в тупике.<br>
<dd> Мы уже знаем, как обнаружить взаимоблокировки, и появляется вопрос: когда 
  нужно искать их возникновение. Можно проверять систему каждый раз, когда запрашивается 
  очередной ресурс. Это, конечно, позволит обнаружить тупик максимально рано (насколько 
  это возможно), но такая операция может оказаться дорогой в смысле времени загрузки 
  процессора. Альтернативный подход: проверять систему каждые <i>k</i> минут, 
  или, может быть, только когда степень занятости процессора меньше некоторого 
  граничного значения. Учет загрузки процессора имеет смысл, потому что при достаточно 
  большом количестве заблокированных процессов работоспособных процессов в системе 
  останется немного, и процессор часто будет незанятым.<br>
  <br>
  <br>
<a NAME="03"></a>
  <b><font size="4">Выход из взаимоблокировки</font></b><br>
  <br>
  Предположим, что наш алгоритм обнаружения взаимоблокировок закончился успешно 
  и нашел тупик. Что дальше? Необходимы методы для восстановления и получения 
  в итоге снова работающей системы. В этом разделе мы обсудим различные способы 
  ликвидации взаимоблокировок. Однако ни один из них не является особо заманчивым.<br>
  <br>
  <br>
  <b>Восстановление при помощи принудительной выгрузки ресурса</b><br>
  <br>
  Иногда можно временно отобрать ресурс у его текущего владельца и отдать его 
  другому процессу. Во многих случаях требуется ручное вмешательство, особенно 
  в операционных системах пакетной обработки, работающих на мэйнфреймах.<br>
<dd> Например, чтобы забрать лазерный принтер у использующего его процесса, оператор 
  может взять все уже напечатанные листы и сложить их в стопку, соблюдая последовательность 
  их появления из принтера. Затем процесс можно приостановить (пометить как неработоспособный). 
  В этот момент принтер можно предоставить другому процессу. Когда он закончит 
  работу, можно сложить стопку напечатанных листов обратно на выходной поднос 
  принтера и возобновить первоначальный процесс.<br>
<dd> Способность забирать ресурс у процесса, отдавать его другому процессу и затем 
  возвращать назад так, что исходный процесс этого не замечает, в значительной 
  мере зависит от свойств ресурса. Выйти из тупика таким образом зачастую трудно 
  или невозможно. Выбор приостанавливаемого процесса главным образом зависит от 
  того, какой процесс владеет ресурсами, которые легко могут быть у него отняты.<br>
  <br>
  <br>
  <b>Восстановление через откат</b><br>
  <br>
  Если разработчики системы и машинные операторы знают о том, что есть вероятность 
  появления взаимоблокировок, они могут организовать работу таким образом, чтобы 
  процессы периодически создавали контрольные точки. Создание процессом контрольной 
  точки означает, что состояние процесса записывается в файл, в результате чего 
  впоследствии процесс может быть возобновлен из этого файла. Контрольные точки 
  содержат не только образ памяти, но и состояние ресурсов, то есть информацию 
  о том, какие ресурсы в данный момент предоставлены процессу. Для большей эффективности 
  новая контрольная точка должна записываться не поверх старой, а в новый файл, 
  так что во время выполнения процесса образуется целая последовательность контрольных 
  точек.<br>
<dd> Когда взаимоблокировка обнаружена, достаточно просто понять, какие ресурсы 
  нужны процессам. Чтобы выйти из тупика, процесс, занимающий необходимый ресурс, 
  откатывается к тому моменту времени, перед которым он получил данный ресурс, 
  для чего запускается одна из его контрольных точек. Вся работа, выполненная 
  после этой контрольной копии, теряется (например, выходные данные, напечатанные 
  позднее контрольной копии, отбрасываются и позже печатаются заново). В результате 
  процесс вновь запускается с более раннего момента, когда он не занимал тот ресурс, 
  который теперь предоставляется одному из процессов, попавших в тупик. Если возобновленный 
  процесс снова пытается получить данный ресурс, ему придется ждать того момента, 
  когда ресурс опять станет доступен.<br>
  <br>
  <br>
  <b>Восстановление путем уничтожения процессов</b><br>
  <br>
  Грубейший, но одновременно и простейший способ выхода из ситуации взаимоблокировки 
  заключается в уничтожении одного или нескольких процессов. Можно уничтожить 
  процесс, находящийся в цикле взаимоблокировки. При небольшом везении другие 
  процессы смогут продолжить работу. Если первое удаление не помогает, процедуру 
  можно повторять до тех пор, пока цикл наконец не будет разорван.<br>
<dd> Можно, наоборот, в качестве жертвы выбрать процесс, не находящийся в цикле, 
  чтобы он освободил свои ресурсы. При этом подходе уничтожаемый процесс выбирается 
  с особой тщательностью, потому что он должен занимать ресурсы, которые нужны 
  некоторым процессам в цикле. Например, один процесс может использовать принтер 
  и требовать плоттер, другой, наоборот, получил плоттер и запрашивает принтер. 
  Оба попали в тупик. Третий процесс может удерживать другие принтер и плоттер 
  и успешно работать. Уничтожение третьего процесса приведет к освобождению этих 
  ресурсов и разрушит взаимоблокировку первых двух процессов.<br>
<dd> Там, где это возможно, лучше всего уничтожать те процессы, которые можно 
  запустить с самого начала без всяких болезненных эффектов. Например, процедуру 
  компиляции всегда можно повторить заново, поскольку она всего лишь читает исходный 
  файл и создает объектный файл. Если процедуру компиляции уничтожить в процессе 
  работы, первый ее запуск не повлияет на второй<br>
<dd> С другой стороны, процесс, который обновляет базу данных, не всегда можно 
  успешно выполнить во второй раз. Если процесс прибавляет 1 к какой-нибудь записи 
  в базе данных, то его запуск, потом уничтожение, затем повторный запуск приведут 
  к прибавлению к записи 2, что неверно.<br>
</BODY>
</HTML>
