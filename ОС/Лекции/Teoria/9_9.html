<HTML>
<HEAD>
<TITLE>Сегментация</TITLE>
</HEAD>
<body>
  <b><font size="6"><center>Сегментация</center></font></b><br>
  <br>
  Обсуждавшаяся до сих пор виртуальная память представляет собой одномерное пространство, 
  потому что виртуальные адреса идут один за другим от 0 до некоторого максимума. 
  Для многих задач наличие двух и более отдельных виртуальных адресных пространств 
  может оказаться намного лучше, чем всего одно. Например, у компилятора есть 
  много таблиц, которые формируются по мере трансляции, возможно, включая в себя:<br>
  <br>
<dd> 1. Исходный текст, сохраненный для печати листинга (в пакетных системах).<br>
<dd> 2. Символьную таблицу, содержащую имена и атрибуты переменных.<br>
<dd> 3. Таблицу, содержащую все используемые константы: целые и с плавающей точкой.<br>
<dd> 4. Дерево грамматического разбора, содержащее синтаксический анализ программы.<br>
<dd> 5. Стек, используемый для процедурных вызовов внутри компилятора.<br>
  <br>
<dd> Во время компиляции каждая из первых четырех таблиц непрерывно растет. Последняя 
  таблица при компиляции непредсказуемо увеличивается или уменьшается. В одномерной 
  памяти эти пять таблиц должны были бы размещаться в смежных частях виртуального 
  адресного пространства, как на рис. 4.33.<br>
<dd> Рассмотрим, что происходит, если программа имеет исключительно большое число 
  переменных, но нормальное количество всего остального. Участок адресного пространства, 
  предоставленный для таблицы кодировки символов, может заполниться, но в других 
  таблицах, скорее всего, останется пустым множество ячеек. Конечно, компилятор 
  может просто создать сообщение о том, что компиляция не может продолжаться вследствие 
  слишком большого количества переменных, но нам кажется, что такое решение проблемы 
  не спортивно, когда в других таблицах осталась масса неиспользованного места.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_35.jpg" alt="В одномерном адресном пространстве при росте таблиц одна может упереться в другую"><br>
    <br>
    <b>Рис. 4.33.</b> В одномерном адресном пространстве при росте таблиц одна 
    может упереться в другую<br>
  </center>
  <br>
<dd> При другом варианте можно поиграть в Робин Гуда, забирая пространство из 
  таблиц с излишеством ячеек и передавая их таблицам с их недостатком. Такая перетасовка 
  реализуема, но она аналогична управлению собственными оверлеями, что представляет 
  собой маленькое неудобство в лучшем случае и большое количество скучной и неоплачиваемой 
  работы в худшем случае.<br>
<dd> На самом деле необходим метод, освобождающий программиста от управления расширяющимися 
  и сокращающимися таблицами тем же самым способом, которым виртуальная память 
  устраняет беспокойство организации программ с оверлеями.<br>
<dd> Простое и предельно общее решение заключается в том, чтобы обеспечить машину 
  множеством полностью независимых адресных пространств, называемых сегментами. 
  Каждый сегмент содержит линейную последовательность адресов от О до некоторого 
  максимума. Длина каждого сегмента может быть любой от нуля до разрешенного максимума. 
  Различные сегменты могут быть различной длины. Более того, длины сегментов могут 
  изменяться во время выполнения. Длина сегмента стека может увеличиваться всякий 
  раз, когда что-либо помещается в стек, и уменьшаться при выборке данных из стека.<br>
<dd> Поскольку каждый сегмент составляет отдельное адресное пространство, разные 
  сегменты могут расти или сокращаться независимо друг от друга. Если стек, находящийся 
  в определенном сегменте, нуждается в большем количестве адресного пространства 
  для роста, он может получить его, потому что в его адресном пространстве нет 
  больше ничего, с чем можно столкнуться. Конечно, сегмент может заполниться, 
  но сегменты обычно очень большие, поэтому такие инциденты редки. Чтобы определить 
  адрес в такой сегментированной или двумерной памяти, программа должна указать 
  адрес, состоящий из двух частей: номер сегмента и адрес внутри сегмента.<br>
<dd> Рисунок 4.34 иллюстрирует сегментированную память, использующуюся для обсуждавшихся 
  ранее таблиц компилятора. Здесь показаны пять независимых сегментов.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_36.jpg" alt="Сегментированная память позволяет каждой таблице расти или уменьшаться независимо от других таблиц"><br>
    <br>
    <b>Рис. 4.34.</b> Сегментированная память позволяет каждой таблице расти или<br>
    уменьшаться независимо от других таблиц<br>
  </center>
  <br>
<dd> Стоит подчеркнуть, что сегмент — это логический объект, о чем программист 
  знает и поэтому использует его как логический объект. Сегмент может иметь в 
  составе процедуру, массив, стек или набор скалярных переменных, но обычно он 
  не содержит смеси различных типов.<br>
<dd> Помимо простоты управления увеличивающимися или сокращающимися структурами 
  данных, сегментированная память обладает и другими преимуществами. Если каждая 
  процедура занимает отдельный сегмент и адрес 0 — это ее начальный адрес, компоновка 
  отдельно скомпилированных процедур происходит намного проще. После того как 
  все процедуры, составляющие программу, будут скомпилированы и скомпонованы, 
  для адресации слова 0 (начальной точки) обращение к процедуре в сегменте <i>n</i> 
  будет использовать адрес, состоящий из двух частей (<i>n</i>, 0).<br>
<dd> Если потом процедура в сегменте <i>n </i> модифицируется и компилируется 
  заново, не нужно изменять другие процедуры (потому что начальный адрес остался 
  тем же), даже если новая версия больше предыдущей. В одномерной памяти процедуры 
  упакованы одна к другой и между ними нет свободного адресного пространства. 
  В результате изменение размера одной процедуры может повлиять на начальный адрес 
  другой, не имеющей отношения к первой процедуре. Это, в свою очередь, требует 
  модификации всех процедур, вызывающих любую из передвинутых процедур, чтобы 
  поместить в них новые начальные адреса. Если программа содержит сотни процедур, 
  такой процесс очень дорог.<br>
<dd> Сегментация также облегчает совместное использование процедур и данных несколькими 
  процессами. Общим примером является библиотека совместного доступа. Современные 
  рабочие станции, работающие с передовыми оконными системами, часто имеют крайне 
  большие графические библиотеки, являющиеся составляющими практически каждой 
  программы. В сегментированных системах графические библиотеки могут располагаться 
  в отдельном сегменте и совместно использоваться несколькими процессами, что 
  устраняет необходимость их присутствия в адресном пространстве каждого процесса. 
  В принципе в системах с чистой страничной организацией памяти также можно иметь 
  совместно используемые библиотеки, но это намного сложнее в реализации. Поэтому 
  такие системы предоставляют совместный доступ путем моделирования сегментации.<br>
<dd> Поскольку каждый сегмент формирует логический объект (такой как процедура, 
  массив или стек), с которым общается программист, у различных сегментов могут 
  быть разные виды защиты. Сегмент процедуры может быть определен как только исполняемый, 
  что запрещает попытки чтения из него или сохранения в него. Для массива чисел 
  с плавающей точкой можно разрешить режим доступа чтение/запись, но не исполнение, 
  чтобы отлавливать попытки передачи управления по адресам, на которых располагается 
  массив. Такая защита полезна при обнаружении ошибок программирования.<br>
<dd> Вы должны попытаться понять, почему защита имеет смысл в сегментированной 
  памяти, а не в одномерной страничной памяти. В сегментированной памяти пользователь 
  осведомлен о том, что представляет собой каждый сегмент. В обычном случае сегмент 
  не может содержать, например, и процедуру и стек, а только либо первое, либо 
  второе. Так как каждый сегмент содержит только один тип объектов, он может иметь 
  защиту, соответствующую этому конкретному типу. Страничная организация памяти 
  и сегментация сравниваются в табл. 4.3.<br>
<dd> Содержимое страниц в известной степени случайно. Программист не осведомлен 
  даже о том факте, что происходит страничная подкачка. Хотя добавление нескольких 
  битов в каждую запись таблицы страниц для определения разрешенного доступа в 
  принципе возможно, но, чтобы использовать это свойство, программист должен был 
  бы отслеживать, где находятся границы страниц в его адресном пространстве. Это 
  представляет собой в точности тот вид администрирования, для устранения которого 
  была придумана страничная подкачка. Поскольку пользователь сегментированной 
  памяти имеет дело с иллюзией постоянного нахождения всех сегментов в оперативной 
  памяти — то есть он может адресоваться к ним так, как будто они существуют, 
  — он может защищать сегменты по отдельности, не заботясь об управлении их загрузкой 
  в память.<br>
  <center>
    <br>
    <b>Таблица 4.3.</b> Сравнение страничной организации памяти и сегментации<br>
    <TABLE border=1 cellPadding=0 cellSpacing=0 frame=box height=41 rules=all width=720>
      <TBODY> 
      <TR align=left vAlign=top> 
        <TD align=left height=42 vAlign=center width=281><b>Вопрос</b></TD>
        <TD align=left height=42 vAlign=center width=212><b>Страничная память</b></TD>
        <TD align=left height=42 vAlign=center width=264><b>Сегментация</b></TD>
      </TR>
      <TR align=left vAlign=top> 
        <TD align=left height=3 vAlign=top width=281>Нужно ли программисту знать 
          о том, что используется эта техника?</TD>
        <TD align=left height=3 vAlign=top width=212>Нет</TD>
        <TD align=left height=3 vAlign=top width=264>Да</TD>
      </TR>
      <TR align=left vAlign=top> 
        <TD align=left height=4 vAlign=top width=281>Сколько в системе линейных 
          адресных пространств?</TD>
        <TD align=left height=4 vAlign=top width=212>1</TD>
        <TD align=left height=4 vAlign=top width=264>Много</TD>
      </TR>
      <TR align=left vAlign=top> 
        <TD align=left height=1 vAlign=top width=281>Может ли суммарное адресное 
          пространство превышать размеры физической памяти?</TD>
        <TD align=left height=1 vAlign=top width=212>Да</TD>
        <TD align=left height=1 vAlign=top width=264>Да</TD>
      </TR>
      <TR align=left vAlign=top> 
        <TD align=left height=7 vAlign=top width=281>Возможно ли разделение процедур 
          и данных, а также раздельная защита для них?</TD>
        <TD align=left height=7 vAlign=top width=212>Нет</TD>
        <TD align=left height=7 vAlign=top width=264>Да</TD>
      </TR>
      <TR align=left vAlign=top> 
        <TD align=left height=7 vAlign=top width=281>Легко ли размещаются таблицы 
          с непостоянными размерами?</TD>
        <TD align=left height=7 vAlign=top width=212>Нет</TD>
        <TD align=left height=7 vAlign=top width=264>Да</TD>
      </TR>
      <TR align=left vAlign=top> 
        <TD align=left height=1 vAlign=top width=281>Облегчен ли совместный доступ 
          пользователей к процедурам?</TD>
        <TD align=left height=1 vAlign=top width=212>Нет</TD>
        <TD align=left height=1 vAlign=top width=264>Да</TD>
      </TR>
      <TR align=left vAlign=top> 
        <TD align=left height=1 vAlign=top width=281>Зачем была придумана эта 
          техника?</TD>
        <TD align=left height=1 vAlign=top width=212>Чтобы получить большое линейное 
          адресное пространство без дополнительных затрат на физическую память</TD>
        <TD align=left height=1 vAlign=top width=264>Для возможности разбиения 
          программ и данных на логически независимые адресные пространства, облегчения 
          совместного доступа и защиты</TD>
      </TR>
    </TABLE>
  </center>
  <br>
  <br>
<a NAME="01"></a>
  <b><font size="4">Реализация сегментации</font></b><br>
  <br>
  Реализация сегментации существенно отличается от страничной организации памяти: 
  страницы имеют фиксированный размер, а сегменты — нет. На рис. 4.35, <i>а</i> 
  показан пример физической памяти, изначально содержащей пять сегментов. Теперь 
  рассмотрим, что произойдет, если удаляется сегмент 1, а на его место помещается 
  сегмент 7 меньшего размера. Мы получим конфигурацию памяти, изображенную на 
  рис. 4.35, <i>б.</i> Между сегментом 7 и сегментом 2 расположена неиспользуемая 
  область, то есть дыра. Затем сегмент 4 замещается сегментом 5 (см. рис. 4.35, 
  в), а сегмент 3 заменяется сегментом 6, как на рис. 4.35, <i>г.</i> После того 
  как система поработает какое-то время, память разделится на некоторое количество 
  участков, часть из которых содержит сегменты, а остальные свободны. Этот феномен 
  разделения памяти на маленькие свободные участки, которые сложно использовать, 
  называется <b>поклеточной разбивкой</b> или <b>внешней фрагментацией</b>. С 
  внешней фрагментацией можно бороться с помощью уплотнения, как показано на рис. 
  4.35, <i>д.</i><br>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Сегментация с использованием страниц: система MULTICS</font></b><br>
  <br>
  При большом размере сегментов может быть неудобно или даже невозможно хранить 
  их в оперативной памяти целиком. Это приводит к идее их страничной организации, 
  чтобы поблизости находились только те страницы, которые на самом деле нужны. 
  Страничные сегменты поддерживались несколькими важными для нас системами. В 
  этом разделе мы будем описывать первую из них: систему MULTICS. В следующем 
  разделе мы обратимся к более современной системе Intel Pentium.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_37.jpg" alt="Развитие внешней фрагментации (а—г); устранение фрагментации с помощью уплотнения (д)"> 
    <br>
    <br>
    <b>Рис. 4.35.</b> Развитие внешней фрагментации (а—г); устранение<br>
    фрагментации с помощью уплотнения (д)<br>
  </center>
  <br>
<dd> Система MULTICS работала на компьютерах Honeywell 6000 и их потомках и обеспечивала 
  каждую программу виртуальной памятью размером вплоть до 2<sup>18</sup> сегментов 
  (более 250 000), каждый из которых мог быть до 65 536 (36-разрядных) слов длиной. 
  Чтобы осуществить это, разработчики системы MULTICS решили трактовать каждый 
  сегмент как виртуальную память и разбить его на страницы, комбинируя преимущества 
  страничной организации памяти (постоянный размер страницы и отсутствие необходимости 
  хранения целого сегмента в памяти, если используется только его часть) с преимуществом 
  сегментации (облегчение программирования, модульности, защиты и совместного 
  доступа).<br>
<dd> Каждая программа в системе MULTICS имеет таблицу сегментов с одним дескриптором 
  на сегмент. Так как записей в таблице потенциально больше четверти миллиона, 
  таблица сегментов сама является сегментом и разбита на страницы. Дескриптор 
  сегмента содержит индикатор того, находится ли сегмент в памяти или нет. Если 
  какая-то часть сегмента присутствует в памяти, считается, что сегмент в памяти 
  и его таблица страниц будет в памяти. Если сегмент находится в памяти, то его 
  дескриптор содержит 18-разрядный указатель на его таблицу страниц (рис. 4.36, 
  <i>а).</i> Поскольку физические адреса 24-разрядные, а страницы выстраиваются 
  по 64-байтным границам (предполагается, что 6 бит низших разрядов адреса страницы 
  — это 000000), необходимо только 18 бит в дескрипторе для хранения адреса таблицы 
  страниц. Дескриптор также содержит размер сегмента, биты защиты и несколько 
  других полей. Рисунок 4.36, б демонстрирует дескриптор сегмента в системе MULTICS. 
  Адрес сегмента во вспомогательной памяти не находится в дескрипторе сегмента, 
  но в другой таблице используется обработчиком сегментных прерываний.<br>
<dd> Каждый сегмент представляет собой обыкновенное адресное пространство и разбит 
  на страницы точно так же, как и несегментированная страничная память, описанная 
  ранее в этой главе. Нормальный размер страницы равен 1024 словам (хотя несколько 
  меньшие сегменты, используемые MULTICS, не разбиты на страницы или же все-таки 
  разделены на страницы по 64 слова, чтобы сохранить физическую память).<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_38.jpg" alt="Виртуальная память системы MULTICS: сегмент дескрипторов указывает на таблицы страниц (а); дескриптор сегмента (б). Числа означают длину полей"> 
    <br>
    <br>
    <b>Рис. 4.36.</b> Виртуальная память системы MULTICS: сегмент дескрипторов 
    указывает<br>
    на таблицы страниц (а); дескриптор сегмента (б). Числа означают длину полей<br>
  </center>
  <br>
<dd> Адрес в системе MULTICS состоит иг двух частей, сегмента и адреса внутри 
  сегмента. Последний, в свою очередь, делится на номер страницы и слово внутри 
  страницы, как показано на рис. 4.37. Когда происходит обращение к памяти, выполняется 
  следующий алгоритм:<br>
  <br>
<dd> 1. По номеру сегмента находится дескриптор сегмента.<br>
<dd> 2. Проверяется, находится ли таблица страниц сегмента в памяти. Если таблица 
  страниц в памяти, определяется ее расположение. Если нет, вызывается сегментное 
  прерывание. При нарушении защиты происходит прерывание.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_39.jpg" alt="34-разрядный виртуальный адрес в системе MULTICS"><br>
    <br>
    <b>Рис. 4.37.</b> 34-разрядный виртуальный адрес в системе MULTICS<br>
  </center>
  <br>
<dd> Этот процесс продемонстрирован на рис. 4.38. Для простоты был опущен тот 
  факт, что сегмент дескрипторов сам имеет страничное строение. Реально происходит 
  следующее: регистр (основной регистр дескриптора) используется для определения 
  расположения таблицы страниц сегмента дескрипторов, которая, в свою очередь, 
  указывает на страницы сегмента дескрипторов. Как только дескриптор для необходимого 
  сегмента найден, адресация продолжается, как показано на рис. 4.38.<br>
  <br>
  <center>
    Виртуальный адрес MULTICS<br>
    <img src="09/Tanenbaum_4_40.jpg"><br>
    <br>
    <br>
    <img src="09/Tanenbaum_4_41.jpg" alt="Преобразование в системе MULTICS адреса, состоящего из двух частей, в адрес в оперативной памяти"><br>
    <br>
    <b>Рис. 4.38.</b> Преобразование в системе MULTICS адреса, состоящего из двух 
    частей, в адрес в оперативной памяти<br>
  </center>
  <br>
<dd> Как вы, без сомнения, теперь догадались, если бы на практике предыдущий алгоритм 
  выполнялся операционной системой для каждой команды процессора, работа программы 
  была бы не слишком быстрой. В действительности аппаратура системы<br>
<dd> 3. Изучается запись в таблице страниц для запрашиваемой виртуальной страницы. 
  Если страница не находится в памяти, происходит страничное прерывание. Если 
  она в памяти, из записи таблицы страниц извлекается адрес начала страницы в 
  оперативной памяти.<br>
<dd> 4. К адресу начала страницы прибавляется смещение, что дает в результате 
  адрес в оперативной памяти, где расположено нужное слово.<br>
<dd> 5. Наконец, происходит чтение или сохранение.<br>
  <br>
<dd> MULTICS содержит высокоскоростной буфер быстрого преобразования адреса (TLB) 
  размером в 16 слов, способный производить поиск параллельно по всем своим записям 
  для заданного ключа. Это проиллюстрировано на рис. 4.39. Когда компьютер получает 
  адрес, аппаратура адресации сначала проверяет наличие виртуального адреса в 
  буфере TLB. Если это так, она получает номер страничного блока прямиком из буфера 
  TLB и формирует фактический адрес слова, к которому происходит обращение, не 
  выполняя поиск в сегменте дескрипторов или таблице страниц.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_42.jpg" alt="Простейший вариант буфера быстрого преобразования адреса (TLB)"><br>
    <br>
    <b>Рис. 4.39.</b> Простейший вариант буфера быстрого преобразования адреса 
    (TLB)<br>
  </center>
  <br>
<dd> в системе MULTICS. Существование двух размеров страниц делает фактическое 
  строение буфера TLB более сложным<br>
<dd> Адреса 16 наиболее часто использующихся страниц хранятся в буфере быстрого 
  преобразования адреса. Программы, у которых рабочий набор меньше размера буфера 
  TLB, будут хранить адреса всего рабочего набора в буфере TLB и, следовательно, 
  будут работать эффективно. Если страница не находится в буфере быстрого преобразования 
  адреса, фактически происходит обращение к дескриптору и таблице страниц, чтобы 
  найти адрес страничного блока, и буфер TLB обновляется, чтобы включить эту страницу. 
  При этом выгружается страница, не использовавшаяся дольше всего. Поле &laquo;возраста&raquo; 
  хранит информацию о том, какая из записей использовалась наиболее давно. Причиной 
  для применения буфера TLB служит обеспечиваемое им параллельное сравнение сегментов 
  и номеров страниц всех записей.<br>
  <br>
  <br>
<a NAME="03"></a>
  <b><font size="4">Сегментация с использованием страниц: Intel Pentium</font></b><br>
  <br>
  Виртуальная память на компьютере Pentium во многих отношениях аналогична памяти 
  в системе MULTICS, включая наличие и сегментации, и страничной организации. 
  В то время как система MULTICS имеет 256 К независимых сегментов, каждый до 
  64 К 36-разрядных слов, система Pentium поддерживает 16 К независимых сегментов, 
  каждый до 1 млрд 32-разрядных слов. Хотя в последней системе меньше сегментов, 
  их увеличенный размер намного более важен, так как программы редко нуждаются 
  более чем в 1000 сегментах, но многим программам необходимы сегменты значительного 
  размера.<br>
<dd> Основа виртуальной памяти системы Pentium состоит их двух таблиц: локальной 
  таблицы дескрипторов LDT (Local Descriptor Table) и глобальной таблицы дескрипторов 
  GDT (Global Descriptor Table). У каждой программы есть своя собственная таблица 
  LDT, но глобальная таблица дескрипторов одна, ее совместно используют все программы 
  в компьютере. Таблица LDT описывает сегменты, локальные для каждой программы, 
  включая ее код, данные, стек и т. д., тогда как таблица GDT несет информацию 
  о системных сегментах, включая саму операционную систему.<br>
<dd> Чтобы получить доступ к сегменту, программа системы Pentium сначала загружает 
  селектор для этого сегмента в один из шести сегментных регистров машины. Во 
  время выполнения регистр CS содержит селектор для сегмента кода команд, а регистр 
  DS хранит селектор для сегмента данных. Каждый селектор представляет собой 16-разрядный 
  номер (рис. 4.40).<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_43.jpg" alt="Селектор в системе Pentium"><br>
    <br>
    <b>Рис. 4.40.</b> Селектор в системе Pentium<br>
  </center>
  <br>
<dd> Один из битов селектора несет информацию о том, является ли данный сегмент 
  локальным или глобальным (то есть находится ли он в локальной или глобальной 
  таблице дескрипторов). Следующие тринадцать битов определяют номер записи в 
  таблице дескрипторов, поэтому эти таблицы ограничены: каждая содержит 8 К сегментных 
  дескрипторов. Остальные 2 бита относятся к проблемам защиты и будут описаны 
  позже. Дескриптор 0 является запрещенным. Его можно безопасно загрузить в сегментный 
  регистр, чтобы обозначить, что сегментный регистр в данный момент недоступен. 
  При попытке его использовать происходит прерывание.<br>
<dd> Во время загрузки селектора в сегментный регистр соответствующий дескриптор 
  извлекается из локальной или глобальной таблицы дескрипторов и сохраняется в 
  микропрограммных регистрах, что обеспечивает к нему быстрый доступ. Дескриптор 
  состоит из 8 байт, в которые входит базовый адрес сегмента, размер и другая 
  информация (рис. 4.41).<br>
<dd> Формат селектора искусно выбирался так, чтобы упростить определение местоположения 
  дескриптора. Сначала выбирается локальная или глобальная таблица дескрипторов, 
  основываясь на бите два селектора. Затем селектор копируется во внутренний рабочий 
  регистр и три младших бита приравниваются к 0. Наконец, к нему прибавляется 
  адрес одной из таблиц, чтобы получить прямой указатель на дескриптор. Например, 
  селектор 72 ссылается на запись 9 в глобальной таблице дескрипторов, расположенную 
  по адресу в таблице GDT+72.<br>
<dd> Теперь проследим шаги, с помощью которых пара (селектор, смещение) преобразуется 
  в физический адрес. Как только микропрограмма узнает, какой сегментный регистр 
  используется, она может найти в своих внутренних регистрах полный дескриптор, 
  соответствующий этому селектору. Если сегмент не существует (селектор равен 
  0) или в данный момент выгружен, возникает прерывание.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_44.jpg" alt="Дескриптор программного сегмента в системе Pentium. Сегменты данных немного отличаются от программных сегментов"><br>
    <br>
    <b>Рис. 4.41.</b> Дескриптор программного сегмента в системе Pentium. Сегменты 
    данных<br>
    немного отличаются от программных сегментов<br>
  </center>
  <br>
<dd> Затем она проверяет, выходит ли смещение за пределы сегмента, в случае чего 
  также возникает прерывание. Логически в дескрипторе просто должно существовать 
  32-разрядное поле, дающее размер сегмента, но там доступны только 20 бит, поэтому 
  используется другая схема. Если поле <i>Gbit </i> (granularity — глубина детализации) 
  равно 0, поле <i>Limit</i> (предел) содержит точный размер сегмента, до 1 Мбайт. 
  Если оно равно 1, поле <i>Limit</i> дает размер сегмента в страницах вместо 
  байтов. Размер страницы в системе Pentium фиксирован на величине 4 Кбайт, поэтому 
  20 битов достаточно для сегментов размером до 2<sup>32</sup> байтов.<br>
<dd> Предположим, что сегмент находится в памяти, смещение попало в нужный интервал, 
  тогда система Pentium прибавляет 32-разрядное поле <i>Base</i> (база) в дескрипторе 
  к смещению, формируя то, что называется <b>линейным адресом,</b> как показано 
  на рис. 4.42. Поле <i>Base </i> разбито на три части, которые разбросаны по 
  дескриптору для совместимости с процессором Intel 80286, в котором поле <i>Base</i> 
  имеет только 24 бита. В сущности, поле <i>Base</i> позволяет каждому сегменту 
  начинаться в произвольном месте внутри 32-разрядного линейного адресного пространства.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_45.jpg" alt="Преобразование пары (селектор, смещение) в физический адрес"><br>
    <br>
    <b>Рис. 4.42.</b> Преобразование пары (селектор, смещение) в физический адрес<br>
  </center>
  <br>
<dd> Если разбиение на страницы блокировано (с помощью бита в глобальном управляющем 
  регистре), линейный адрес интерпретируется как физический адрес и посылается 
  в память для чтения или записи. Таким образом, при отключенной страничной схеме 
  памяти мы получаем чистую схему сегментации с базовым адресом каждого сегмента, 
  выдаваемым его дескриптором. Сегментам разрешено перекрываться случайным образом, 
  возможно, потому, что контроль за тем, чтобы они не пересекались, мог бы причинить 
  достаточно хлопот и занял бы слишком много времени.<br>
<dd> С другой стороны, если доступна страничная подкачка, линейный адрес интерпретируется 
  как виртуальный адрес и отображается на физический адрес с помощью таблицы страниц 
  практически так же, как в наших предыдущих примерах. Единственная серьезная 
  трудность заключается в том, что при 32-разряном виртуальном адресе и странице 
  размером 4 Кбайт сегмент может содержать 1 млн страниц, поэтому используется 
  двухуровневое отображение с целью уменьшения размера таблицы страниц для маленьких 
  сегментов.<br>
<dd> У каждой работающей программы есть <b>страничный каталог</b>, состоящий из 
  1024 32-разрядных записей. Он расположен по адресу, хранящемуся в глобальном 
  регистре. Каждая запись в каталоге ссылается на таблицу страниц, также содержащую 
  1024 32-разрядных записей. Записи в таблицах страниц в свою очередь указывают 
  на страничные блоки. Эта схема продемонстрирована на рис. 4.43.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_46.jpg" alt="Отображение линейного адреса на физический адрес"><br>
    <br>
    <b>Рис. 4.43.</b> Отображение линейного адреса на физический адрес<br>
  </center>
  <br>
<dd> На рис. 4.43, <i>а</i> мы видим линейный адрес, разделенный на три поля: 
  <i>Каталог, Страница</i> и <i>Смещение.</i> Поле <i>Каталог</i> используется 
  как индекс в страничном каталоге, определяющий расположение указателя на правильную 
  таблицу страниц. Затем поле <i>Страница</i> используется в качестве индекса 
  в таблице страниц, чтобы найти физический адрес страничного блока. И наконец, 
  чтобы получить физический адрес требуемого байта или слова, к адресу страничного 
  блока прибавляется последнее поле <i>Смещение.</i><br>
<dd> Каждая запись в таблице имеет размер 32 бита, 20 из которых содержат номер 
  страничного блока. В остальные биты входят биты доступа и &laquo;грязный&raquo; 
  бит, задаваемые аппаратурой для операционной системы, биты защиты и другие полезные 
  биты.<br>
<dd> Каждая таблица страниц включает в себя записи для 1024 страничных блоков 
  размером по 4 Кбайт, таким образом, одна таблица страниц управляет четырьмя 
  мегабайтами памяти. Сегмент, длина которого меньше 4 Мбайт, будет иметь страничный 
  каталог с единственной записью — указателем на его единственную таблицу страниц. 
  Следовательно, в случае короткого сегмента на поддержку таблиц страниц расходуется 
  только две страницы вместо миллиона, который был бы нужен в одноуровневой таблице 
  страниц.<br>
<dd> Чтобы избежать создания повторных обращений к памяти, система Pentium, как 
  и система MULTICS, имеет небольшой буфер быстрого преобразования адреса (TLB), 
  который напрямую отображает наиболее часто использующиеся комбинации <i>Каталог-Страница</i> 
  на физический адрес страничного блока. Только когда текущая комбинация отсутствует 
  в буфере TLB, действительно выполняется механизм, показанный на рис. 4.43, и 
  буфер TLB обновляется. Система обладает хорошей производительностью до тех пор, 
  пока обращения к отсутствующим страницам в буфере TLB происходят относительно 
  редко.<br>
<dd> Также следует отметить, что если некоторые приложения не требуют сегментации, 
  а довольствуются единым, разбитым на страницы 32-разрядным адресным пространством, 
  эта модель все равно работает. Все сегментные регистры могут быть настроены 
  тем же самым селектором, в дескрипторе которого поле <i>Base =</i> 0 и поле 
  <i>Limit</i> установлено на максимум. Тогда, при использовании единственного 
  адресного пространства, смещение команды будет линейным адресом — в сущности, 
  обычная страничная организация памяти. Фактически все современные операционные 
  системы для компьютера Pentium работают таким образом. Система OS/2 была единственной, 
  которая использовала всю мощь архитектуры диспетчера памяти (MMU) фирмы Intel.<br>
<dd> В конце концов, кто-то должен похвалить разработчиков системы Pentium. При 
  поставленных перед ними противоречивых задачах — реализовать чистую страничную 
  организацию памяти, чистое сегментирование и страничные сегменты и в то же время 
  обеспечить совместимость с 286-м процессором, а кроме того, сделать все это 
  эффективно, — результирующая структура удивительно проста и понятна.<br>
<dd> Мы хотя и кратко, но целиком описали полную архитектуру виртуальной памяти 
  системы Pentium и теперь следует сказать несколько слов о защите, так как эта 
  тема тесно связана с виртуальной памятью. Как схема виртуальной памяти, так 
  и система защиты на Pentium близка по модели к системе MULTICS. Система Pentium 
  поддерживает четыре уровня защиты, где уровень 0 является наиболее привилегированным, 
  а уровень 3 — наименее привилегированным. Они показаны на рис. 4.44. В каждый 
  момент времени работающая программа находится на определенном уровне, что отмечается 
  2-битовым полем в его регистре слова состояния программы (PSW). Каждый сегмент 
  в системе также имеет свой уровень.<br>
  <br>
  <center>
    <img src="09/Tanenbaum_4_47.jpg" alt="Защита в системе Pentium"><br>
    <br>
    <b>Рис. 4.44.</b> Защита в системе Pentium<br>
  </center>
  <br>
<dd> До тех пор пока программа сама ограничивает использование сегментов на своем 
  собственном уровне, система прекрасно работает. Разрешаются попытки получения 
  доступа к данным высшего уровня. Попытки доступа к данным более низкого уровня 
  запрещены и вызывают прерывания. Попытки вызвать процедуры различного уровня 
  (более высокого или низкого) позволяются, но тщательно контролируемым образом. 
  Чтобы сделать межуровневый вызов, инструкция CALL должна содержать селектор 
  вместо адреса. Этот селектор определяет дескриптор, называемый <b>шлюзом вызова</b> 
  (call gate), который передает адрес вызываемой процедуры. Таким образом, перепрыгнуть 
  в середину произвольного сегмента кода другого уровня невозможно. Могут использоваться 
  только официальные точки входа. Концепция уровней защиты и схем вызова впервые 
  появилась в системе MULTICS, где они представали в виде <b>колец защиты.</b><br>
<dd> Типичное использование этого механизма представлено на рис. 4.44. На уровне 
  0 мы находим ядро операционной системы, занимающееся обработкой операций ввода-вывода, 
  управлением памятью и другими наиболее важными вопросами. На уровне 1 находится 
  обработчик системных вызовов. На этом уровне пользовательские программы могут 
  обращаться к процедурам для выполнения системных вызовов, но только к определенному 
  и защищенному списку процедур. Уровень 2 содержит библиотечные процедуры, возможно, 
  совместно используемые несколькими запущенными программами. Пользовательские 
  программы могут вызывать эти процедуры и читать их данные, но не могут их изменять. 
  И наконец, пользовательские программы работают на уровне 3, который имеет наименьшую 
  степень защиты.<br>
<dd> Эмулированные и аппаратные прерывания используют механизм, аналогичный шлюзам 
  вызовов. Они тоже обращаются к дескрипторам, а не к абсолютным адресам, эти 
  дескрипторы указывают на определенные процедуры. Поле <i>Тип</i> на рис. 4.40 
  позволяет различать программные сегменты, сегменты данных и различных видов 
  шлюзов вызовов.<br>
</BODY>
</HTML>
