<HTML>
<HEAD>
<TITLE>Планирование</TITLE>
</HEAD>
<body>
  
<h1 align="center">Планирование</h1>
<p>
  Когда компьютер работает в многозадачном режиме, на нем могут быть активными 
  несколько процессов, пытающихся одновременно получить доступ к процессору. Эта 
  ситуация возникает при наличии двух и более процессов в состоянии готовности. 
  Если доступен только один процессор, необходимо выбирать между процессами. Отвечающая 
  за это часть операционной системы называется <B>планировщиком, </B>а используемый 
  алгоритм — <B>алгоритмом планирования. </B>Рассмотрению задач, связанных с планированием, 
  посвящены следующие разделы.<BR>
</p>
Многие методы, применимые к планированию процессов, также могут быть применены 
  к планированию потоков, хотя и не все. Для начала мы остановимся на планировании 
  процессов, а позже рассмотрим планирование потоков.<BR>
  <br>
  <br>
<a NAME="01"></a>
  <B><font size="4">Введение в планирование</font></B><BR>
  <br>
  Давным-давно, во времена систем пакетной обработки, использовавших отображение 
  содержимого перфокарт на магнитной ленте в качестве устройства ввода, алгоритм 
  планирования был прост: запустить следующую задачу на ленте. С появлением систем 
  с разделением времени алгоритм планирования усложнился, поскольку теперь несколько 
  задач одновременно ожидали обслуживания. На некоторых мэйнфреймах до сих пор 
  совмещаются системы пакетной обработки и службы разделения времени. В результате 
  планировщик должен решать, запустить ли следующим пакетное задание или предоставить 
  процессор интерактивному пользователю за терминалом. (Пакетное задание может 
  предполагать запуск нескольких последовательных программ за один сеанс, но в 
  этом разделе мы считаем, что пакетное задание является запросом на запуск одной 
  программы.) Поскольку время процессора является в такой системе дефицитным ресурсом, 
  хороший планировщик может существенно изменить ощущаемую пользователем производительность 
  работы и, следовательно, степень удовлетворения пользователя. Поэтому много 
  усилий было потрачено на разработку умных и эффективных алгоритмов планирования.<BR>
<p>С появлением персональных компьютеров ситуация изменилась. Во-первых, большую 
  часть времени активен только один процесс. Пользователь, работающий с документом 
  в текстовом редакторе, вряд ли будет одновременно считать что-либо в фоновом 
  режиме. Когда пользователь дает команду текстовому процессору, планировщику 
  не приходится долго выбирать, какой процесс запустить, поскольку других кандидатов 
  нет.<BR>
</p>
<p>Во-вторых, компьютеры стали настолько быстрее, что время процессора практически 
  перестало быть дефицитным ресурсом. Большинство программ для персонального компьютера 
  ограничены скоростью, с которой пользователь вводит входные данные (с клавиатуры 
  или с помощью мыши), а не скоростью процессора. Даже процедуры компиляции, основные 
  потребители процессорного времени прошлого, теперь занимают всего несколько 
  секунд. Если одновременно запущены две программы, например текстовый редактор 
  и электронная таблица, и то вряд ли имеет значение, которая из них была первой, 
  поскольку пользователь, вероятно, ждет окончания работы обеих. Таким образом, 
  на простых персональных компьютерах планирование не играет существенной роли. 
  Разумеется, существуют приложения, занимающие практически весь процессор: визуализация 
  одного часа видеозаписи может потребовать обрабатывающих мощностей промышленного 
  уровня для всех 108 000 кадров формата NTSC (90 000 кадров формата PAL), но 
  подобные приложения являются скорее исключением из правила.<BR>
</p>
<p>Картина меняется при рассмотрении мощных сетевых рабочих станций и серверов. 
  Здесь планирование снова играет существенную роль, поскольку несколько процессов 
  пытаются получить доступ к процессору. Например, когда процессору нужно выбрать 
  между процессом, перерисовывающим экран после того, как пользователь закрыл 
  окно приложения, и процессом, отсылающим почту, впечатление пользователя о реакции 
  компьютера будет существенно зависеть от этого выбора. Ведь если перерисовка 
  экрана во время отправки почты займет 2 с, пользователь решит, что система очень 
  медленная, тогда как двухсекундная отсылка почты даже не будет замечена. В этом 
  случае планирование процессов очень важно.<BR>
</p>
<p>Помимо правильного выбора следующего процесса, планировщик также должен заботиться 
  об эффективном использовании процессора, поскольку переключение между процессами 
  требует затрат. Во-первых, необходимо переключиться из режима пользователя в 
  режим ядра. Затем следует сохранить состояние текущего процесса, включая сохранение 
  регистров в таблице процессов, чтобы их можно было загрузить заново позже. В 
  большинстве систем также необходимо сохранить карту памяти (то есть биты-признаки 
  обращения к страницам памяти). Затем нужно выбрать следующий процесс, запустив 
  алгоритм планирования. После этого необходимо перезапустить блок управления 
  памятью с картой памяти нового процесса. И наконец, нужно запустить новый процесс. 
  Помимо этого, переключение между процессами обычно делает бесполезной информацию, 
  содержащуюся в кэше памяти, что приводит к двойной перезагрузке кэша из основной 
  памяти (при входе в ядро и при выходе из ядра). Все это занимает много процессорного 
  времени, особенно при слишком частом переключении между процессами, поэтому 
  в этом рекомендуется соблюдать умеренность.<BR>
  <br>
  <br>
  <B>Поведение процесса</B><BR>
  <br>
  Практически все процессы чередуют периоды вычислений с операциями (дисковыми) 
  ввода-вывода, как показано на рис. 2.20. Обычно процессор некоторое время работает 
  без остановки, затем происходит системный вызов на чтение из файла или запись 
  в файл. После выполнения системного вызова процессор опять считает, пока ему 
  не понадобятся новые данные или не потребуется записать полученные данные и 
  т. д. Заметьте, что некоторые операции ввода-вывода считаются вычислениями. 
  Например, когда процессор копирует биты в видео-ОЗУ, чтобы перерисовать экран, 
  он вычисляет, а не выполняет операцию ввода-вывода, поскольку задействован процессор. 
  С этой точки зрения операция ввода-вывода выполняется в случае, если процесс 
  входит в состояние блокировки, ожидая окончания работы внешнего устройства.<BR>
  
</p>
<center>
    <br>
    <img src="06/Tanenbaum_2_18.jpg" alt="Периоды использования процессора, чередующиеся с ожиданием ввода-вывода"><br>
    <br>
    <font face="Arial"><B>Рис. 2.20.</B> Периоды использования процессора, чередующиеся 
    с ожиданием ввода-вывода:<BR>
    процесс, ограниченный возможностями процессора (а); процесс, ограниченный<BR>
    возможностями устройств ввода-вывода (б)</font><BR>
  </center>
  <br>
<p>Важно отметить, что некоторые процессы, как на рис. 2.20, <I>а, </I>большую 
  часть времени заняты вычислениями, а другие, как на рис. 2.20, <I>б, </I>большую 
  часть времени ожидают ввода-вывода. Первые называются ограниченными возможностями 
  процессора, вторые — ограниченными возможностями устройств ввода-вывода.<BR>
</p>
<p>Процессы, ограниченные возможностями процессора, обычно характеризуются длительными 
  периодами использования процессора и нечастыми ожиданиями ввода-вывода, тогда 
  как процессы, ограниченные возможностями устройств ввода-вывода, наоборот: короткими 
  периодами использования процессора и частыми ожиданиями ввода-вывода. Основным 
  параметром здесь является не время ожидания, а время вычислений. Процессы, ограниченные 
  возможностями устройств ввода-вывода, называются так, поскольку загруженность 
  процессора вычислениями между запросами ввода-вывода мала, а не потому, что 
  время выполнения ввода-вывода особо велико. На считывание блока данных с диска 
  уходит одно и то же время, не зависящее от времени, затрачиваемого на обработку 
  этих данных.<BR>
</p>
<p>Стоит отметить, что с увеличением скорости процессоров процессы становятся 
  все более ограниченными возможностями устройств ввода-вывода. Это связано с 
  тем, что процессоры совершенствуются существенно быстрее, чем диски. Таким образом, 
  планирование процессов, ограниченных возможностями устройств ввода-вывода, будет 
  иметь большее значение в будущем. В таких процессах следует избегать простоя 
  относительно медленных дисков.<BR>
  <br>
  <br>
  <B>Когда планировать?</B><BR>
  <br>
  Ключевым вопросом планирования является выбор момента принятия решений. Оказывается, 
  существует множество ситуаций, в которых необходимо планирование. Во-первых, 
  когда создается новый процесс, необходимо решить, какой процесс запустить: родительский 
  или дочерний. Поскольку оба процесса находятся в состоянии готовности, эта ситуация 
  не выходит за рамки обычного и планировщик может запустить любой из двух процессов.<BR>
</p>
<p>Во-вторых, планирование необходимо, когда процесс завершает работу. Этот процесс 
  уже не существует, следовательно, необходимо из набора готовых процессов выбрать 
  и запустить следующий. Если процессов, находящихся в состоянии готовности, нет, 
  обычно запускается холостой процесс, поставляемый системой.<BR>
</p>
<p>В-третьих, когда процесс блокируется на операции ввода-вывода, семафоре, или 
  по какой-либо другой причине, необходимо выбрать и запустить другой процесс. 
  Иногда причина блокировки может повлиять на выбор. Например, если <I>А — </I>важный 
  процесс и он ожидает выхода процесса <I>В </I>из критической области, можно 
  запустить следующим процесс <I>В, </I>чтобы он вышел из критической области 
  и позволил процессу <I>А </I>продолжать работу. Сложность, однако, в том, что 
  планировщик обычно не обладает информацией, необходимой для принятия правильного 
  решения.<BR>
</p>
<p>В-четвертых, необходимость планирования может возникнуть при появлении прерывания 
  ввода-вывода. Если прерывание пришло от устройства ввода-вывода, закончившего 
  работу, можно запустить процесс, который был блокирован в ожидании этого события. 
  Планировщик должен выбрать, какой процесс запустить: новый, тот, который был 
  остановлен прерыванием, или какой-то другой.<BR>
</p>
<p>Если аппаратный таймер выполняет периодические прерывания с частотой 50 Гц, 
  60 Гц или с любой другой частотой, решения планирования могут приниматься при 
  каждом прерывании по таймеру или при каждом <I>k</I>-м прерывании. Алгоритмы 
  планирования можно разделить на две категории согласно их поведению после прерываний. 
  Алгоритмы планирования <B>без переключений, </B>иногда называемого также <B>неприоритетным 
  </B>планированием, выбирают процесс и позволяют ему работать вплоть до блокировки 
  (в ожидании ввода-вывода или другого процесса), либо вплоть до того момента, 
  когда процесс сам не отдаст процессор. Процесс не будет прерван, даже если он 
  работает часами. Соответственно, решения планирования не принимаются по прерываниям 
  от таймера. После обработки прерывания таймера управление всегда возвращается 
  приостановленному процессу.<BR>
</p>
<p>Напротив, алгоритмы планирования <B>с переключениями, </B>называемого также 
  <B>приоритетным </B>планированием, выбирают процесс и позволяют ему работать 
  некоторое максимально возможное фиксированное время. Если к концу заданного 
  интервала времени процесс все еще работает, он приостанавливается и управление 
  переходит к другому процессу (если в очереди есть процесс). Приоритетное планирование 
  требует прерываний по таймеру, происходящих в конце отведенного периода времени, 
  чтобы передать управление планировщику. При отсутствии таймера возможно только 
  планирование без переключений.<BR>
  <br>
  <br>
  <B>Категории алгоритмов планирования</B><BR>
  <br>
  В различных средах требуются различные алгоритмы планирования. Это связано с 
  тем, что различные операционные системы и различные приложения ориентированы 
  на разные задачи. Другими словами, то, для чего следует оптимизировать планировщик, 
  различно в разных системах. Можно выделить три среды:<BR>
  <br>
</p>
<p>1. Системы пакетной обработки данных.</p>
<p>2. Интерактивные системы.</p>
<p>3. Системы реального времени.</p>
<p>В системах пакетной обработки нет пользователей, сидящих за терминалами и 
  ожидающих ответа. В таких системах приемлемы алгоритмы без переключений или 
  с переключениями, но с большим временем, отводимым каждому процессу. Такой метод 
  уменьшает количество переключений между процессами и улучшает эффективность.<BR>
</p>
<p>В интерактивных системах необходимы алгоритмы планирования с переключениями, 
  чтобы предотвратить захват процессора одним процессом. Даже если ни один процесс 
  не захватывает процессор на неопределенно долгий срок намеренно, из-за ошибки 
  в программе один процесс может заблокировать остальные. Для исключения подобных 
  ситуаций используется планирование с переключениями.<BR>
</p>
<p>В системах с ограничениями реального времени приоритетность, как это ни странно, 
  не всегда обязательна, поскольку процессы знают, что их время ограничено, и 
  быстро выполняют работу, а затем блокируются. Отличие от интерактивных систем 
  в том, что в системах реального времени работают только программы, предназначенные 
  для содействия конкретным приложениям. Интерактивные системы являются универсальными 
  системами. В них могут работать произвольные программы, не сотрудничающие друг 
  с другом и даже враждебные по отношению друг к другу.<BR>
  <br>
  <br>
  <B>Задачи алгоритмов планирования</B><BR>
  <br>
  Чтобы разработать алгоритм планирования, необходимо иметь представление о том, 
  что должен делать хороший алгоритм. Некоторые задачи зависят от среды (системы 
  пакетной обработки, интерактивные или реального времени), но есть задачи, одинаковые 
  во всех системах. Список задач представлен в табл. 2.5. Мы рассмотрим их ниже.<BR>
  <br>
  
</p>
<center>
    <font face="Arial"><B>Таблица 2.5.</B> Некоторые задачи алгоритмов планирования</font><BR>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="1" CELLSPACING="0" CELLPADDING="0" WIDTH="771" HEIGHT="68">
      <TR> 
        <TD width="750" height="329"> <B>Все системы</B><BR>
          Справедливость — предоставление каждому процессу справедливой доли процессорного 
          времени<BR>
          Принудительное применение политики — контроль за выполнением принятой 
          политики<BR>
          Баланс — поддержка занятости всех частей системы<BR>
          <br>
          <B>Системы пакетной обработки данных</B><BR>
          Пропускная способность — максимальное количество задач в час<BR>
          Оборотное время — минимизация времени, затрачиваемого на ожидание обслуживания 
          и обработку задачи<BR>
          Использование процессора — поддержка постоянной занятости процессора<BR>
          <br>
          <B>Интерактивные системы</B><BR>
          Время отклика — быстрая реакция на запросы<br>
          Соразмерность — выполнение пожеланий пользователя<BR>
          <br>
          <B>Системы реального времени</B><BR>
          Окончание работы к сроку — предотвращение потери данных<BR>
          Предсказуемость — предотвращение деградации качества в мультимедийных 
          системах </td>
      </tr>
    </table>
  </center>
  <br>
<p>При всех обстоятельствах необходимо справедливое распределение процессорного 
  времени. Сопоставимые процессы должны получать сопоставимое обслуживание. Выделить 
  одному процессу намного больше времени процессора, чем другому, эквивалентному, 
  несправедливо. Разумеется, с различными категориями процессов можно обращаться 
  весьма по-разному. Возьмите, например, задачи обеспечения безопасности и начисления 
  заработной платы в компьютерном центре атомной электростанции.<BR>
</p>
<p>С принципом справедливости в какой-то мере связано принудительное применение 
  системной политики. Если локальная политика заключается в предоставлении процессора 
  процессам контроля безопасности по первому требованию, планировщик должен удостовериться 
  в принудительном применении этой политики, даже когда это приводит к начислению 
  заработной платы на 30 с позже.<BR>
</p>
<p>Еще одной глобальной задачей является контроль занятости всех частей системы. 
  Если устройства ввода-вывода и процессор все время работают, в единицу времени 
  окажется выполнено гораздо больше полезной деятельности, чем если отдельные 
  компоненты будут простаивать. Например, в системах пакетной обработки планировщик 
  выбирает, какие задачи загрузить в память для работы. Гораздо лучше иметь в 
  памяти одновременно несколько процессов, ограниченных возможностями процессора, 
  и несколько процессов, ограниченных возможностями устройств ввода-вывода, чем 
  сначала загрузить и запустить несколько процессов, ограниченных возможностями 
  процессора, и только потом несколько процессов, ограниченных возможностями устройств 
  ввода-вывода. В последнем случае во время работы процессов, ограниченных возможностями 
  процессора, будет простаивать диск, а во время работы процессов, ограниченных 
  возможностями устройств ввода-вывода, будет простаивать процессор. Правильнее 
  будет заставить работать всю систему, аккуратно перемешав процессы.<BR>
</p>
<p>Руководители крупных компьютерных центров, в которых обрабатываются большие 
  пакетные задания, обычно контролируют три показателя, позволяющие оценить эффективность 
  системы: пропускную способность, оборотное время и использование процессора. 
  Пропускной способностью называется число выполненных системой задач в час. В 
  любом случае 50 задач в час лучше, чем 40 задач в час. Оборотное время — статистически 
  усредненное время от момента получения задачи до ее выполнения. Оно характеризует 
  время, которое среднестатистический пользователь должен ждать получения выходных 
  данных. Основным правилом является &laquo;чем меньше, тем лучше&raquo;.<BR>
</p>
<p>Алгоритм планирования, максимизирующий пропускную способность, не обязательно 
  минимизирует оборотное время. При наличии смеси из длинных и коротких задач 
  алгоритм, запускающий только короткие задачи, может добиться высокой пропускной 
  способности (много коротких задач в час), но за счет ужасного оборотного времени 
  для длинных задач. Если короткие задачи поступают с постоянной скоростью, до 
  длинных задач дело может не дойти никогда, в результате чего оборотное время 
  будет бесконечным при высокой пропускной способности.<BR>
</p>
<p>Учет такой характеристики, как использование процессора, связан с тем, что 
  процессор все еще является самой дорогой частью мэйнфреймов, на которых используются 
  системы пакетной обработки. Руководители таких центров чувствуют себя неловко, 
  если процессор не занят все время. Хотя на самом деле этот показатель не так 
  уж и важен. Гораздо важнее пропускная способность и оборотное время. Рассматривать 
  коэффициент использования процессора в качестве показателя эффективности примерно 
  так же разумно, как рассматривать рейтинг машин, основанный на количестве оборотов 
  двигателя в минуту.<BR>
</p>
<p>Для интерактивных систем, особенно систем и серверов, работающих в режиме 
  разделения времени, важны другие задачи. Самой важной является минимизация времени 
  отклика, то есть времени между введением команды и получением результата. На 
  персональном компьютере с фоновым процессом (например, отправкой и получением 
  почты) запрос пользователя на запуск программы или открытие файла должен иметь 
  приоритет перед фоновым процессом. Первоочередная обработка всех интерактивных 
  запросов рассматривается как хорошее обслуживание.<BR>
</p>
<p>Еще одной задачей является достижение соразмерности. У пользователя всегда 
  есть собственное (зачастую неправильное) представление о том, сколько времени 
  должна занимать та или иная операция. Если запрос, оцениваемый пользователем 
  как сложный, занимает много времени, пользователь готов с этим согласиться, 
  но если запрос оценивался как простой, пользователь сердится. Так, если после 
  щелчка на значке соединения с Интернет-провайдером, у которого аналоговый модем, 
  до момента выхода в Интернет проходит 45 с, пользователь воспринимает это как 
  должное. Но если 45 с будет занимать отключение от сети, пользователь через 
  30 с начнет безостановочно ругаться, а к 45-й секунде у него пойдет пена изо 
  рта. Такое поведение пользователя основано на его представлении о том, что звонок 
  по телефону и установление соединения <I>должно </I>занимать существенно больше 
  времени, чем разрыв соединения. В некоторых случаях (и в этом тоже) планировщик 
  не может ничего сделать, но может улучшить ситуацию во многих других, особенно 
  если задержка вызвана неправильным порядком процессов.<BR>
</p>
<p>Системы реального времени обладают другими свойствами, чем интерактивные системы, 
  соответственно и задачи планирования будут разными. Характерной особенностью 
  систем реального времени является наличие жестких сроков выполнения определенных 
  действий. Например, если компьютер управляет устройством, выдающим данные с 
  постоянной скоростью, неспособность своевременно запустить процесс, обрабатывающий 
  данные, приведет к потере данных. Поэтому первоочередной задачей в системах 
  реального времени является строгое соблюдение всех (или большинства) требований 
  по срокам.<BR>
</p>
<p>В некоторых системах реального времени, особенно связанных с мультимедиа, 
  важна предсказуемость. Небольшая временная задержка не является катастрофичной, 
  но неравномерность аудиопроцесса тут же скажется на ухудшении качества звука. 
  Это касается и изображения, но слух более чувствителен к вибрации, чем зрение. 
  Чтобы исключить эту проблему, планирование процессов необходимо сделать предсказуемым 
  и регулярным. Мы рассмотрим в этой главе алгоритмы планирования для систем пакетной 
  обработки и интерактивных систем, но рассмотрение планирования в системах реального 
  времени отложим до главы 7, в которой изучим мультимедийные операционные системы.<BR>
  <br>
  <br>
<a NAME="02"></a>
  <B><font size="4">Планирование в системах пакетной обработки данных</font></B><BR>
  <br>
  Перейдем от общих проблем планирования к конкретным алгоритмам. В этом параграфе 
  мы рассмотрим алгоритмы, используемые в системах пакетной обработки, а в дальнейших 
  параграфах обратимся к алгоритмам интерактивных систем и систем реального времени. 
  Следует отметить, что некоторые алгоритмы используются как в системах пакетной 
  обработки, так и в интерактивных системах — мы рассмотрим их позже. В этом параграфе 
  мы ограничимся алгоритмами планирования, подходящими только для систем пакетной 
  обработки.<BR>
  <br>
  <br>
  <B>&laquo;Первым пришел — первым обслужен&raquo;</B><BR>
  <br>
  Алгоритм без переключений &laquo;первым пришел — первым обслужен&raquo; является, 
  пожалуй, самым простым из алгоритмов планирования. Процессам предоставляется 
  доступ к процессору в том порядке, в котором они его запрашивают. Чаще всего 
  формируется единая очередь ждущих процессов. Как только появляется первая задача, 
  она немедленно запускается и работает столько, сколько необходимо. Остальные 
  задачи ставятся в конец очереди. Когда текущий процесс блокируется, запускается 
  следующий в очереди, а когда блокировка снимается, процесс попадает в конец 
  очереди.<BR>
</p>
<p>Основным преимуществом этого алгоритма является то, что его легко понять и 
  столь же легко программировать. Он справедлив в том же самом смысле, в каком 
  справедливо распределение дефицитных билетов на концерт или соревнования среди 
  всех желающих стоять в очереди с двух часов ночи. В этом алгоритме все процессы 
  в состоянии готовности контролируются одним связным списком. Чтобы выбрать процесс 
  для запуска, нужно всего лишь взять первый элемент списка и удалить его. Появление 
  нового процесса приводит к помещению его в конец списка — что может быть проще?<BR>
</p>
<p>К сожалению, у этого алгоритма есть существенный недостаток. Представьте себе, 
  что есть один процесс, ограниченный возможностями процессора, который каждый 
  раз работает ровно 1 с, и много процессов, ограниченных возможностями устройств 
  ввода-вывода, каждый из которых очень в небольшой мере использует процессор, 
  но должен выполнить 1000 обращений к диску. Процесс, ограниченный возможностями 
  процессора, запускается, работает 1 с, затем читает блок с диска. Теперь запускаются 
  все процессы ввода-вывода и считывают информацию с диска. Когда процесс, ограниченный 
  возможностями процессора, получает свой блок с диска, он запускается еще на 
  1 с, а за ним все процессы, ограниченные возможностями устройств ввода-вывода.<BR>
</p>
<p>Конечный результат будет следующим: каждый из процессов, ограниченных возможностями 
  устройств ввода-вывода, считывает 1 блок данных в секунду, и им потребуется 
  по 1000 с, чтобы закончить работу. Если алгоритм планирования будет прерывать 
  процесс, ограниченный возможностями процессора, раз в 10 мс, процессы, ограниченные 
  возможностями устройств ввода-вывода, закончат за 10 с вместо 1000 с и не очень 
  замедлят работу процесса, ограниченного возможностями процессора.<BR>
  <br>
  <br>
  <B>&laquo;Кратчайшая задача — первая&raquo;</B><BR>
  <br>
  Рассмотрим еще один алгоритм без переключений для систем пакетной обработки, 
  предполагающий, что временные отрезки работы известны заранее. Например, работники 
  страховой компании могут довольно точно предсказать, сколько времени займет 
  обработка пакета из 1000 исков, поскольку они делают это каждый день. Если в 
  очереди есть несколько одинаково важных задач, планировщик выбирает <B>первой 
  самую короткую задачу. </B>Посмотрите на рис. 2.21. У нас есть четыре задачи: 
  <I>А, В, С</I> и <I>D, </I>со временем выполнения 8, 4, 4 и 4 мин соответственно. 
  Если мы запустим их в данном порядке, оборотное время задачи <I>А </I>будет 
  8 мин, <I>В — </I>12 мин, <I>С — </I>16 мин и <I>D</I> — 20 мин, и среднее время 
  будет равно 14 мин.<BR>
  
</p>
<center>
    <br>
    <img src="06/Tanenbaum_2_19.jpg" alt="Пример алгоритма планирования"><br>
    <br>
    <font face="Arial"><B>Рис.</B> 2.21. Пример алгоритма планирования &laquo;Кратчайшая 
    задача — первая&raquo;: запуск четырех<br>
    задач в исходном порядке (а); запуск в соответствии с алгоритмом (б)</font><BR>
  </center>
  <br>
<p>Запустим задачи в соответствии с алгоритмом, как показано на рис. 2.21, <I>6. 
  </I>Теперь значения оборотного времени составляют 4, 8, 12 и 20 мин соответственно, 
  а среднее время равно 11 мин. Алгоритм оптимизирует задачу. Рассмотрим четыре 
  процесса со временем выполнения <I>а, b, с </I>и <I>d. </I>Первая задача выполняется 
  за время <I>а, </I>вторая — за время <I>а </I>+ <I>b </I>и т. д. Среднее оборотное 
  время будет равно (4а + <I>Зb + 2с + d)/</I>4. Очевидно, что вклад времени <I>а 
  </I>в среднее больше, чем всех остальных интервалов времени, поэтому первой 
  должна выполняться самая короткая задача, а последней — самая длинная, вносящая 
  вклад, равный собственному оборотному времени. Точно так же рассматривается 
  система из любого количества задач.<BR>
</p>
<p>Следует отметить, что эта схема работает лишь в случае одновременного наличия 
  задач. В качестве контрпримера можно рассмотреть пять задач, <I>А, В, С, D</I> 
  и <I>Е, </I>причем первые две доступны стразу же, а три оставшиеся — еще через 
  три минуты. Время выполнения этих задач составляет 2, 4, 1, 1 и 1 мин соответственно. 
  Вначале можно выбрать только <I>А или В, </I>поскольку остальные недоступны. 
  Если руководствоваться алгоритмом &laquo;Кратчайшая задача — первая&raquo;, 
  задачи будут запущены в следующем порядке: <I>А, В, С, D, E,</I> и среднее оборотное 
  время составит 4,6 мин. Если же запустить их в порядке <I>В, С, </I>D, E, А, 
  то среднее оборотное время составит 4,4 мин.<BR>
  <br>
  <br>
  <B>Наименьшее оставшееся время выполнения</B><BR>
  <br>
  Версией предыдущего алгоритма с переключениями является алгоритм <B>наименьшего 
  оставшегося времени выполнения. </B>В соответствии с этим алгоритмом планировщик 
  каждый раз выбирает процесс с наименьшим оставшимся временем выполнения. В этом 
  случае также необходимо заранее знать время выполнения задач. Когда поступает 
  новая задача, ее полное время выполнения сравнивается с оставшимся временем 
  выполнения текущей задачи. Если время выполнения новой задачи меньше, текущий 
  процесс приостанавливается и управление передается новой задаче. Эта схема позволяет 
  быстро обслуживать короткие запросы.<BR>
  <br>
  <br>
  <B>Трехуровневое планирование</B><BR>
  <br>
  Системы пакетной обработки позволяют реализовать трехуровневое планирование, 
  как показано на рис. 2.22. По мере поступления в систему новые задачи сначала 
  помещаются в очередь, хранящуюся на диске. <B>Впускной планировщик </B>выбирает 
  задание и передает его системе. Остальные задания остаются в очереди.<BR>
</p>
<p>Характерный алгоритм входного контроля может заключаться в выборе смеси из 
  процессов, ограниченных возможностями процессора, и процессов, ограниченных 
  возможностями устройств ввода-вывода. Также возможен алгоритм, в котором устанавливается 
  приоритет коротких задач перед длинными. Впускной планировщик волен придержать 
  некоторые задания во входной очереди, а пропустить задание, поступившее позже 
  остальных.<BR>
  <br>
  
</p>
<center>
    <img src="06/Tanenbaum_2_20.jpg" alt="Трехуровневое планирование"><br>
    <br>
    <font face="Arial"><B>Рис. 2.22.</B> Трехуровневое планирование</font><BR>
  </center>
  <br>
<p>Как только задание попало в систему, для него будет создан соответствующий 
  процесс, и он может тут же вступить в борьбу за доступ к процессору. Тем не 
  менее возможна ситуация, когда процессов слишком много и они все в памяти не 
  помещаются, тогда некоторые из них будут выгружены на диск. Второй уровень планирования 
  определяет, какие процессы можно хранить в памяти, а какие — на диске. Этим 
  занимается <B>планировщик памяти.</B><BR>
</p>
<p>С одной стороны, распределение процессов необходимо часто пересматривать, 
  чтобы у процессов, хранящихся на диске, тоже был шанс получить доступ к процессору. 
  С другой стороны, перемещение процесса с диска в память требует затрат, поэтому 
  к диску следует обращаться не чаще, чем раз в секунду, а может быть и реже. 
  Если содержимое оперативной памяти будет слишком часто меняться, пропускная 
  способность диска будет расходоваться впустую, что замедлит файловый ввод-вывод.<BR>
</p>
<p>Для оптимизации эффективности системы планировщик памяти должен решить, сколько 
  и каких процессов может одновременно находиться в памяти. Количество процессов, 
  одновременно находящихся в памяти, называется <B>степенью многозадачности. </B>Если 
  планировщик памяти обладает информацией о том, какие процессы ограничены возможностями 
  процессора, а какие — возможностями устройств ввода-вывода, он может пытаться 
  поддерживать смесь этих процессов в памяти. Можно грубо оценить, что если некая 
  разновидность процессов будет занимать примерно 20 % времени процессора, то 
  пяти процессов будет достаточно для поддержания постоянной занятости процессора. 
  Более совершенная модель многозадачности будет рассмотрена в главе 4.<BR>
</p>
<p>Планировщик памяти периодически просматривает процессы, находящиеся на диске, 
  чтобы решить, какой из них переместить в память. Среди критериев, используемых 
  планировщиком, есть следующие:<BR>
  <br>
</p>
<p>1. Сколько времени прошло с тех пор, как процесс был выгружен на диск или 
  загружен с диска?<BR>
</p>
<p>2. Сколько времени процесс уже использовал процессор?<BR>
</p>
<p>3. Каков размер процесса (маленькие процессы не мешают)?<BR>
</p>
<p>4. Какова важность процесса?<BR>
  <br>
</p>
<p>Третий уровень планирования отвечает за доступ процессов, находящихся в состоянии 
  готовности, к процессору. Когда идет разговор о &laquo;планировщике&raquo;, 
  обычно имеется в виду именно планировщик процессора. Этим планировщиком используется 
  любой подходящий к ситуации алгоритм, как с прерыванием, так и без. Некоторые 
  из этих алгоритмов мы уже рассмотрели, а с другими еще ознакомимся.<BR>
  <br>
  <br>
<a NAME="03"></a>
  <B><font size="4">Планирование в интерактивных системах</font></B><BR>
  <br>
  Теперь давайте обратимся к алгоритмам планирования, используемым в интерактивных 
  системах. Все они также могут использоваться в качестве планировщика процессора 
  в системах пакетной обработки. В интерактивных системах невозможно трехуровневое 
  планирование, но двухуровневое (планировщик памяти и процессора) возможно и 
  часто используется. Ниже мы рассмотрим алгоритмы для планировщика процессора.<BR>
  <br>
  <br>
  <B>Циклическое планирование</B><BR>
  <br>
  В этом подразделе мы обратимся к некоторым характерным алгоритмам планирования. 
  Одним из наиболее старых, простых, справедливых и часто используемых является 
  алгоритм циклического планирования. Каждому процессу предоставляется некоторый 
  интервал времени процессора, так называемый квант времени. Если к концу кванта 
  времени процесс все еще работает, он прерывается, а управление передается другому 
  процессу. Разумеется, если процесс блокируется или прекращает работу раньше, 
  переход управления происходит в этот момент. Реализация циклического планирования 
  проста. Планировщику нужно всего лишь поддерживать список процессов в состоянии 
  готовности согласно рисунку 2.23, <I>а. </I>Когда процесс исчерпал свой лимит 
  времени, он отправляется в конец списка (рис. 2.23, <I>б).</I><BR>
  <br>
  
</p>
<center>
    <img src="06/Tanenbaum_2_21.jpg" alt="Циклическое планирование"><br>
    <br>
    <font face="Arial"><B>Рис. 2.23.</B> Циклическое планирование: список процессов 
    в состоянии готовности (а): список<br>
    процессов в состоянии готовности после того, как процесс <I>В </I>исчерпал 
    свой квант времени (б)</font><BR>
  </center>
  <br>
<p>Единственным интересным моментом этого алгоритма является длина кванта. Переключение 
  с одного процесса на другой занимает некоторое время — необходимо сохранить 
  и загрузить регистры и карты памяти, обновить таблицы и списки, сохранить и 
  перезагрузить кэш памяти и т. п. Представим, что <B>переключение процессов или 
  переключение контекста, </B>как его иногда называют, занимает 1 мс, включая 
  переключение карт памяти, перезагрузку кэша и т. п. Пусть размер кванта установлен 
  в 4 мс. В таком случае 20 % процессорного времени уйдет на администрирование 
  — это слишком много.<BR>
</p>
<p>Для увеличения эффективности назначим размер кванта, скажем, 100 мс. Теперь 
  пропадает только 1 % времени. Но представьте, что будет в системе с разделением 
  времени, если 10 пользователей одновременно нажмут клавишу возврата каретки. 
  В список будет занесено 10 процессов. Если процессор был свободен, первый процесс 
  будет запущен немедленно, второму придется ждать 100 мс и т. д. Последнему процессу, 
  возможно, придется ждать целую секунду, если все остальные не блокируются за 
  время кванта. Большинству пользователей секундная задержка вряд ли понравится.<BR>
</p>
<p>Важен и тот фактор, что если установленное значение кванта больше среднего 
  интервала работы процессора, переключение процессов будет происходить редко. 
  Напротив, большинство процессов будут совершать блокирующую операцию прежде, 
  чем истечет длительность кванта, вызывая переключение процессов. Устранение 
  принудительных переключений процессов улучшает производительность системы, так 
  как переключения процессов будут происходить только тогда, когда это логически 
  необходимо, то есть когда процесс заблокировался и не может продолжать работу.<BR>
</p>
<p>Вывод можно сформулировать следующим образом: слишком малый квант приведет 
  к частому переключению процессов и небольшой эффективности, но слишком большой 
  квант может привести к медленному реагированию на короткие интерактивные запросы. 
  Значение кванта около 20-50 мс часто является разумным компромиссом.<BR>
  <br>
  <br>
  <B>Приоритетное планирование</B><BR>
  <br>
  В циклическом алгоритме планирования есть важное допущение о том, что все процессы 
  равнозначны. В ситуации компьютера с большим числом пользователей это может 
  быть не так. Например, в университете прежде всего должны обслуживаться деканы, 
  затем профессора, секретари, уборщицы и лишь потом студенты. Необходимость принимать 
  во внимание подобные внешние факторы приводит к <B>приоритетному планированию. 
  </B>Основная идея проста: каждому процессу присваивается приоритет, и управление 
  передается готовому к работе процессу с самым высоким приоритетом.<BR>
</p>
<p>Даже на персональном компьютере с одним пользователем может происходить несколько 
  процессов, отдельные из которых являются более важными, чем другие. Демон, отвечающий 
  за пересылку электронной почты в фоновом режиме, имеет более низкий приоритет, 
  чем процесс, отображающий на экране видеофильм в реальном времени.<BR>
</p>
<p>Чтобы предотвратить бесконечную работу процессов с высоким приоритетом, планировщик 
  может уменьшать приоритет процесса с каждым тактом часов (то есть при каждом 
  прерывании по таймеру). Если в результате приоритет текущего процесса окажется 
  ниже, чем приоритет следующего процесса, произойдет переключение. Возможно предоставление 
  каждому процессу максимального отрезка времени работы. Как только время кончилось, 
  управление передается следующему по приоритету процессу.<BR>
</p>
<p>Приоритеты процессам могут присваиваться статически или динамически. На военной 
  базе процессу, запущенному генералом, присваивается приоритет 100, полковником 
  — 90, майором — 80, капитаном — 70, лейтенантом — 60 и т. д. А в коммерческом 
  компьютерном центре выполнение заданий с высоким приоритетом может стоить 100 
  долларов в час, со средним — 75, с низким — 50. В системе UNIX есть команда 
  <I>nice, </I>позволяющая пользователю добровольно снизить приоритет своих процессов, 
  чтобы быть вежливым по отношению к остальным пользователям. Этой командой никто 
  никогда не пользуется.<BR>
</p>
<p>Система может динамически назначать приоритеты для достижения своих целей. 
  Например, некоторые процессы сильно ограничены возможностями устройств ввода-вывода 
  и большую часть времени проводят в ожидании завершения операций ввода-вывода. 
  Когда бы ни потребовался процессор такому процессу, его следует немедленно предоставить, 
  чтобы процесс мог начать следующий запрос ввода-вывода, который будет выполняться 
  параллельно с вычислениями другого процесса. Если заставить процесс, ограниченный 
  возможностями устройств ввода-вывода, длительное время ждать доступа к процессору, 
  он будет неоправданно долго находиться в памяти. Простой алгоритм обслуживания 
  процессов, ограниченных возможностями устройств ввода-вывода, состоит в установке 
  приоритета, равного 1/<I>f</I>, где <I>f </I>— часть использованного в последний 
  раз кванта. Процесс, использовавший всего 1 мс из 50 мс кванта, получит приоритет 
  50, процесс, использовавший 25 мс, получит приоритет 2, а процесс, использовавший 
  весь квант, получит приоритет 1.<BR>
</p>
<p>Часто бывает удобно сгруппировать процессы в классы по приоритетам и использовать 
  приоритетное планирование среди классов, но циклическое планирование внутри 
  каждого класса. На рис. 2.24 представлена система с четырьмя классами приоритетов. 
  Алгоритм планирования выглядит следующим образом: пока в классе 4 есть готовые 
  к запуску процессы, они запускаются один за другим согласно алгоритму циклического 
  планирования, и каждому отводится квант времени. При этом классы с более низким 
  приоритетом не будут их беспокоить. Если в классе 4 нет готовых к запуску процессов, 
  запускаются процессы класса 3 и т. д. Если приоритеты постоянны, до процессов 
  класса 1 процессор может не дойти никогда.<BR>
  <br>
  
</p>
<center>
    <img src="06/Tanenbaum_2_22.jpg" alt="Приоритетный алгоритм планирования"><br>
    <br>
    <font face="Arial"><B>Рис. 2.24.</B> Приоритетный алгоритм планирования с 
    четырьмя классами приоритетов</font><BR>
  </center>
  <br>
  <br>
  <B>Несколько очередей</B><BR>
  <br>
  Один из первых приоритетных планировщиков был реализован в системе CTSS (compatible 
  time-shared system — совместимая система с разделением времени) [75]. Основной 
  проблемой системы CTSS было слишком медленное переключение процессов, поскольку 
  в памяти компьютера IBM 7094 мог находиться только один процесс. Каждое переключение 
  означало выгрузку текущего процесса на диск и считывание нового процесса с диска. 
  Разработчики CTSS быстро сообразили, что эффективность будет выше, если процессам, 
  ограниченным возможностями процессора, выделять больший квант времени, чем если 
  предоставлять им небольшие кванты, но часто. С одной стороны, это уменьшит количество 
  перекачек из памяти на диск, а с другой — приведет к ухудшению времени отклика, 
  как мы уже видели. В результате было разработано решение с классами приоритетов. 
  Процессам класса с высшим приоритетом выделялся один квант, процессам следующего 
  класса — два кванта, следующего — четыре кванта и т. д. Когда процесс использовал 
  все отведенное ему время, он перемещался на класс ниже.<BR>
<p>В качестве примера рассмотрим процесс, которому необходимо производить вычисления 
  в течение 100 квантов. Вначале ему будет предоставлен один квант, затем он будет 
  перекачан на диск. В следующий раз ему достанется 2 кванта, затем 4, 8, 16, 
  32, 64, хотя из 64 он использует только 37. В этом случае понадобится всего 
  7 перекачек (включая первоначальную загрузку) вместо 100, которые понадобились 
  бы при использовании циклического алгоритма. Помимо этого, по мере погружения 
  в очереди приоритетов процесс будет все реже запускаться, предоставляя процессор 
  более коротким процессам.<BR>
</p>
<p>Чтобы процессу, который при запуске считался долгим, но позже стал интерактивным, 
  не погибнуть в недрах планирования, была разработана следующая стратегия. Как 
  только с терминала приходит сигнал возврата каретки, процесс, соответствующий 
  этому терминалу, переносится в класс высшего приоритета, поскольку предполагается, 
  что он становится интерактивным. Однажды пользователь, запустивший процесс, 
  сильно ограниченный возможностями процессора, обнаружил, что бездумное нажимание 
  клавиши возврата каретки существенно уменьшает время отклика, и рассказал об 
  этом друзьям. Мораль этой истории такова: осуществить задуманное на практике 
  гораздо сложней, чем в теории.<BR>
</p>
<p>Для разделения процессов по классам используются также многие другие алгоритмы. 
  Например, в системе XDS 940, разработанной в Беркли [192], было четыре класса 
  приоритетов, называвшихся: терминал, ввод-вывод, короткий квант и длинный квант. 
  Когда запускался процесс, ожидающий вывода на терминал, он перемещался в класс 
  высшего приоритета (терминал). Когда снималась блокировка процесса, ожидавшего 
  доступа к диску, он перемещался во второй класс. Если к концу отведенного времени 
  процесс все еще работал, он сначала перемещался в третий класс. Если процесс 
  слишком много раз полностью использовал свой квант времени, не блокируясь на 
  терминале или другом устройстве ввода-вывода, он перемещался в последний класс. 
  Этот метод используется во многих системах для предоставления преимущества интерактивным 
  процессам по сравнению с фоновыми.<BR>
  <br>
  <br>
  <B>&laquo;Самый короткий процесс — следующий&raquo;</B><BR>
  <br>
  Поскольку алгоритм &laquo;Кратчайшая задача — первая&raquo; минимизирует среднее 
  оборотное время в системах пакетной обработки, хотелось бы использовать его 
  и в интерактивных системах. В известной степени это возможно. Интерактивные 
  процессы чаще всего следуют схеме &laquo;ожидание команды, исполнение команды, 
  ожидание команды, исполнение команды...&raquo; Если рассматривать выполнение 
  каждой команды как отдельную задачу, можно минимизировать общее среднее время 
  отклика, запуская первой самую короткую задачу. Единственная проблема состоит 
  в том, чтобы понять, какой из ожидающих процессов самый короткий.<BR>
</p>
<p>Один из методов основывается на оценке длины процесса, базирующейся на предыдущем 
  поведении процесса. При этом запускается процесс, у которого оцененное время 
  самое маленькое. Допустим, что предполагаемое время исполнения команды равно 
  <I>Т<SUB>0</SUB> </I>и предполагаемое время следующего запуска равно <I>Т<SUB>1</SUB>.</I> 
  Можно улучшить оценку времени, взяв взвешенную сумму этих времен <I>аТ<SUB>0</SUB> 
  </I>+ (1 - <I>а)Т<SUB>1</SUB>. </I>Выбирая соответствующее значение <I>а, </I>мы 
  можем заставить алгоритм оценки быстро забывать о предыдущих запусках или, наоборот, 
  помнить о них в течение долгого времени. Взяв <I>а</I> = 1/2, мы получим серию 
  оценок:<BR>
  <br>
  <font face="Arial">Т<SUB>0</SUB>, Т<SUB>0</SUB>/2 + Т<SUB>1</SUB>/2, Т<SUB>0</SUB>/4 
  + Т<SUB>1</SUB>/4 + Т<SUB>1</SUB>/2, Т<SUB>0</SUB>/8 + Т<SUB>1</SUB>/8 + <I>Т<SUB>2</SUB>/4</I> 
  + <I>Т<SUB>3</SUB>/2</I>.</font><BR>
  <br>
</p>
<p>После трех запусков вес <I>Т</I><SUB>0</SUB> в оценке уменьшится до 1/8.<BR>
</p>
<p>Метод оценки следующего значения серии через взвешенное среднее предыдущего 
  значения и предыдущей оценки часто называют старением. Этот метод применим во 
  многих ситуациях, где необходима оценка по предыдущим значениям. Проще всего 
  реализовать старение при <I>а </I>= 1/2. На каждом шаге нужно всего лишь добавить 
  к текущей оценке новое значение и разделить сумму пополам (сдвинув вправо на 
  1 бит).<BR>
  <br>
  <br>
  <B>Гарантированное планирование</B><BR>
  <br>
  Принципиально другим подходом к планированию является предоставление пользователям 
  реальных обещаний и затем их выполнение. Вот одно обещание, которое легко произнести 
  и легко выполнить: если вместе с вами процессором пользуются <I>п </I>пользователей, 
  вам будет предоставлено 1/<I>п </I>мощности процессора. И в системе с одним 
  пользователем и <I>п </I>запущенными процессорами каждому достанется 1/<I>n</I> 
  циклов процессора.<BR>
</p>
<p>Чтобы выполнить это обещание, система должна отслеживать распределение процессора 
  между процессами с момента создания каждого процесса. Затем система рассчитывает 
  количество ресурсов процессора, на которое процесс имеет право, например время 
  с момента создания, деленное на <I>п.</I> Теперь можно сосчитать отношение времени, 
  предоставленного процессу, к времени, на которое он имеет право. Полученное 
  значение 0,5 означает, что процессу выделили только половину положенного, а 
  2,0 означает, что процессу досталось в два раза больше, чем положено. Затем 
  запускается процесс, у которого это отношение наименьшее, пока оно не станет 
  больше, чем у его ближайшего соседа.<BR>
  <br>
  <br>
  <B>Лотерейное планирование</B><BR>
  <br>
  Хотя идея обещаний пользователям и их выполнения хороша, но ее трудно реализовать. 
  Для более простой реализации предсказуемых результатов используется другой алгоритм, 
  называемый лотерейным планированием [352].<BR>
</p>
<p>В основе алгоритма лежит раздача процессам лотерейных билетов на доступ к 
  различным ресурсам, в том числе и к процессору. Когда планировщику необходимо 
  принять решение, выбирается случайным образом лотерейный билет, и его обладатель 
  получает доступ к ресурсу. Что касается доступа к процессору, &laquo;лотерея&raquo; 
  может происходить 50 раз в секунду, и победитель получает 20 мс времени процессора.<BR>
</p>
<p>Если перефразировать Джорджа Оруэлла: &laquo;Все процессы равны, но некоторые 
  равнее других&raquo;. Более важным процессам можно раздать дополнительные билеты, 
  чтобы увеличить вероятность выигрыша. Если всего 100 билетов и 20 из них находятся 
  у одного процесса, то ему достанется 20 % времени процессора. В отличие от приоритетного 
  планировщика, в котором очень трудно оценить, что означает, скажем, приоритет 
  40, в лотерейном планировании все очевидно. Каждый процесс получит процент ресурсов, 
  примерно равный проценту имеющихся у него билетов.<BR>
</p>
<p>Лотерейное планирование характеризуется несколькими интересными свойствами. 
  Например, если при создании процессу достается несколько билетов, то уже в следующей 
  лотерее его шансы на выигрыш пропорциональны количеству билетов. Другими словами, 
  лотерейное планирование обладает высокой отзывчивостью.<BR>
</p>
<p>Взаимодействующие процессы могут при необходимости обмениваться билетами. 
  Так, если клиентский процесс посылает сообщение серверному процессу и затем 
  блокируется, он может передать все свои билеты серверному процессу, чтобы увеличить 
  шанс запуска сервера. Когда серверный процесс заканчивает работу, он может вернуть 
  все билеты обратно. Действительно, если клиентов нет, то серверу билеты вовсе 
  не нужны.<BR>
</p>
<p>Лотерейное планирование позволяет решать задачи, которые не решить с помощью 
  других алгоритмов. В качестве примера можно привести видеосервер, на котором 
  несколько процессов передают своим клиентам потоки видеоинформации с различной 
  частотой кадров. Предположим, что процессы используют частоты 10, 20 и 25 кадров 
  в секунду. Предоставив процессам соответственно 10, 20 и 25 билетов, можно реализовать 
  загрузку процессора в желаемой пропорции 10:20:25.<BR>
  <br>
  <br>
  <B>Справедливое планирование</B><BR>
  <br>
  До сих пор мы предполагали, что каждый процесс управляется независимо от того, 
  кто его хозяин. Поэтому если пользователь 1 создаст 9 процессов, а пользователь 
  2 — 1 процесс, то с использованием циклического планирования или в случае равных 
  приоритетов пользователю 1 достанется 90 % процессора, а пользователю 2 всего 
  10.<BR>
</p>
<p>Чтобы избежать подобных ситуаций, некоторые системы обращают внимание на хозяина 
  процесса перед планированием. В такой модели каждому пользователю достается 
  некоторая доля процессора, и планировщик выбирает процесс в соответствии с этим 
  фактом. Если в нашем примере каждому из пользователей было обещано по 50 % процессора, 
  то им достанется по 50 % процессора, независимо от количества процессов.<BR>
</p>
<p>В качестве примера рассмотрим систему и двух пользователей, каждому из которых 
  отведено по 50 % процессора. У первого пользователя четыре процесса: <I>А, В, 
  С </I>и <I>D, у </I>второго один процесс <I>Е. </I>Если используется циклическое 
  планирование, цепочка процессов, удовлетворяющая всем требованиям, будет выглядеть 
  следующим образом:<BR>
  <br>
  <font face="Arial">A E B E C E D E A E B E C E D E...</font><BR>
  <br>
</p>
<p>С другой стороны, если первому пользователю положено вдвое больше ресурсов, 
  чем второму, мы получим<BR>
  <br>
  <font face="Arial">A B E C D E A B E C D E...</font><BR>
  <br>
</p>
<p>Существует множество других решений, используемых в зависимости от конкретных 
  представлений о справедливости.<BR>
  <br>
  <br>
<a NAME="04"></a>
  <B><font size="4">Планирование в системах реального времени</font></B><BR>
  <br>
  В системах реального времени существенную роль играет время. Чаще всего одно 
  или несколько внешних физических устройств генерируют входные сигналы, и компьютер 
  должен адекватно на них реагировать в течение заданного промежутка времени. 
  Например, компьютер в проигрывателе компакт-дисков получает биты от дисковода 
  и должен за очень маленький промежуток времени конвертировать их в музыку. Если 
  процесс конвертации будет слишком долгим, звук окажется искаженным. Подобные 
  системы также используются для наблюдения за пациентами в палатах интенсивной 
  терапии, в качестве автопилота самолета, для управления роботами на автоматизированном 
  производстве. В любом из этих случаев запоздалая реакция ничуть не лучше, чем 
  отсутствие реакции.<BR>
</p>
<p>Системы реального времени делятся на жесткие системы реального времени, что 
  означает наличие жестких сроков для каждой задачи (в них обязательно надо укладываться), 
  и гибкие системы реального времени, в которых нарушения временного графика нежелательны, 
  но допустимы. В обоих случаях реализуется разделение программы на несколько 
  процессов, каждый из которых предсказуем. Эти процессы чаще всего бывают короткими 
  и завершают свою работу в течение секунды. Когда появляется внешний сигнал, 
  именно планировщик должен обеспечить соблюдение графика.<BR>
</p>
<p>Внешние события, на которые система должна реагировать, можно разделить на 
  периодические (возникающие через регулярные интервалы времени) и непериодические 
  (возникающие непредсказуемо). Возможно наличие нескольких периодических потоков 
  событий, которые система должна обрабатывать. В зависимости от времени, затрачиваемого 
  на обработку каждого из событий, может оказаться, что система не в состоянии 
  своевременно обработать все события. Если в систему поступает <I>т </I>периодических 
  событий, событие с номером <I>i</I> поступает с периодом <I>P<SUB>i</SUB>, </I>и 
  на его обработку уходит С<I><SUB>i</SUB></I> секунд работы процессора, все потоки 
  могут быть своевременно обработаны только при выполнении условия<BR>
  <br>
  
</p>
<center>
    <img src="06/Tanenbaum_2_23.jpg"><br>
  </center>
  <br>
<p>Системы реального времени, удовлетворяющие этому условию, называются поддающимися 
  планированию или планируемыми.<BR>
</p>
<p>В качестве примера рассмотрим гибкую систему реального времени с тремя периодическими 
  сигналами с периодами в 100, 200 и 500 мс соответственно. Если на обработку 
  этих сигналов уходит 50, 30 и 100 мс соответственно, система является поддающейся 
  планированию, поскольку 0,5 + 0,15 + 0,2 &lt; 1. Даже при добавлении четвертого 
  сигнала с периодом в 1 с системой все равно можно будет управлять при помощи 
  планирования, пока время обработки сигнала не будет превышать 150 мс. В этих 
  расчетах существенным является предположение, что время переключения между процессами 
  пренебрежимо мало.<BR>
</p>
<p>Алгоритмы планирования для систем реального времени могут быть как статическими, 
  так и динамическими. В первом случае все решения планирования принимаются заранее, 
  еще до запуска системы. Во втором случае решения планирования принимаются по 
  ходу дела. Статическое планирование применимо только при наличии достоверной 
  информации о работе, которую необходимо выполнить, и о временном графике, которого 
  нужно придерживаться. Динамическое планирование не нуждается в подобных ограничениях. 
  На этом мы отложим изучение алгоритмов планирования и вернемся к ним в главе 
  7, посвященной мультимедийным системам реального времени.<BR>
  <br>
  <br>
<a NAME="05"></a>
  <B><font size="4">Политика и механизм</font></B><BR>
  <br>
  Вплоть до этого момента мы подразумевали, что процессы в системе принадлежат 
  различным пользователям и конкурируют за доступ к процессору. Чаще всего именно 
  так все и выглядит, но возможна ситуация, в которой у одного процесса есть много 
  дочерних процессов, работающих под его управлением. Например, у процесса, управляющего 
  базой данных, может быть много дочерних процессов, обрабатывающих отдельные 
  запросы или выполняющих конкретные функции (анализ запроса, доступ к диску и 
  т. п.). Вполне возможно, что родительский процесс лучше представляет, какой 
  из его дочерних процессов более важен (или для которого фактор времени более 
  критичен), а какой — менее важен. К сожалению, ни один из рассмотренных нами 
  планировщиков не может получать информацию от пользовательских процессов и учитывать 
  ее при принятии решений планирования. В результате планировщики редко принимают 
  оптимальное решение.<BR>
</p>
<p>Решить проблему можно, разделив механизм планирования и политику планирования. 
  Таким образом, мы реализуем ситуацию, в которой алгоритм планирования будет 
  каким-либо образом параметризован, но параметры могут быть заданы процессом 
  пользователя. Обратимся еще раз к примеру базы данных. Пусть ядро использует 
  алгоритм приоритетного планирования, но существует системный запрос, посредством 
  которого процесс может устанавливать (и менять) приоритеты своих дочерних процессов. 
  В этом случае родительский процесс может управлять планированием дочерними процессами, 
  хотя сам он планирования не осуществляет. Механизм определяется ядром, но политику 
  задает процесс пользователя.<BR>
  <br>
  <br>
<a NAME="06"></a>
  <B><font size="4">Планирование потоков</font></B><BR>
  <br>
  В случае нескольких процессов, каждый из которых разделен на несколько потоков, 
  реализуются два уровня параллелизма: на уровне потоков и на уровне процессов. 
  Планирование в таких системах существенно зависит от того, поддерживаются ли 
  потоки на уровне пользователя, на уровне ядра или и те и другие.<BR>
</p>
<p>Для начала рассмотрим потоки на уровне пользователя. Поскольку ядро не знает 
  о существовании потоков, оно выполняет обычное планирование, выбирая процесс 
  <I>А</I> и предоставляя ему квант времени. Планировщик потоков внутри процесса 
  <I>А</I> выбирает поток, например <I>А</I>1. Поскольку в случае потоков прерывания 
  по таймеру нет, выбранный поток будет работать столько, сколько пожелает. Если 
  он займет весь квант процесса <I>А, </I>ядро передаст управление другому процессу.<BR>
</p>
<p>Когда управление снова перейдет к процессу <I>А, </I>поток <I>А</I>1 возобновит 
  работу. Он будет продолжать потреблять все процессорное время, предоставляемое 
  процессу <I>А, </I>пока не закончит свою работу. Впрочем, асоциальное поведение 
  потока <I>А</I>1 на другие процессы не повлияет. Они будут продолжать получать 
  долю процессорного времени, которую планировщик считает справедливой, независимо 
  от того, что происходит внутри процесса <I>А.</I><BR>
</p>
<p>Теперь представим, что потокам процесса <I>А</I> нужно всего лишь 5 мс из 
  отведенного кванта в 50 мс. Соответственно, каждый из них будет выполнять свою 
  небольшую работу и возвращать процессор планировщику потоков. Это приведет к 
  следующей цепочке: <I>А</I>1, <I>А</I>2, <I>А</I>3, <I>А</I>1, <I>А</I>2, <I>А</I>3, 
  <I>А</I>1, <I>А</I>2, <I>А</I>З, <I>А</I>1, прежде чем управление будет передано 
  процессу <I>В.</I> Эта ситуация представлена на рис. 2.25, <I>а.</I><BR>
  <br>
  
</p>
<center>
    <img src="06/Tanenbaum_2_24.jpg" alt="Возможное планирование потоков"><br>
    <br>
    <font face="Arial"><B>Рис. 2.25.</B> Возможное планирование потоков: на уровне 
    пользователя в случае кванта в 50 мс<br>
    и потоков, блокирующихся через 5 мс (а); на уровне ядра с теми же характеристиками 
    (б)</font><BR>
  </center>
  <br>
<p>В качестве алгоритма планирования для системы поддержки исполнения программ 
  можно взять любой из уже рассмотренных нами. Наиболее часто используются алгоритмы 
  циклического и приоритетного планирования. Единственной проблемой является отсутствие 
  таймера, который прерывал бы затянувшуюся работу потока.<BR>
</p>
<p>Теперь рассмотрим потоки на уровне ядра. В этой ситуации ядро выбирает следующий 
  поток. При этом ядро не обязано принимать во внимание, какой поток принадлежит 
  какому процессу, хотя у него есть такая возможность. Потоку предоставляется 
  квант времени и по истечении этого кванта управление передается другому потоку. 
  В случае кванта в 50 мс и потоков, блокирующихся через 5 мс, цепочка длиной 
  в 30 мс может выглядеть так: <I>А</I>1<I>, В</I>1<I>, А</I>2<I>, В</I>2<I>, 
  A</I>3<I>, В</I>3 что было невозможно в случае потоков на уровне пользователя. 
  Эта ситуация представлена на рис. 2.25, <I>б.</I><BR>
</p>
<p>Основное различие между реализацией потоков на уровне пользователя и реализацией 
  их на уровне ядра состоит в производительности. Для переключения потоков на 
  уровне пользователя требуется выполнение всего нескольких машинных команд. Для 
  переключения потоков на уровне ядра нужно выполнить полное переключение контекста 
  с заменой карты памяти и аннулированием кэша, что выполняется на несколько порядков 
  медленнее. С другой стороны, при реализации потоков на уровне пользователя блокировка 
  потока на устройстве ввода-вывода блокирует весь процесс, чего не случается 
  с потоками на уровне ядра.<BR>
</p>
<p>Поскольку ядро знает, что на переключение от потока процесса <I>А </I>к потоку 
  процесса <I>В </I>будет затрачено больше ресурсов, чем на передачу управления 
  следующему потоку процесса <I>А </I>(из-за карты памяти и кэша), эта информация 
  может учитываться при принятии решения планирования. Например, при наличии двух 
  одинаково важных потоков, один из которых принадлежит тому же процессу, что 
  и только что блокированный поток, а второй — другому процессу, предпочтение 
  будет отдано первому потоку.<BR>
</p>
<p>Еще одним важным фактором является возможность совместного использования потоков 
  на уровне пользователя и специализированного планировщика потоков. Рассмотрим, 
  например, web-сервер на рис. 2.7. Пусть один рабочий поток только что заблокирован, 
  а диспетчер и два оставшихся рабочих потока находятся в состоянии готовности. 
  Который из них будет запущен? Система поддержки исполнения программ, которая 
  обладает информацией о задаче каждого потока, выберет следующим диспетчера, 
  чтобы он запустил следующий рабочий поток. Подобная стратегия увеличивает степень 
  параллелизма в среде, где рабочие потоки часто блокируются на обращениях к диску. 
  В случае потоков на уровне ядра оно не знает, чем занимается каждый поток (хотя 
  у них могут быть разные приоритеты). В целом специализированные планировщики 
  потоков лучше управляют приложениями, чем ядро.<BR>
</p>
</BODY>
</HTML>
