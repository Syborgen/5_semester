<HTML>
<HEAD>
<TITLE>Принципы программного обеспечения ввода-вывода</TITLE>
</HEAD>
<BODY>
  <b><font size="6"><center>Принципы программного обеспечения ввода-вывода</center></font></b><br>
  <br>
  Перейдем теперь от рассмотрения аппаратуры ввода-вывода к знакомству с программным 
  обеспечением ввода-вывода. Сначала мы познакомимся с целями программного обеспечения 
  ввода-вывода, а затем с различными способами выполнения операций ввода-вывода 
  с точки зрения операционной системы.<br>
  <br>
  <br>
<a NAME="01"></a>
  <b><font size="4">Задачи программного обеспечения ввода-вывода</font></b><br>
  <br>
  Ключевая концепция разработки программного обеспечения ввода-вывода известна 
  как независимость от устройств. Эта концепция означает возможность написания 
  программ, способных получать доступ к любому устройству ввода-вывода, без предварительного 
  указания конкретного устройства. Например, программа, читающая данные из входного 
  файла, должна с одинаковым успехом работать с файлом на дискете, жестком диске 
  или компакт-диске. При этом не должны требоваться какие-либо изменения в программе. 
  Например, должна быть возможность дать команду вроде<br>
  <br>
<dd> <font face="Arial">sort &lt;input &gt;output</font><br>
  <br>
<dd> и эта команда должна работать, независимо от того, что указано в качестве 
  входного устройства — гибкий диск, IDE-диск, SCSI-диск или клавиатура. В качестве 
  выходного устройства также с равным успехом может быть указан экран, файл на 
  любом диске или принтер. Все проблемы, связанные с отличиями этих устройств, 
  должна решать операционная система.<br>
<dd> Тесно связан с концепцией независимости от устройств принцип единообразного 
  именования. Имя файла или устройства должно быть просто текстовой строкой или 
  целым числом и никоим образом не зависеть от физического устройства. В системе 
  UNIX все диски могут быть произвольным образом интегрированы в иерархию файловой 
  системы, так что пользователю не обязательно знать, какое имя какому устройству 
  соответствует. Например, гибкий диск может быть <b>смонтирован</b> поверх каталога 
  <i>/usr/ast/backup, </i> так что копирование файла в каталог <i>/usr/ast/backup/monday</i> 
  автоматически приведет к копированию файлов на гибкий диск. Таким образом, все 
  файлы и устройства адресуются одним и тем же способом: по имени пути.<br>
<dd> Другим важным аспектом программного обеспечения ввода-вывода является <b>обработка 
  ошибок.</b> Ошибки должны обрабатываться как можно ближе к аппаратуре. Если 
  контроллер обнаружил ошибку чтения, он должен попытаться по возможности исправить 
  эту ошибку сам. Если он не может это сделать, тогда эту ошибку должен обработать 
  драйвер устройства, возможно, попытавшись прочитать этот блок еще раз. Многие 
  ошибки бывают временными, как, например, ошибки чтения, вызванные пылинками 
  на читающих головках. Такие ошибки часто исчезают при повторной попытке чтения 
  блока. Только если нижний уровень не может сам справиться с проблемой, о ней 
  следует информировать верхний уровень. Во многих случаях восстановление после 
  ошибок может осуществляться на нижнем уровне, прозрачно для верхних уровней, 
  то есть так, что верхние уровни даже не будут знать о наличии ошибок.<br>
<dd> Еще одним ключевым вопросом является способ переноса данных: <b>синхронный</b> 
  (блокирующий) против <b>асинхронного </b> (управляемого прерываниями). Большинство 
  операций ввода-вывода на физическом уровне являются асинхронными — центральный 
  процессор запускает перенос данных и отправляется заниматься чем-либо другим, 
  пока не придет прерывание. Программы пользователя значительно легче написать, 
  используя блокирующие операции ввода-вывода — после обращения к системному вызову 
  read программа автоматически приостанавливается до тех пор, пока данные не появятся 
  в буфере. Тем, чтобы операции ввода-вывода, в действительности являющиеся асинхронными, 
  выглядели как блокирующие в программах пользователя, занимается операционная 
  система.<br>
<dd> Еще одним аспектом программного обеспечения ввода-вывода является <b>буферизация.</b> 
  Часто данные, поступающие с устройства, не могут быть сохранены сразу там, куда 
  они в конечном итоге направляются. Например, когда пакет приходит по сети, операционная 
  система не знает, куда его поместить, пока не будет изучено его содержимое, 
  для чего этот пакет нужно где-то временно сохранить. Кроме того, для многих 
  устройств реального времени крайне важными оказываются параметры сроков поступления 
  данных (например для устройств воспроизведения цифрового звука), поэтому полученные 
  данные должны быть помещены в выходной буфер заранее, чтобы скорость, с которой 
  эти данные получаются из буфера воспроизводящей программой, не зависела от скорости 
  заполнения буфера. Таким образом удается избежать неравномерности воспроизведения 
  звука. Буферизация включает копирование данных в значительных количествах, что 
  часто является основным фактором снижения производительности операций ввода-вывода.<br>
<dd> И последним понятием, которое мы упомянем здесь, является понятие выделенных 
  устройств и устройств коллективного использования. С некоторыми устройствами 
  ввода-вывода, такими как диски, может одновременно работать большое количество 
  пользователей. При этом не должно возникать проблем, если несколько пользователей 
  на одном и том же диске одновременно откроют файлы. Другие устройства, такие 
  как накопители на магнитной ленте, должны предоставляться в монопольное владение 
  одному пользователю, пока он не завершит свою работу с этим устройством. После 
  этого накопитель может быть предоставлен другому пользователю. Если два или 
  более пользователей одновременно станут писать вперемешку блоки на одну ленту, 
  то ничего хорошего не получится. Введение понятия выделенных (монопольно используемых) 
  устройств также привносит целый спектр проблем, например, как взаимоблокировки. 
  Тем не менее операционная система должна уметь управлять как устройствами общего 
  доступа, так и выделенными устройствами, позволяя избегать различных потенциальных 
  проблем.<br>
  <br>
  <br>
<a NAME="02"></a>
  <b><font size="4">Программный ввод-вывод</font></b><br>
  <br>
  Существует три фундаментально различных способа осуществления операций ввода-вывода. 
  В этом разделе мы рассмотрим первый способ (программный ввод-вывод). В следующих 
  двух разделах мы познакомимся с остальными разновидностями ввода-вывода (с управляемым 
  прерываниями вводом-выводом и вводом-выводом с использованием DMA). Простейший 
  вид ввода-вывода состоит в том, что всю работу выполняет центральный процессор. 
  Этот метод называется программным вводом-выводом.<br>
<dd> Проще всего проиллюстрировать программный ввод-вывод на примере. Рассмотрим 
  процесс пользователя, которому нужно напечатать на принтере строку из восьми 
  символов &laquo;ABCDEFGH&raquo;. Сначала он собирает эту строку в буфере в пространстве 
  пользователя (рис. 5.5, <i>а</i>).<br>
  <br>
  <center>
    <img src="12/Tanenbaum_5_5.jpg" alt="Этапы печати строки"><br>
    <br>
    <font face="Arial"><b>Рис. 5.5.</b> Этапы печати строки</font><br>
    <br>
  </center>
<dd> Затем, обращаясь к системному вызову, процесс пользователя получает принтер 
  во временное пользование. Если принтер в данный момент оказывается занят другим 
  процессом, обращение к системному вызову на открытие принтера завершится неудачей. 
  Вызывающему процессу либо будет возвращен код ошибки, либо этот процесс будет 
  блокирован до тех пор, пока принтер не освободится, в зависимости от операционной 
  системы и параметров вызова. Получив принтер, процесс пользователя обращается 
  к другому системному вызову, прося операционную систему распечатать строку на 
  принтере.<br>
<dd> Операционная система при этом обычно копирует содержимое буфера со строкой 
  в некий массив, расположенный в пространстве ядра, где ей проще получить к этим 
  данным доступ (поскольку ядру для получения доступа к пространству пользователя, 
  возможно, придется изменять карту памяти). Затем она проверяет, доступен ли 
  в данный момент принтер. Если нет, она ждет его освобождения. Как только принтер 
  становится доступен, операционная система копирует первый символ в регистр данных 
  принтера, используя в данном примере отображение регистров устройств ввода-вывода 
  на память. Это действие активизирует принтер. На бумаге этот символ может сразу 
  не появиться, так как большинство принтеров буферизируют целую строку или даже 
  страницу данных прежде, чем начать собственно печать. Однако на рис. 5.5, <i>б</i> 
  мы видим, что первый символ напечатан, а указатель операционной системы установлен 
  на следующий символ (В).<br>
<dd> Напечатав первый символ на принтере, операционная система проверяет, готов 
  ли принтер к приему следующего символа. Обычно у принтера есть второй регистр, 
  в котором можно прочитать его состояние. При записи символа в регистр данных 
  принтер инвертирует бит готовности в статусном регистре. По окончании обработки 
  полученного символа контроллером принтера бит готовности снова устанавливается, 
  показывая, что принтер готов к приему следующего символа.<br>
<dd> Итак, операционная система ждет, когда принтер снова перейдет в состояние 
  готовности. Когда это происходит, она печатает следующий символ (рис. 5.5, <i>в</i>). 
  Этот цикл продолжается до тех пор, пока не будет распечатана вся строка. После 
  этого управление возвращается процессу пользователя.<br>
<dd> Действия, выполняемые операционной системой, в виде программы на языке С 
  продемонстрированы в листинге 5.1. Сначала данные копируются в ядро. Затем операционная 
  система входит в цикл, в котором на каждой итерации цикла печатает на принтере 
  один символ. Существенный аспект программного ввода-вывода, ясно проиллюстрированный 
  данным примером, состоит в том, что после печати каждого символа процессор в 
  цикле опрашивает готовность устройства. Такое поведение процессора называется 
  опросом или ожиданием готовности, а также активным ожиданием.<br>
  <br>
  <center>
    <font face="Arial"><b>Листинг 5.1.</b> Печать строки при помощи программного 
    ввода-вывода</font><br>
    <br>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="631" HEIGHT="60">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD width="631" height="58"> copy_from_user(buffer, p, count); &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/*p 
          - буфер ядра */<br>
          for (i=0: i&lt;count; i++)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 
          /* цикл символов */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{while (*printer_status_reg 
          != READY); &nbsp;&nbsp;&nbsp;&nbsp;/* цикл ожидания готовности */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; printer_data_reg = p[i];&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;/* 
          печать символа */<br>
          &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
          return_to_user(); </TD>
      </TR>
    </TABLE>
    <br>
  </center>
<dd> Программный ввод-вывод очень легко реализуется, но его существенный недостаток 
  состоит в том, что центральный процессор занимается на все время операции ввода-вывода. 
  Даже если один символ &laquo;печатается&raquo; очень быстро, поскольку все, 
  что нужно сделать принтеру — это поместить этот символ в свой внутренний буфер, 
  принтер обычно не рассчитан на прием символов с той скоростью, с которой их 
  может выдать быстрый процессор. Поэтому большую часть времени центральный процессор 
  проведет в ожидании готовности принтера, что является неэффективным использованием 
  процессорного времени. Такой подход вполне допустим в примитивных встроенных 
  системах, в которых у центрального процессора нет других задач; однако в более 
  сложных, многозадачных системах такой подход неприемлем.<br>
  <br>
  <br>
<a NAME="03"></a>
  <b><font size="4">Управляемый прерываниями ввод-вывод</font></b><br>
  <br>
  Рассмотрим теперь случай принтера, не буферизирующего символы, а печатающего 
  их сразу по прибытии. Если принтер может печатать, скажем, 100 символов в секунду, 
  то на печать каждого символа уходит 10 мс. Это значит, что после записи каждого 
  символа в регистр данных принтера центральный процессор должен ждать в цикле 
  целых 10 мс, пока ему не позволят записать в регистр следующий символ. Этого 
  времени более чем достаточно для переключения контекста и запуска другого процесса 
  на 10 мс, которые в противном случае просто будут потеряны. Предоставить центральному 
  процессору возможность делать что-нибудь в то время, когда принтер переходит 
  в состояние готовности, можно при помощи прерываний. Когда выполняется системный 
  вызов печати строки, как мы уже показывали, буфер копируется в пространство 
  ядра и первый символ строки копируется на принтер, как только принтер выставит 
  бит готовности. После этого центральный процессор вызывает планировщик, который 
  запускает какой-либо другой процесс. Процесс, попросивший распечатать строку, 
  оказывается заблокирован на весь период печати строки. Работа, выполняемая при 
  системном вызове, показана на рис. 5.6, <i>а</i>.<br>
  <br>
  <center>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="653" HEIGHT="181">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD width="338" height="179"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="307" HEIGHT="60">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD width="307" height="58"> copy_from_user(buffer,p,count);<br>
                enable_interrupts( );<br>
                while(*printer_status_reg != READY);<br>
                *printer_data_register = p[0];<br>
                scheduler( ); </TD>
            </TR>
          </TABLE>
          <br>
          <br>
          <br>
          <br>
          <br>
          <center>
            <i>а</i> 
          </center>
        </TD>
        <TD width="324" height="179"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="268" HEIGHT="61">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD width="303" height="59"> if (count = = 0)<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{unblock_user( );<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;} else<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;{*printer_data_register=p[i];<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; count=count-l;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; i=i+1;<br>
                &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}<br>
                acknowledge_interrupt( );<br>
                return_from_interrupt( ); </TD>
            </TR>
          </TABLE>
          <br>
          <center>
            <i>б</i> 
          </center>
        </TD>
      </TR>
    </TABLE>
    <br>
    <font face="Arial"><b>Рис. 5.6.</b> Печать строки при помощи ввода-вывода, 
    управляемого прерываниями: программа,<br>
    выполняемая при обращении к системному вызову (а); процедура обработки прерываний 
    (б)</font><br>
  </center>
  <br>
<dd> Когда принтер напечатал символ и готов принять следующий, он инициирует прерывание. 
  Это прерывание вызывает остановку текущего процесса и сохранение его состояния. 
  Затем запускается процедура обработки прерывания от принтера. Грубый вариант 
  этой программы показан на рис. 5.6, <i>б</i>. Если напечатаны все символы, обработчик 
  прерывания предпринимает необходимые меры для разблокировки процесса пользователя. 
  В противном случае он печатает следующий символ, подтверждает прерывание и возвращается 
  к процессу, выполнение которого было приостановлено прерыванием от принтера.<br>
  <br>
  <br>
<a NAME="04"></a>
  <b><font size="4">Ввод-вывод с использованием DMA</font></b><br>
  <br>
  Очевидный недостаток управляемого прерываниями ввода-вывода состоит в том, что 
  прерывания происходят при печати каждого символа. Обработка прерываний занимает 
  определенное время, поэтому такая схема не является эффективной. Решение этой 
  проблемы заключается в использовании DMA. Идея состоит в том, чтобы позволить 
  контроллеру DMA поставлять принтеру символы по одному, не беспокоя при этом 
  центральный процессор. По существу, этот метод почти не отличается от программного 
  ввода-вывода, с той лишь разницей, что всю работу вместо центрального процессора 
  выполняет контроллер DMA. Набросок программы показан на рис. 5.7.<br>
  <br>
  <center>
    <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="599" HEIGHT="109">
      <TR ALIGN="LEFT" VALIGN="TOP"> 
        <TD width="341" height="107"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="286" HEIGHT="60">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD width="286" height="58"> copy_from_user(buffer,p,count);<br>
                set_up_DMA_controller( );<br>
                scheduler( ); </TD>
            </TR>
          </TABLE>
          <br>
          <center>
            <i>а</i> 
          </center>
        </TD>
        <TD width="267" height="107"> 
          <TABLE FRAME="BOX" RULES="ALL" BORDER="0" CELLSPACING="0" CELLPADDING="0" WIDTH="261" HEIGHT="61">
            <TR ALIGN="LEFT" VALIGN="TOP"> 
              <TD width="296" height="59"> acknowledge_interrupt( );<br>
                unblock_user( );<br>
                return_from_interrupt( ); </TD>
            </TR>
          </TABLE>
          <br>
          <center>
            <i>б</i> 
          </center>
        </TD>
      </TR>
    </TABLE>
    <br>
    <font face="Arial"><b>Рис. 5.7.</b> Печать строки при помощи DMA: программа, 
    выполняемая при обращении к системному вызову (а);<br>
    процедура обработки прерываний (б)</font><br>
  </center>
  <br>
<dd> Наибольший выигрыш от использования DMA состоит в уменьшении количества прерываний 
  с одного на печатаемый символ до одного на печатаемый буфер. Если символов много, 
  а прерывания обрабатываются медленно, то этот выигрыш весьма существенен. С 
  другой стороны, контроллер DMA обычно значительно уступает центральному процессору 
  в скорости. Если контроллер DMA не может поддерживать полную скорость ввода 
  или вывода с внешнего устройства, либо у центрального процессора нет других 
  задач во время ожидания прерывания от DMA, тогда оба предыдущих метода ввода-вывода 
  (программный и управляемый прерываниями) будут предпочтительнее.<br>
</BODY>
</HTML>
